(this.nativeLog || function(s) {console.log(s)})('START WEEX HTML5: 0.2.18 BUILD 20160609');
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1)
	var Weex = __webpack_require__(2)
	module.exports = Weex

/***/ },
/* 1 */
/***/ function(module, exports) {

	(this.nativeLog || function(s) {console.log(s)})('START JS FRAMEWORK: 0.13.9');
	/******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(global) {'use strict';
		
		__webpack_require__(1);
		
		var _framework = __webpack_require__(76);
		
		var framework = _interopRequireWildcard(_framework);
		
		var _package = __webpack_require__(105);
		
		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
		
		var _loop = function _loop(methodName) {
		    global[methodName] = function () {
		        var ret = framework[methodName].apply(framework, arguments);
		        if (ret instanceof Error) {
		            console.error(ret.toString());
		        } else if (ret instanceof Array) {
		            ret.forEach(function (r) {
		                if (r instanceof Error) {
		                    console.error(r.toString());
		                }
		            });
		        }
		        return ret;
		    };
		};
		
		for (var methodName in framework) {
		    _loop(methodName);
		}
		
		Object.assign(global, {
		    frameworkVersion: _package.version,
		    needTransformerVersion: _package.optionalDependencies['weex-transformer']
		});
		
		/**
		 * register methods
		 */
		var methods = __webpack_require__(106);
		var _global = global;
		var registerMethods = _global.registerMethods;
		
		registerMethods(methods);
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		__webpack_require__(2);
		
		__webpack_require__(40);
		
		__webpack_require__(74);
		
		__webpack_require__(75);
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		__webpack_require__(3);
	
	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		__webpack_require__(4);
		module.exports = __webpack_require__(7).Object.assign;
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// 19.1.3.1 Object.assign(target, source)
		var $export = __webpack_require__(5);
		
		$export($export.S + $export.F, 'Object', { assign: __webpack_require__(23) });
	
	/***/ },
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var global = __webpack_require__(6),
		    core = __webpack_require__(7),
		    hide = __webpack_require__(8),
		    redefine = __webpack_require__(18),
		    ctx = __webpack_require__(21),
		    PROTOTYPE = 'prototype';
		
		var $export = function $export(type, name, source) {
		  var IS_FORCED = type & $export.F,
		      IS_GLOBAL = type & $export.G,
		      IS_STATIC = type & $export.S,
		      IS_PROTO = type & $export.P,
		      IS_BIND = type & $export.B,
		      target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE],
		      exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
		      expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}),
		      key,
		      own,
		      out,
		      exp;
		  if (IS_GLOBAL) source = name;
		  for (key in source) {
		    // contains in native
		    own = !IS_FORCED && target && target[key] !== undefined;
		    // export native or passed
		    out = (own ? target : source)[key];
		    // bind timers to global for call from export context
		    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
		    // extend global
		    if (target) redefine(target, key, out, type & $export.U);
		    // export
		    if (exports[key] != out) hide(exports, key, exp);
		    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
		  }
		};
		global.core = core;
		// type bitmap
		$export.F = 1; // forced
		$export.G = 2; // global
		$export.S = 4; // static
		$export.P = 8; // proto
		$export.B = 16; // bind
		$export.W = 32; // wrap
		$export.U = 64; // safe
		$export.R = 128; // real proto method for `library`
		module.exports = $export;
	
	/***/ },
	/* 6 */
	/***/ function(module, exports) {
	
		'use strict';
		
		// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
		var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
		if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
		'use strict';
		
		var core = module.exports = { version: '2.1.5' };
		if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
	
	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var dP = __webpack_require__(9),
		    createDesc = __webpack_require__(17);
		module.exports = __webpack_require__(13) ? function (object, key, value) {
		  return dP.f(object, key, createDesc(1, value));
		} : function (object, key, value) {
		  object[key] = value;
		  return object;
		};
	
	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var anObject = __webpack_require__(10),
		    IE8_DOM_DEFINE = __webpack_require__(12),
		    toPrimitive = __webpack_require__(16),
		    dP = Object.defineProperty;
		
		exports.f = __webpack_require__(13) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
		  anObject(O);
		  P = toPrimitive(P, true);
		  anObject(Attributes);
		  if (IE8_DOM_DEFINE) try {
		    return dP(O, P, Attributes);
		  } catch (e) {/* empty */}
		  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
		  if ('value' in Attributes) O[P] = Attributes.value;
		  return O;
		};
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var isObject = __webpack_require__(11);
		module.exports = function (it) {
		  if (!isObject(it)) throw TypeError(it + ' is not an object!');
		  return it;
		};
	
	/***/ },
	/* 11 */
	/***/ function(module, exports) {
	
		'use strict';
		
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
		
		module.exports = function (it) {
		  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
		};
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		module.exports = !__webpack_require__(13) && !__webpack_require__(14)(function () {
		  return Object.defineProperty(__webpack_require__(15)('div'), 'a', { get: function get() {
		      return 7;
		    } }).a != 7;
		});
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// Thank's IE8 for his funny defineProperty
		module.exports = !__webpack_require__(14)(function () {
		  return Object.defineProperty({}, 'a', { get: function get() {
		      return 7;
		    } }).a != 7;
		});
	
	/***/ },
	/* 14 */
	/***/ function(module, exports) {
	
		"use strict";
		
		module.exports = function (exec) {
		  try {
		    return !!exec();
		  } catch (e) {
		    return true;
		  }
		};
	
	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var isObject = __webpack_require__(11),
		    document = __webpack_require__(6).document
		// in old IE typeof document.createElement is 'object'
		,
		    is = isObject(document) && isObject(document.createElement);
		module.exports = function (it) {
		  return is ? document.createElement(it) : {};
		};
	
	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// 7.1.1 ToPrimitive(input [, PreferredType])
		var isObject = __webpack_require__(11);
		// instead of the ES6 spec version, we didn't implement @@toPrimitive case
		// and the second argument - flag - preferred type is a string
		module.exports = function (it, S) {
		  if (!isObject(it)) return it;
		  var fn, val;
		  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
		  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
		  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
		  throw TypeError("Can't convert object to primitive value");
		};
	
	/***/ },
	/* 17 */
	/***/ function(module, exports) {
	
		"use strict";
		
		module.exports = function (bitmap, value) {
		  return {
		    enumerable: !(bitmap & 1),
		    configurable: !(bitmap & 2),
		    writable: !(bitmap & 4),
		    value: value
		  };
		};
	
	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var global = __webpack_require__(6),
		    hide = __webpack_require__(8),
		    has = __webpack_require__(19),
		    SRC = __webpack_require__(20)('src'),
		    TO_STRING = 'toString',
		    $toString = Function[TO_STRING],
		    TPL = ('' + $toString).split(TO_STRING);
		
		__webpack_require__(7).inspectSource = function (it) {
		  return $toString.call(it);
		};
		
		(module.exports = function (O, key, val, safe) {
		  var isFunction = typeof val == 'function';
		  if (isFunction) has(val, 'name') || hide(val, 'name', key);
		  if (O[key] === val) return;
		  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
		  if (O === global) {
		    O[key] = val;
		  } else {
		    if (!safe) {
		      delete O[key];
		      hide(O, key, val);
		    } else {
		      if (O[key]) O[key] = val;else hide(O, key, val);
		    }
		  }
		  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
		})(Function.prototype, TO_STRING, function toString() {
		  return typeof this == 'function' && this[SRC] || $toString.call(this);
		});
	
	/***/ },
	/* 19 */
	/***/ function(module, exports) {
	
		"use strict";
		
		var hasOwnProperty = {}.hasOwnProperty;
		module.exports = function (it, key) {
		  return hasOwnProperty.call(it, key);
		};
	
	/***/ },
	/* 20 */
	/***/ function(module, exports) {
	
		'use strict';
		
		var id = 0,
		    px = Math.random();
		module.exports = function (key) {
		  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
		};
	
	/***/ },
	/* 21 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// optional / simple context binding
		var aFunction = __webpack_require__(22);
		module.exports = function (fn, that, length) {
		  aFunction(fn);
		  if (that === undefined) return fn;
		  switch (length) {
		    case 1:
		      return function (a) {
		        return fn.call(that, a);
		      };
		    case 2:
		      return function (a, b) {
		        return fn.call(that, a, b);
		      };
		    case 3:
		      return function (a, b, c) {
		        return fn.call(that, a, b, c);
		      };
		  }
		  return function () /* ...args */{
		    return fn.apply(that, arguments);
		  };
		};
	
	/***/ },
	/* 22 */
	/***/ function(module, exports) {
	
		'use strict';
		
		module.exports = function (it) {
		  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
		  return it;
		};
	
	/***/ },
	/* 23 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		// 19.1.2.1 Object.assign(target, source, ...)
		
		var getKeys = __webpack_require__(24),
		    gOPS = __webpack_require__(37),
		    pIE = __webpack_require__(38),
		    toObject = __webpack_require__(39),
		    IObject = __webpack_require__(27),
		    $assign = Object.assign;
		
		// should work with symbols and should have deterministic property order (V8 bug)
		module.exports = !$assign || __webpack_require__(14)(function () {
		  var A = {},
		      B = {},
		      S = Symbol(),
		      K = 'abcdefghijklmnopqrst';
		  A[S] = 7;
		  K.split('').forEach(function (k) {
		    B[k] = k;
		  });
		  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
		}) ? function assign(target, source) {
		  // eslint-disable-line no-unused-vars
		  var T = toObject(target),
		      aLen = arguments.length,
		      index = 1,
		      getSymbols = gOPS.f,
		      isEnum = pIE.f;
		  while (aLen > index) {
		    var S = IObject(arguments[index++]),
		        keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
		        length = keys.length,
		        j = 0,
		        key;
		    while (length > j) {
		      if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
		    }
		  }return T;
		} : $assign;
	
	/***/ },
	/* 24 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// 19.1.2.14 / 15.2.3.14 Object.keys(O)
		var $keys = __webpack_require__(25),
		    enumBugKeys = __webpack_require__(36);
		
		module.exports = Object.keys || function keys(O) {
		  return $keys(O, enumBugKeys);
		};
	
	/***/ },
	/* 25 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var has = __webpack_require__(19),
		    toIObject = __webpack_require__(26),
		    arrayIndexOf = __webpack_require__(30)(false),
		    IE_PROTO = __webpack_require__(34)('IE_PROTO');
		
		module.exports = function (object, names) {
		  var O = toIObject(object),
		      i = 0,
		      result = [],
		      key;
		  for (key in O) {
		    if (key != IE_PROTO) has(O, key) && result.push(key);
		  } // Don't enum bug & hidden keys
		  while (names.length > i) {
		    if (has(O, key = names[i++])) {
		      ~arrayIndexOf(result, key) || result.push(key);
		    }
		  }return result;
		};
	
	/***/ },
	/* 26 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// to indexed object, toObject with fallback for non-array-like ES3 strings
		var IObject = __webpack_require__(27),
		    defined = __webpack_require__(29);
		module.exports = function (it) {
		  return IObject(defined(it));
		};
	
	/***/ },
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// fallback for non-array-like ES3 and non-enumerable old V8 strings
		var cof = __webpack_require__(28);
		module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
		  return cof(it) == 'String' ? it.split('') : Object(it);
		};
	
	/***/ },
	/* 28 */
	/***/ function(module, exports) {
	
		"use strict";
		
		var toString = {}.toString;
		
		module.exports = function (it) {
		  return toString.call(it).slice(8, -1);
		};
	
	/***/ },
	/* 29 */
	/***/ function(module, exports) {
	
		"use strict";
		
		// 7.2.1 RequireObjectCoercible(argument)
		module.exports = function (it) {
		  if (it == undefined) throw TypeError("Can't call method on  " + it);
		  return it;
		};
	
	/***/ },
	/* 30 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// false -> Array#indexOf
		// true  -> Array#includes
		var toIObject = __webpack_require__(26),
		    toLength = __webpack_require__(31),
		    toIndex = __webpack_require__(33);
		module.exports = function (IS_INCLUDES) {
		  return function ($this, el, fromIndex) {
		    var O = toIObject($this),
		        length = toLength(O.length),
		        index = toIndex(fromIndex, length),
		        value;
		    // Array#includes uses SameValueZero equality algorithm
		    if (IS_INCLUDES && el != el) while (length > index) {
		      value = O[index++];
		      if (value != value) return true;
		      // Array#toIndex ignores holes, Array#includes - not
		    } else for (; length > index; index++) {
		        if (IS_INCLUDES || index in O) {
		          if (O[index] === el) return IS_INCLUDES || index;
		        }
		      }return !IS_INCLUDES && -1;
		  };
		};
	
	/***/ },
	/* 31 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// 7.1.15 ToLength
		var toInteger = __webpack_require__(32),
		    min = Math.min;
		module.exports = function (it) {
		  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
		};
	
	/***/ },
	/* 32 */
	/***/ function(module, exports) {
	
		"use strict";
		
		// 7.1.4 ToInteger
		var ceil = Math.ceil,
		    floor = Math.floor;
		module.exports = function (it) {
		  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
		};
	
	/***/ },
	/* 33 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var toInteger = __webpack_require__(32),
		    max = Math.max,
		    min = Math.min;
		module.exports = function (index, length) {
		  index = toInteger(index);
		  return index < 0 ? max(index + length, 0) : min(index, length);
		};
	
	/***/ },
	/* 34 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var shared = __webpack_require__(35)('keys'),
		    uid = __webpack_require__(20);
		module.exports = function (key) {
		  return shared[key] || (shared[key] = uid(key));
		};
	
	/***/ },
	/* 35 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var global = __webpack_require__(6),
		    SHARED = '__core-js_shared__',
		    store = global[SHARED] || (global[SHARED] = {});
		module.exports = function (key) {
		  return store[key] || (store[key] = {});
		};
	
	/***/ },
	/* 36 */
	/***/ function(module, exports) {
	
		'use strict';
		
		// IE 8- don't enum bug keys
		module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
	
	/***/ },
	/* 37 */
	/***/ function(module, exports) {
	
		"use strict";
		
		exports.f = Object.getOwnPropertySymbols;
	
	/***/ },
	/* 38 */
	/***/ function(module, exports) {
	
		"use strict";
		
		exports.f = {}.propertyIsEnumerable;
	
	/***/ },
	/* 39 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// 7.1.13 ToObject(argument)
		var defined = __webpack_require__(29);
		module.exports = function (it) {
		  return Object(defined(it));
		};
	
	/***/ },
	/* 40 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(global) {'use strict';
		
		// fix Promise Problem on JSContext of iOS7~8
		// @see https://bugs.webkit.org/show_bug.cgi?id=135866
		global.Promise = null;
		__webpack_require__(41);
		__webpack_require__(44);
		__webpack_require__(55);
		__webpack_require__(59);
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 41 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		// 19.1.3.6 Object.prototype.toString()
		
		var classof = __webpack_require__(42),
		    test = {};
		test[__webpack_require__(43)('toStringTag')] = 'z';
		if (test + '' != '[object z]') {
		  __webpack_require__(18)(Object.prototype, 'toString', function toString() {
		    return '[object ' + classof(this) + ']';
		  }, true);
		}
	
	/***/ },
	/* 42 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// getting tag from 19.1.3.6 Object.prototype.toString()
		var cof = __webpack_require__(28),
		    TAG = __webpack_require__(43)('toStringTag')
		// ES3 wrong here
		,
		    ARG = cof(function () {
		  return arguments;
		}()) == 'Arguments';
		
		// fallback for IE11 Script Access Denied error
		var tryGet = function tryGet(it, key) {
		  try {
		    return it[key];
		  } catch (e) {/* empty */}
		};
		
		module.exports = function (it) {
		  var O, T, B;
		  return it === undefined ? 'Undefined' : it === null ? 'Null'
		  // @@toStringTag case
		  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
		  // builtinTag case
		  : ARG ? cof(O)
		  // ES3 arguments fallback
		  : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
		};
	
	/***/ },
	/* 43 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var store = __webpack_require__(35)('wks'),
		    uid = __webpack_require__(20),
		    _Symbol = __webpack_require__(6).Symbol,
		    USE_SYMBOL = typeof _Symbol == 'function';
		module.exports = function (name) {
		  return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
		};
	
	/***/ },
	/* 44 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var $at = __webpack_require__(45)(true);
		
		// 21.1.3.27 String.prototype[@@iterator]()
		__webpack_require__(46)(String, 'String', function (iterated) {
		  this._t = String(iterated); // target
		  this._i = 0; // next index
		  // 21.1.5.2.1 %StringIteratorPrototype%.next()
		}, function () {
		  var O = this._t,
		      index = this._i,
		      point;
		  if (index >= O.length) return { value: undefined, done: true };
		  point = $at(O, index);
		  this._i += point.length;
		  return { value: point, done: false };
		});
	
	/***/ },
	/* 45 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var toInteger = __webpack_require__(32),
		    defined = __webpack_require__(29);
		// true  -> String#at
		// false -> String#codePointAt
		module.exports = function (TO_STRING) {
		  return function (that, pos) {
		    var s = String(defined(that)),
		        i = toInteger(pos),
		        l = s.length,
		        a,
		        b;
		    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
		    a = s.charCodeAt(i);
		    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
		  };
		};
	
	/***/ },
	/* 46 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var LIBRARY = __webpack_require__(47),
		    $export = __webpack_require__(5),
		    redefine = __webpack_require__(18),
		    hide = __webpack_require__(8),
		    has = __webpack_require__(19),
		    Iterators = __webpack_require__(48),
		    $iterCreate = __webpack_require__(49),
		    setToStringTag = __webpack_require__(53),
		    getPrototypeOf = __webpack_require__(54),
		    ITERATOR = __webpack_require__(43)('iterator'),
		    BUGGY = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
		,
		    FF_ITERATOR = '@@iterator',
		    KEYS = 'keys',
		    VALUES = 'values';
		
		var returnThis = function returnThis() {
		  return this;
		};
		
		module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
		  $iterCreate(Constructor, NAME, next);
		  var getMethod = function getMethod(kind) {
		    if (!BUGGY && kind in proto) return proto[kind];
		    switch (kind) {
		      case KEYS:
		        return function keys() {
		          return new Constructor(this, kind);
		        };
		      case VALUES:
		        return function values() {
		          return new Constructor(this, kind);
		        };
		    }return function entries() {
		      return new Constructor(this, kind);
		    };
		  };
		  var TAG = NAME + ' Iterator',
		      DEF_VALUES = DEFAULT == VALUES,
		      VALUES_BUG = false,
		      proto = Base.prototype,
		      $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
		      $default = $native || getMethod(DEFAULT),
		      $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined,
		      $anyNative = NAME == 'Array' ? proto.entries || $native : $native,
		      methods,
		      key,
		      IteratorPrototype;
		  // Fix native
		  if ($anyNative) {
		    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
		    if (IteratorPrototype !== Object.prototype) {
		      // Set @@toStringTag to native iterators
		      setToStringTag(IteratorPrototype, TAG, true);
		      // fix for some old engines
		      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
		    }
		  }
		  // fix Array#{values, @@iterator}.name in V8 / FF
		  if (DEF_VALUES && $native && $native.name !== VALUES) {
		    VALUES_BUG = true;
		    $default = function values() {
		      return $native.call(this);
		    };
		  }
		  // Define iterator
		  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
		    hide(proto, ITERATOR, $default);
		  }
		  // Plug for library
		  Iterators[NAME] = $default;
		  Iterators[TAG] = returnThis;
		  if (DEFAULT) {
		    methods = {
		      values: DEF_VALUES ? $default : getMethod(VALUES),
		      keys: IS_SET ? $default : getMethod(KEYS),
		      entries: $entries
		    };
		    if (FORCED) for (key in methods) {
		      if (!(key in proto)) redefine(proto, key, methods[key]);
		    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
		  }
		  return methods;
		};
	
	/***/ },
	/* 47 */
	/***/ function(module, exports) {
	
		"use strict";
		
		module.exports = false;
	
	/***/ },
	/* 48 */
	/***/ function(module, exports) {
	
		"use strict";
		
		module.exports = {};
	
	/***/ },
	/* 49 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var create = __webpack_require__(50),
		    descriptor = __webpack_require__(17),
		    setToStringTag = __webpack_require__(53),
		    IteratorPrototype = {};
		
		// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
		__webpack_require__(8)(IteratorPrototype, __webpack_require__(43)('iterator'), function () {
		  return this;
		});
		
		module.exports = function (Constructor, NAME, next) {
		  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
		  setToStringTag(Constructor, NAME + ' Iterator');
		};
	
	/***/ },
	/* 50 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
		var anObject = __webpack_require__(10),
		    dPs = __webpack_require__(51),
		    enumBugKeys = __webpack_require__(36),
		    IE_PROTO = __webpack_require__(34)('IE_PROTO'),
		    Empty = function Empty() {/* empty */},
		    PROTOTYPE = 'prototype';
		
		// Create object with fake `null` prototype: use iframe Object with cleared prototype
		var _createDict = function createDict() {
		  // Thrash, waste and sodomy: IE GC bug
		  var iframe = __webpack_require__(15)('iframe'),
		      i = enumBugKeys.length,
		      gt = '>',
		      iframeDocument;
		  iframe.style.display = 'none';
		  __webpack_require__(52).appendChild(iframe);
		  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
		  // createDict = iframe.contentWindow.Object;
		  // html.removeChild(iframe);
		  iframeDocument = iframe.contentWindow.document;
		  iframeDocument.open();
		  iframeDocument.write('<script>document.F=Object</script' + gt);
		  iframeDocument.close();
		  _createDict = iframeDocument.F;
		  while (i--) {
		    delete _createDict[PROTOTYPE][enumBugKeys[i]];
		  }return _createDict();
		};
		
		module.exports = Object.create || function create(O, Properties) {
		  var result;
		  if (O !== null) {
		    Empty[PROTOTYPE] = anObject(O);
		    result = new Empty();
		    Empty[PROTOTYPE] = null;
		    // add "__proto__" for Object.getPrototypeOf polyfill
		    result[IE_PROTO] = O;
		  } else result = _createDict();
		  return Properties === undefined ? result : dPs(result, Properties);
		};
	
	/***/ },
	/* 51 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var dP = __webpack_require__(9),
		    anObject = __webpack_require__(10),
		    getKeys = __webpack_require__(24);
		
		module.exports = __webpack_require__(13) ? Object.defineProperties : function defineProperties(O, Properties) {
		  anObject(O);
		  var keys = getKeys(Properties),
		      length = keys.length,
		      i = 0,
		      P;
		  while (length > i) {
		    dP.f(O, P = keys[i++], Properties[P]);
		  }return O;
		};
	
	/***/ },
	/* 52 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		module.exports = __webpack_require__(6).document && document.documentElement;
	
	/***/ },
	/* 53 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var def = __webpack_require__(9).f,
		    has = __webpack_require__(19),
		    TAG = __webpack_require__(43)('toStringTag');
		
		module.exports = function (it, tag, stat) {
		  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
		};
	
	/***/ },
	/* 54 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
		var has = __webpack_require__(19),
		    toObject = __webpack_require__(39),
		    IE_PROTO = __webpack_require__(34)('IE_PROTO'),
		    ObjectProto = Object.prototype;
		
		module.exports = Object.getPrototypeOf || function (O) {
		  O = toObject(O);
		  if (has(O, IE_PROTO)) return O[IE_PROTO];
		  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
		    return O.constructor.prototype;
		  }return O instanceof Object ? ObjectProto : null;
		};
	
	/***/ },
	/* 55 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var $iterators = __webpack_require__(56),
		    redefine = __webpack_require__(18),
		    global = __webpack_require__(6),
		    hide = __webpack_require__(8),
		    Iterators = __webpack_require__(48),
		    wks = __webpack_require__(43),
		    ITERATOR = wks('iterator'),
		    TO_STRING_TAG = wks('toStringTag'),
		    ArrayValues = Iterators.Array;
		
		for (var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++) {
		  var NAME = collections[i],
		      Collection = global[NAME],
		      proto = Collection && Collection.prototype,
		      key;
		  if (proto) {
		    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
		    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
		    Iterators[NAME] = ArrayValues;
		    for (key in $iterators) {
		      if (!proto[key]) redefine(proto, key, $iterators[key], true);
		    }
		  }
		}
	
	/***/ },
	/* 56 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var addToUnscopables = __webpack_require__(57),
		    step = __webpack_require__(58),
		    Iterators = __webpack_require__(48),
		    toIObject = __webpack_require__(26);
		
		// 22.1.3.4 Array.prototype.entries()
		// 22.1.3.13 Array.prototype.keys()
		// 22.1.3.29 Array.prototype.values()
		// 22.1.3.30 Array.prototype[@@iterator]()
		module.exports = __webpack_require__(46)(Array, 'Array', function (iterated, kind) {
		  this._t = toIObject(iterated); // target
		  this._i = 0; // next index
		  this._k = kind; // kind
		  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
		}, function () {
		  var O = this._t,
		      kind = this._k,
		      index = this._i++;
		  if (!O || index >= O.length) {
		    this._t = undefined;
		    return step(1);
		  }
		  if (kind == 'keys') return step(0, index);
		  if (kind == 'values') return step(0, O[index]);
		  return step(0, [index, O[index]]);
		}, 'values');
		
		// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
		Iterators.Arguments = Iterators.Array;
		
		addToUnscopables('keys');
		addToUnscopables('values');
		addToUnscopables('entries');
	
	/***/ },
	/* 57 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// 22.1.3.31 Array.prototype[@@unscopables]
		var UNSCOPABLES = __webpack_require__(43)('unscopables'),
		    ArrayProto = Array.prototype;
		if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(8)(ArrayProto, UNSCOPABLES, {});
		module.exports = function (key) {
		  ArrayProto[UNSCOPABLES][key] = true;
		};
	
	/***/ },
	/* 58 */
	/***/ function(module, exports) {
	
		"use strict";
		
		module.exports = function (done, value) {
		  return { value: value, done: !!done };
		};
	
	/***/ },
	/* 59 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var LIBRARY = __webpack_require__(47),
		    global = __webpack_require__(6),
		    ctx = __webpack_require__(21),
		    classof = __webpack_require__(42),
		    $export = __webpack_require__(5),
		    isObject = __webpack_require__(11),
		    anObject = __webpack_require__(10),
		    aFunction = __webpack_require__(22),
		    anInstance = __webpack_require__(60),
		    forOf = __webpack_require__(61),
		    setProto = __webpack_require__(65).set,
		    speciesConstructor = __webpack_require__(67),
		    task = __webpack_require__(68).set,
		    microtask = __webpack_require__(70),
		    PROMISE = 'Promise',
		    TypeError = global.TypeError,
		    process = global.process,
		    $Promise = global[PROMISE],
		    process = global.process,
		    isNode = classof(process) == 'process',
		    empty = function empty() {/* empty */},
		    Internal,
		    GenericPromiseCapability,
		    Wrapper;
		
		var USE_NATIVE = !!function () {
		  try {
		    // correct subclassing with @@species support
		    var promise = $Promise.resolve(1),
		        FakePromise = (promise.constructor = {})[__webpack_require__(43)('species')] = function (exec) {
		      exec(empty, empty);
		    };
		    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
		    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
		  } catch (e) {/* empty */}
		}();
		
		// helpers
		var sameConstructor = function sameConstructor(a, b) {
		  // with library wrapper special case
		  return a === b || a === $Promise && b === Wrapper;
		};
		var isThenable = function isThenable(it) {
		  var then;
		  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
		};
		var newPromiseCapability = function newPromiseCapability(C) {
		  return sameConstructor($Promise, C) ? new PromiseCapability(C) : new GenericPromiseCapability(C);
		};
		var PromiseCapability = GenericPromiseCapability = function GenericPromiseCapability(C) {
		  var resolve, reject;
		  this.promise = new C(function ($$resolve, $$reject) {
		    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
		    resolve = $$resolve;
		    reject = $$reject;
		  });
		  this.resolve = aFunction(resolve);
		  this.reject = aFunction(reject);
		};
		var perform = function perform(exec) {
		  try {
		    exec();
		  } catch (e) {
		    return { error: e };
		  }
		};
		var notify = function notify(promise, isReject) {
		  if (promise._n) return;
		  promise._n = true;
		  var chain = promise._c;
		  microtask(function () {
		    var value = promise._v,
		        ok = promise._s == 1,
		        i = 0;
		    var run = function run(reaction) {
		      var handler = ok ? reaction.ok : reaction.fail,
		          resolve = reaction.resolve,
		          reject = reaction.reject,
		          domain = reaction.domain,
		          result,
		          then;
		      try {
		        if (handler) {
		          if (!ok) {
		            if (promise._h == 2) onHandleUnhandled(promise);
		            promise._h = 1;
		          }
		          if (handler === true) result = value;else {
		            if (domain) domain.enter();
		            result = handler(value);
		            if (domain) domain.exit();
		          }
		          if (result === reaction.promise) {
		            reject(TypeError('Promise-chain cycle'));
		          } else if (then = isThenable(result)) {
		            then.call(result, resolve, reject);
		          } else resolve(result);
		        } else reject(value);
		      } catch (e) {
		        reject(e);
		      }
		    };
		    while (chain.length > i) {
		      run(chain[i++]);
		    } // variable length - can't use forEach
		    promise._c = [];
		    promise._n = false;
		    if (isReject && !promise._h) onUnhandled(promise);
		  });
		};
		var onUnhandled = function onUnhandled(promise) {
		  task.call(global, function () {
		    var value = promise._v,
		        abrupt,
		        handler,
		        console;
		    if (isUnhandled(promise)) {
		      abrupt = perform(function () {
		        if (isNode) {
		          process.emit('unhandledRejection', value, promise);
		        } else if (handler = global.onunhandledrejection) {
		          handler({ promise: promise, reason: value });
		        } else if ((console = global.console) && console.error) {
		          console.error('Unhandled promise rejection', value);
		        }
		      });
		      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
		      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
		    }promise._a = undefined;
		    if (abrupt) throw abrupt.error;
		  });
		};
		var isUnhandled = function isUnhandled(promise) {
		  if (promise._h == 1) return false;
		  var chain = promise._a || promise._c,
		      i = 0,
		      reaction;
		  while (chain.length > i) {
		    reaction = chain[i++];
		    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
		  }return true;
		};
		var onHandleUnhandled = function onHandleUnhandled(promise) {
		  task.call(global, function () {
		    var handler;
		    if (isNode) {
		      process.emit('rejectionHandled', promise);
		    } else if (handler = global.onrejectionhandled) {
		      handler({ promise: promise, reason: promise._v });
		    }
		  });
		};
		var $reject = function $reject(value) {
		  var promise = this;
		  if (promise._d) return;
		  promise._d = true;
		  promise = promise._w || promise; // unwrap
		  promise._v = value;
		  promise._s = 2;
		  if (!promise._a) promise._a = promise._c.slice();
		  notify(promise, true);
		};
		var $resolve = function $resolve(value) {
		  var promise = this,
		      then;
		  if (promise._d) return;
		  promise._d = true;
		  promise = promise._w || promise; // unwrap
		  try {
		    if (promise === value) throw TypeError("Promise can't be resolved itself");
		    if (then = isThenable(value)) {
		      microtask(function () {
		        var wrapper = { _w: promise, _d: false }; // wrap
		        try {
		          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
		        } catch (e) {
		          $reject.call(wrapper, e);
		        }
		      });
		    } else {
		      promise._v = value;
		      promise._s = 1;
		      notify(promise, false);
		    }
		  } catch (e) {
		    $reject.call({ _w: promise, _d: false }, e); // wrap
		  }
		};
		
		// constructor polyfill
		if (!USE_NATIVE) {
		  // 25.4.3.1 Promise(executor)
		  $Promise = function Promise(executor) {
		    anInstance(this, $Promise, PROMISE, '_h');
		    aFunction(executor);
		    Internal.call(this);
		    try {
		      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
		    } catch (err) {
		      $reject.call(this, err);
		    }
		  };
		  Internal = function Promise(executor) {
		    this._c = []; // <- awaiting reactions
		    this._a = undefined; // <- checked in isUnhandled reactions
		    this._s = 0; // <- state
		    this._d = false; // <- done
		    this._v = undefined; // <- value
		    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
		    this._n = false; // <- notify
		  };
		  Internal.prototype = __webpack_require__(71)($Promise.prototype, {
		    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
		    then: function then(onFulfilled, onRejected) {
		      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
		      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
		      reaction.fail = typeof onRejected == 'function' && onRejected;
		      reaction.domain = isNode ? process.domain : undefined;
		      this._c.push(reaction);
		      if (this._a) this._a.push(reaction);
		      if (this._s) notify(this, false);
		      return reaction.promise;
		    },
		    // 25.4.5.1 Promise.prototype.catch(onRejected)
		    'catch': function _catch(onRejected) {
		      return this.then(undefined, onRejected);
		    }
		  });
		  PromiseCapability = function PromiseCapability() {
		    var promise = new Internal();
		    this.promise = promise;
		    this.resolve = ctx($resolve, promise, 1);
		    this.reject = ctx($reject, promise, 1);
		  };
		}
		
		$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
		__webpack_require__(53)($Promise, PROMISE);
		__webpack_require__(72)(PROMISE);
		Wrapper = __webpack_require__(7)[PROMISE];
		
		// statics
		$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
		  // 25.4.4.5 Promise.reject(r)
		  reject: function reject(r) {
		    var capability = newPromiseCapability(this),
		        $$reject = capability.reject;
		    $$reject(r);
		    return capability.promise;
		  }
		});
		$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
		  // 25.4.4.6 Promise.resolve(x)
		  resolve: function resolve(x) {
		    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
		    if (x instanceof $Promise && sameConstructor(x.constructor, this)) return x;
		    var capability = newPromiseCapability(this),
		        $$resolve = capability.resolve;
		    $$resolve(x);
		    return capability.promise;
		  }
		});
		$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(73)(function (iter) {
		  $Promise.all(iter)['catch'](empty);
		})), PROMISE, {
		  // 25.4.4.1 Promise.all(iterable)
		  all: function all(iterable) {
		    var C = this,
		        capability = newPromiseCapability(C),
		        resolve = capability.resolve,
		        reject = capability.reject;
		    var abrupt = perform(function () {
		      var values = [],
		          index = 0,
		          remaining = 1;
		      forOf(iterable, false, function (promise) {
		        var $index = index++,
		            alreadyCalled = false;
		        values.push(undefined);
		        remaining++;
		        C.resolve(promise).then(function (value) {
		          if (alreadyCalled) return;
		          alreadyCalled = true;
		          values[$index] = value;
		          --remaining || resolve(values);
		        }, reject);
		      });
		      --remaining || resolve(values);
		    });
		    if (abrupt) reject(abrupt.error);
		    return capability.promise;
		  },
		  // 25.4.4.4 Promise.race(iterable)
		  race: function race(iterable) {
		    var C = this,
		        capability = newPromiseCapability(C),
		        reject = capability.reject;
		    var abrupt = perform(function () {
		      forOf(iterable, false, function (promise) {
		        C.resolve(promise).then(capability.resolve, reject);
		      });
		    });
		    if (abrupt) reject(abrupt.error);
		    return capability.promise;
		  }
		});
	
	/***/ },
	/* 60 */
	/***/ function(module, exports) {
	
		'use strict';
		
		module.exports = function (it, Constructor, name, forbiddenField) {
		  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
		    throw TypeError(name + ': incorrect invocation!');
		  }return it;
		};
	
	/***/ },
	/* 61 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var ctx = __webpack_require__(21),
		    call = __webpack_require__(62),
		    isArrayIter = __webpack_require__(63),
		    anObject = __webpack_require__(10),
		    toLength = __webpack_require__(31),
		    getIterFn = __webpack_require__(64);
		module.exports = function (iterable, entries, fn, that, ITERATOR) {
		  var iterFn = ITERATOR ? function () {
		    return iterable;
		  } : getIterFn(iterable),
		      f = ctx(fn, that, entries ? 2 : 1),
		      index = 0,
		      length,
		      step,
		      iterator;
		  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
		  // fast case for arrays with default iterator
		  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
		    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
		  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
		    call(iterator, f, step.value, entries);
		  }
		};
	
	/***/ },
	/* 62 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// call something on iterator step with safe closing on error
		var anObject = __webpack_require__(10);
		module.exports = function (iterator, fn, value, entries) {
		  try {
		    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
		    // 7.4.6 IteratorClose(iterator, completion)
		  } catch (e) {
		    var ret = iterator['return'];
		    if (ret !== undefined) anObject(ret.call(iterator));
		    throw e;
		  }
		};
	
	/***/ },
	/* 63 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// check on default Array iterator
		var Iterators = __webpack_require__(48),
		    ITERATOR = __webpack_require__(43)('iterator'),
		    ArrayProto = Array.prototype;
		
		module.exports = function (it) {
		  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
		};
	
	/***/ },
	/* 64 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var classof = __webpack_require__(42),
		    ITERATOR = __webpack_require__(43)('iterator'),
		    Iterators = __webpack_require__(48);
		module.exports = __webpack_require__(7).getIteratorMethod = function (it) {
		  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
		};
	
	/***/ },
	/* 65 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// Works with __proto__ only. Old v8 can't work with null proto objects.
		/* eslint-disable no-proto */
		var isObject = __webpack_require__(11),
		    anObject = __webpack_require__(10);
		var check = function check(O, proto) {
		  anObject(O);
		  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
		};
		module.exports = {
		  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
		  function (test, buggy, set) {
		    try {
		      set = __webpack_require__(21)(Function.call, __webpack_require__(66).f(Object.prototype, '__proto__').set, 2);
		      set(test, []);
		      buggy = !(test instanceof Array);
		    } catch (e) {
		      buggy = true;
		    }
		    return function setPrototypeOf(O, proto) {
		      check(O, proto);
		      if (buggy) O.__proto__ = proto;else set(O, proto);
		      return O;
		    };
		  }({}, false) : undefined),
		  check: check
		};
	
	/***/ },
	/* 66 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var pIE = __webpack_require__(38),
		    createDesc = __webpack_require__(17),
		    toIObject = __webpack_require__(26),
		    toPrimitive = __webpack_require__(16),
		    has = __webpack_require__(19),
		    IE8_DOM_DEFINE = __webpack_require__(12),
		    gOPD = Object.getOwnPropertyDescriptor;
		
		exports.f = __webpack_require__(13) ? gOPD : function getOwnPropertyDescriptor(O, P) {
		  O = toIObject(O);
		  P = toPrimitive(P, true);
		  if (IE8_DOM_DEFINE) try {
		    return gOPD(O, P);
		  } catch (e) {/* empty */}
		  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
		};
	
	/***/ },
	/* 67 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// 7.3.20 SpeciesConstructor(O, defaultConstructor)
		var anObject = __webpack_require__(10),
		    aFunction = __webpack_require__(22),
		    SPECIES = __webpack_require__(43)('species');
		module.exports = function (O, D) {
		  var C = anObject(O).constructor,
		      S;
		  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
		};
	
	/***/ },
	/* 68 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var ctx = __webpack_require__(21),
		    invoke = __webpack_require__(69),
		    html = __webpack_require__(52),
		    cel = __webpack_require__(15),
		    global = __webpack_require__(6),
		    process = global.process,
		    setTask = global.setImmediate,
		    clearTask = global.clearImmediate,
		    MessageChannel = global.MessageChannel,
		    counter = 0,
		    queue = {},
		    ONREADYSTATECHANGE = 'onreadystatechange',
		    defer,
		    channel,
		    port;
		var run = function run() {
		  var id = +this;
		  if (queue.hasOwnProperty(id)) {
		    var fn = queue[id];
		    delete queue[id];
		    fn();
		  }
		};
		var listener = function listener(event) {
		  run.call(event.data);
		};
		// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
		if (!setTask || !clearTask) {
		  setTask = function setImmediate(fn) {
		    var args = [],
		        i = 1;
		    while (arguments.length > i) {
		      args.push(arguments[i++]);
		    }queue[++counter] = function () {
		      invoke(typeof fn == 'function' ? fn : Function(fn), args);
		    };
		    defer(counter);
		    return counter;
		  };
		  clearTask = function clearImmediate(id) {
		    delete queue[id];
		  };
		  // Node.js 0.8-
		  if (__webpack_require__(28)(process) == 'process') {
		    defer = function defer(id) {
		      process.nextTick(ctx(run, id, 1));
		    };
		    // Browsers with MessageChannel, includes WebWorkers
		  } else if (MessageChannel) {
		      channel = new MessageChannel();
		      port = channel.port2;
		      channel.port1.onmessage = listener;
		      defer = ctx(port.postMessage, port, 1);
		      // Browsers with postMessage, skip WebWorkers
		      // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
		    } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
		        defer = function defer(id) {
		          global.postMessage(id + '', '*');
		        };
		        global.addEventListener('message', listener, false);
		        // IE8-
		      } else if (ONREADYSTATECHANGE in cel('script')) {
		          defer = function defer(id) {
		            html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
		              html.removeChild(this);
		              run.call(id);
		            };
		          };
		          // Rest old browsers
		        } else {
		            defer = function defer(id) {
		              setTimeout(ctx(run, id, 1), 0);
		            };
		          }
		}
		module.exports = {
		  set: setTask,
		  clear: clearTask
		};
	
	/***/ },
	/* 69 */
	/***/ function(module, exports) {
	
		"use strict";
		
		// fast apply, http://jsperf.lnkit.com/fast-apply/5
		module.exports = function (fn, args, that) {
		                  var un = that === undefined;
		                  switch (args.length) {
		                                    case 0:
		                                                      return un ? fn() : fn.call(that);
		                                    case 1:
		                                                      return un ? fn(args[0]) : fn.call(that, args[0]);
		                                    case 2:
		                                                      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
		                                    case 3:
		                                                      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
		                                    case 4:
		                                                      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
		                  }return fn.apply(that, args);
		};
	
	/***/ },
	/* 70 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var global = __webpack_require__(6),
		    macrotask = __webpack_require__(68).set,
		    Observer = global.MutationObserver || global.WebKitMutationObserver,
		    process = global.process,
		    Promise = global.Promise,
		    isNode = __webpack_require__(28)(process) == 'process',
		    head,
		    last,
		    notify;
		
		var flush = function flush() {
		  var parent, fn;
		  if (isNode && (parent = process.domain)) parent.exit();
		  while (head) {
		    fn = head.fn;
		    fn(); // <- currently we use it only for Promise - try / catch not required
		    head = head.next;
		  }last = undefined;
		  if (parent) parent.enter();
		};
		
		// Node.js
		if (isNode) {
		  notify = function notify() {
		    process.nextTick(flush);
		  };
		  // browsers with MutationObserver
		} else if (Observer) {
		    var toggle = true,
		        node = document.createTextNode('');
		    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
		    notify = function notify() {
		      node.data = toggle = !toggle;
		    };
		    // environments with maybe non-completely correct, but existent Promise
		  } else if (Promise && Promise.resolve) {
		      notify = function notify() {
		        Promise.resolve().then(flush);
		      };
		      // for other environments - macrotask based on:
		      // - setImmediate
		      // - MessageChannel
		      // - window.postMessag
		      // - onreadystatechange
		      // - setTimeout
		    } else {
		        notify = function notify() {
		          // strange IE + webpack dev server bug - use .call(global)
		          macrotask.call(global, flush);
		        };
		      }
		
		module.exports = function (fn) {
		  var task = { fn: fn, next: undefined };
		  if (last) last.next = task;
		  if (!head) {
		    head = task;
		    notify();
		  }last = task;
		};
	
	/***/ },
	/* 71 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var redefine = __webpack_require__(18);
		module.exports = function (target, src, safe) {
		  for (var key in src) {
		    redefine(target, key, src[key], safe);
		  }return target;
		};
	
	/***/ },
	/* 72 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var global = __webpack_require__(6),
		    dP = __webpack_require__(9),
		    DESCRIPTORS = __webpack_require__(13),
		    SPECIES = __webpack_require__(43)('species');
		
		module.exports = function (KEY) {
		  var C = global[KEY];
		  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
		    configurable: true,
		    get: function get() {
		      return this;
		    }
		  });
		};
	
	/***/ },
	/* 73 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var ITERATOR = __webpack_require__(43)('iterator'),
		    SAFE_CLOSING = false;
		
		try {
		  var riter = [7][ITERATOR]();
		  riter['return'] = function () {
		    SAFE_CLOSING = true;
		  };
		  Array.from(riter, function () {
		    throw 2;
		  });
		} catch (e) {/* empty */}
		
		module.exports = function (exec, skipClosing) {
		  if (!skipClosing && !SAFE_CLOSING) return false;
		  var safe = false;
		  try {
		    var arr = [7],
		        iter = arr[ITERATOR]();
		    iter.next = function () {
		      safe = true;
		    };
		    arr[ITERATOR] = function () {
		      return iter;
		    };
		    exec(arr);
		  } catch (e) {/* empty */}
		  return safe;
		};
	
	/***/ },
	/* 74 */
	/***/ function(module, exports) {
	
		/* WEBPACK VAR INJECTION */(function(global) {'use strict';
		
		var _global = global;
		var setTimeout = _global.setTimeout;
		var setTimeoutNative = _global.setTimeoutNative;
		
		// fix no setTimeout on Android V8
		
		if (typeof setTimeout === 'undefined' && typeof setTimeoutNative === 'function') {
		  (function () {
		    var timeoutMap = {};
		    var timeoutId = 0;
		    global.setTimeout = function (cb, time) {
		      timeoutMap[++timeoutId] = cb;
		      setTimeoutNative(timeoutId.toString(), time);
		    };
		    global.setTimeoutCallback = function (id) {
		      if (typeof timeoutMap[id] === 'function') {
		        timeoutMap[id]();
		        delete timeoutMap[id];
		      }
		    };
		  })();
		}
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 75 */
	/***/ function(module, exports) {
	
		/* WEBPACK VAR INJECTION */(function(global) {'use strict';
		
		var _global = global;
		var console = _global.console;
		
		
		if (typeof console === 'undefined') {
		  global.console = {
		    log: function log() {
		      if (typeof nativeLog === 'function') {
		        nativeLog.apply(undefined, arguments);
		      }
		    },
		    error: function error() {
		      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		        args[_key] = arguments[_key];
		      }
		
		      throw new Error(args);
		    }
		  };
		}
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 76 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; }; /**
		                                                                                                                                                                                                                                                   * @fileOverview Main entry, instance manager
		                                                                                                                                                                                                                                                   *
		                                                                                                                                                                                                                                                   * - createInstance(instanceId, code, options, data)
		                                                                                                                                                                                                                                                   * - refreshInstance(instanceId, data)
		                                                                                                                                                                                                                                                   * - destroyInstance(instanceId)
		                                                                                                                                                                                                                                                   * - registerComponents(components)
		                                                                                                                                                                                                                                                   * - registerModules(modules)
		                                                                                                                                                                                                                                                   * - getRoot(instanceId)
		                                                                                                                                                                                                                                                   * - instanceMap
		                                                                                                                                                                                                                                                   * - callJS(instanceId, tasks)
		                                                                                                                                                                                                                                                   *   - fireEvent(ref, type, data)
		                                                                                                                                                                                                                                                   *   - callback(funcId, data)
		                                                                                                                                                                                                                                                   */
		
		exports.createInstance = createInstance;
		exports.refreshInstance = refreshInstance;
		exports.destroyInstance = destroyInstance;
		exports.registerComponents = registerComponents;
		exports.registerModules = registerModules;
		exports.registerMethods = registerMethods;
		exports.getRoot = getRoot;
		exports.callJS = callJS;
		
		var _perf = __webpack_require__(77);
		
		var perf = _interopRequireWildcard(_perf);
		
		var _config = __webpack_require__(79);
		
		var config = _interopRequireWildcard(_config);
		
		var _app = __webpack_require__(80);
		
		var _app2 = _interopRequireDefault(_app);
		
		var _vm = __webpack_require__(85);
		
		var _vm2 = _interopRequireDefault(_vm);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
		
		function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
		
		var nativeComponentMap = config.nativeComponentMap;
		
		var instanceMap = {};
		
		/**
		 * create a Weex instance
		 *
		 * @param  {string} instanceId
		 * @param  {string} code
		 * @param  {object} [options] option `HAS_LOG` enable print log
		 * @param  {object} [data]
		 */
		function createInstance(instanceId, code, options, data) {
		  var instance = instanceMap[instanceId];
		  options = options || {};
		
		  config.debug = options.debug;
		
		  var result;
		  if (!instance) {
		    perf.start('createInstance', instanceId);
		    instance = new _app2.default(instanceId, options);
		    instanceMap[instanceId] = instance;
		    result = instance.init(code, data);
		    perf.end('createInstance', instanceId);
		  } else {
		    result = new Error('invalid instance id "' + instanceId + '"');
		  }
		
		  return result;
		}
		
		/**
		 * refresh a Weex instance
		 *
		 * @param  {string} instanceId
		 * @param  {object} data
		 */
		function refreshInstance(instanceId, data) {
		  var instance = instanceMap[instanceId];
		  var result;
		  if (instance) {
		    perf.start('refreshData', instanceId);
		    result = instance.refreshData(data);
		    perf.end('refreshData', instanceId);
		  } else {
		    result = new Error('invalid instance id "' + instanceId + '"');
		  }
		  return result;
		}
		
		/**
		 * destroy a Weex instance
		 * @param  {string} instanceId
		 */
		function destroyInstance(instanceId) {
		  var instance = instanceMap[instanceId];
		  if (!instance) {
		    return new Error('invalid instance id "' + instanceId + '"');
		  }
		
		  perf.start('destroyInstance', instanceId);
		  instance.destroy();
		  delete instanceMap[instanceId];
		  perf.end('destroyInstance', instanceId);
		
		  return instanceMap;
		}
		
		/**
		 * register the name of each native component
		 * @param  {array} components array of name
		 */
		function registerComponents(components) {
		  if (Array.isArray(components)) {
		    components.forEach(function register(name) {
		      /* istanbul ignore if */
		      if (!name) {
		        return;
		      }
		      if (typeof name === 'string') {
		        nativeComponentMap[name] = true;
		      } else if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object' && typeof name.type === 'string') {
		        nativeComponentMap[name.type] = name;
		      }
		    });
		  }
		}
		
		/**
		 * register the name and methods of each module
		 * @param  {object} modules a object of modules
		 */
		function registerModules(modules) {
		  if ((typeof modules === 'undefined' ? 'undefined' : _typeof(modules)) === 'object') {
		    _vm2.default.registerModules(modules);
		  }
		}
		
		/**
		 * register the name and methods of each api
		 * @param  {object} apis a object of apis
		 */
		function registerMethods(apis) {
		  if ((typeof apis === 'undefined' ? 'undefined' : _typeof(apis)) === 'object') {
		    _vm2.default.registerMethods(apis);
		  }
		}
		
		/**
		 * get a whole element tree of an instance
		 * for debugging
		 * @param  {string} instanceId
		 * @return {object} a virtual dom tree
		 */
		function getRoot(instanceId) {
		  var instance = instanceMap[instanceId];
		  var result;
		  if (instance) {
		    result = instance.getRootElement();
		  } else {
		    result = new Error('invalid instance id "' + instanceId + '"');
		  }
		  return result;
		}
		
		var jsHandlers = {
		  fireEvent: function fireEvent(instanceId, ref, type, data) {
		    var instance = instanceMap[instanceId];
		    var result;
		    perf.start('fireEvent', instanceId + '-' + ref + '-' + type);
		    result = instance.fireEvent(ref, type, data);
		    perf.end('fireEvent', instanceId + '-' + ref + '-' + type);
		    return result;
		  },
		
		  callback: function callback(instanceId, funcId, data, ifLast) {
		    var instance = instanceMap[instanceId];
		    var result;
		    perf.start('callback', instanceId + '-' + funcId + '-' + data + '-' + ifLast);
		    result = instance.callback(funcId, data, ifLast);
		    perf.end('callback', instanceId + '-' + funcId + '-' + data + '-' + ifLast);
		    return result;
		  }
		};
		
		/**
		 * accept calls from native (event or callback)
		 *
		 * @param  {string} instanceId
		 * @param  {array} tasks list with `method` and `args`
		 */
		function callJS(instanceId, tasks) {
		  var instance = instanceMap[instanceId];
		  var results = [];
		  if (instance && Array.isArray(tasks)) {
		    tasks.forEach(function (task) {
		      var handler = jsHandlers[task.method];
		      var args = [].concat(_toConsumableArray(task.args));
		      if (typeof handler === 'function') {
		        log('javascript:', task.method, task.args);
		        args.unshift(instanceId);
		        results.push(handler.apply(undefined, _toConsumableArray(args)));
		      }
		    });
		  } else {
		    results.push(new Error('invalid instance id "' + instanceId + '" or tasks'));
		  }
		
		  return results;
		}
	
	/***/ },
	/* 77 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.start = start;
		exports.end = end;
		exports.reset = reset;
		exports.toJSON = toJSON;
		
		var _log = __webpack_require__(78);
		
		var _log2 = _interopRequireDefault(_log);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		var data = { type: 'root', children: [] };
		var current = data;
		var stack = [current];
		
		function spaces(num) {
		  return Array(num).join(' ');
		}
		
		function start(type, id) {
		  var task = { type: type, id: id, children: [], start: Date.now() };
		  current.children.push(task);
		  stack.push(task);
		  current = task;
		  (0, _log2.default)('perf:' + spaces(stack.length - 1), 'start', task.type, task.id);
		}
		
		function end(type, id) {
		  var task = stack.pop();
		  task.end = Date.now();
		  current = stack[stack.length - 1];
		  (0, _log2.default)('perf:' + spaces(stack.length), 'end', task.end - task.start + 'ms', task.type, task.id);
		}
		
		function reset() {
		  data.children = [];
		  current = data;
		  stack.length = 0;
		  stack.push(current);
		}
		
		function toJSON() {
		  return JSON.parse(JSON.stringify(data));
		}
	
	/***/ },
	/* 78 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(global) {'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = log;
		
		var _config = __webpack_require__(79);
		
		var config = _interopRequireWildcard(_config);
		
		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
		
		function log() {
		  if (config.debug) {
		    var _global$console;
		
		    (_global$console = global.console).log.apply(_global$console, arguments);
		  }
		}
		
		global.log = log;
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 79 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		var nativeComponentMap = exports.nativeComponentMap = {
		  text: true,
		  image: true,
		  container: true,
		  slider: {
		    type: 'slider',
		    append: 'tree'
		  },
		  cell: {
		    type: 'cell',
		    append: 'tree'
		  }
		};
		
		var customComponentMap = exports.customComponentMap = {};
		
		var debug = exports.debug = false;
	
	/***/ },
	/* 80 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = AppInstance;
		
		var _util = __webpack_require__(81);
		
		var _perf = __webpack_require__(77);
		
		var perf = _interopRequireWildcard(_perf);
		
		var _bundle = __webpack_require__(82);
		
		var bundle = _interopRequireWildcard(_bundle);
		
		var _ctrl = __webpack_require__(100);
		
		var ctrl = _interopRequireWildcard(_ctrl);
		
		var _differ = __webpack_require__(102);
		
		var _differ2 = _interopRequireDefault(_differ);
		
		var _event = __webpack_require__(103);
		
		var _event2 = _interopRequireDefault(_event);
		
		var _domListener = __webpack_require__(101);
		
		var _domListener2 = _interopRequireDefault(_domListener);
		
		var _dom = __webpack_require__(104);
		
		var _register = __webpack_require__(98);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
		
		function AppInstance(instanceId, options) {
		  var _this = this;
		
		  perf.start('initInstance', instanceId);
		  this.id = instanceId;
		  this.options = options || {};
		  this.vm = null;
		  this.doc = new _dom.Document(instanceId);
		  this.customComponentMap = {};
		  this.callbacks = {};
		  this.differ = new _differ2.default(instanceId);
		  this.uid = 0;
		  this.rendered = false;
		  this.eventManager = new _event2.default();
		  this.listener = new _domListener2.default(this.id, function (tasks) {
		    _this.callTasks(tasks);
		  });
		  this.doc.setEventManager(this.eventManager);
		  this.doc.setListener(this.listener);
		
		  perf.end('initInstance', instanceId);
		} /**
		   * @fileOverview
		   * Weex instance constructor & definition
		   */
		
		function normalize(app, v) {
		  var type = (0, _util.typof)(v);
		
		  switch (type) {
		    case 'undefined':
		    case 'null':
		      return '';
		    case 'regexp':
		      return v.toString();
		    case 'date':
		      return v.toISOString();
		    case 'number':
		    case 'string':
		    case 'boolean':
		    case 'array':
		    case 'object':
		      if (v instanceof _dom.Node) {
		        return v.ref;
		      }
		      return v;
		    case 'function':
		      app.callbacks[++app.uid] = v;
		      return app.uid.toString();
		    default:
		      return JSON.stringify(v);
		  }
		}
		
		AppInstance.prototype.callTasks = function (tasks) {
		  var _this2 = this;
		
		  if ((0, _util.typof)(tasks) !== 'array') {
		    tasks = [tasks];
		  }
		
		  tasks.forEach(function (task) {
		    task.args = task.args.map(function (arg) {
		      return normalize(_this2, arg);
		    });
		  });
		
		  callNative(this.id, tasks, '-1');
		};
		
		(0, _util.extend)(AppInstance.prototype, bundle, ctrl, {
		  registerComponent: _register.registerComponent,
		  requireComponent: _register.requireComponent,
		  requireModule: _register.requireModule
		});
	
	/***/ },
	/* 81 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.warn = exports.log = exports.indexOf = exports.define = exports.normalize = exports.typof = exports.stringify = exports.isArray = exports.isPlainObject = exports.isObject = exports.extend = exports.toArray = exports.bind = exports.camelize = exports.isReserved = undefined;
		
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; }; /// lang.js
		
		
		var _config2 = __webpack_require__(79);
		
		var _config3 = _interopRequireDefault(_config2);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		/**
		 * Check is a string starts with $ or _
		 *
		 * @param {String} str
		 * @return {Boolean}
		 */
		
		var isReserved = exports.isReserved = function isReserved(str) {
		  str += '';
		  var c = (str + '').charCodeAt(0);
		  return c === 0x24 || c === 0x5F;
		};
		
		/**
		 * Camelize a hyphen-delmited string.
		 *
		 * @param {String} str
		 * @return {String}
		 */
		
		var camelRE = /-(\w)/g;
		function toUpper(_, c) {
		  return c ? c.toUpperCase() : '';
		}
		var camelize = exports.camelize = function camelize(str) {
		  return str.replace(camelRE, toUpper);
		};
		
		/**
		 * Simple bind, faster than native
		 *
		 * @param {Function} fn
		 * @param {Object} ctx
		 * @return {Function}
		 */
		
		var bind = exports.bind = function bind(fn, ctx) {
		  return function (a) {
		    var l = arguments.length;
		    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
		  };
		};
		
		/**
		 * Convert an Array-like object to a real Array.
		 *
		 * @param {Array-like} list
		 * @param {Number} [start] - start index
		 * @return {Array}
		 */
		
		var toArray = exports.toArray = function toArray(list, start) {
		  start = start || 0;
		  var i = list.length - start;
		  var ret = new Array(i);
		  while (i--) {
		    ret[i] = list[i + start];
		  }
		  return ret;
		};
		
		/**
		 * Mix properties into target object.
		 *
		 * @param {Object} to
		 * @param {Object} from
		 */
		
		var extend = exports.extend = function extend(target) {
		  for (var _len = arguments.length, src = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		    src[_key - 1] = arguments[_key];
		  }
		
		  if (typeof Object.assign === 'function') {
		    Object.assign.apply(Object, [target].concat(src));
		  } else {
		    var first = src.shift();
		    for (var key in first) {
		      target[key] = first[key];
		    }
		    if (src.length) {
		      extend.apply(undefined, [target].concat(src));
		    }
		  }
		  return target;
		};
		
		/**
		 * Quick object check - this is primarily used to tell
		 * Objects from primitive values when we know the value
		 * is a JSON-compliant type.
		 *
		 * @param {*} obj
		 * @return {Boolean}
		 */
		
		var isObject = exports.isObject = function isObject(obj) {
		  return !!(obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object');
		};
		
		/**
		 * Strict object type check. Only returns true
		 * for plain JavaScript objects.
		 *
		 * @param {*} obj
		 * @return {Boolean}
		 */
		
		var toString = Object.prototype.toString;
		var isPlainObject = exports.isPlainObject = function isPlainObject(obj) {
		  return toString.call(obj) === '[object Object]';
		};
		
		/**
		 * Array type check.
		 *
		 * @param {*} obj
		 * @return {Boolean}
		 */
		
		var isArray = exports.isArray = function isArray(obj) {
		  return Array.isArray(obj);
		};
		
		var stringify = exports.stringify = function stringify(x) {
		  return typeof x === 'undefined' || x === null || typeof x === 'function' ? '' : (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' ? x instanceof RegExp ? x.toString() : x instanceof Date ? JSON.parse(JSON.stringify(x)) : JSON.stringify(x) : x.toString();
		};
		
		var typof = exports.typof = function typof(v) {
		  var s = Object.prototype.toString.call(v);
		  return s.substring(8, s.length - 1).toLowerCase();
		};
		
		var normalize = exports.normalize = function normalize(v) {
		  var type = typof(v);
		
		  switch (type) {
		    case 'undefined':
		    case 'null':
		      return '';
		    case 'regexp':
		      return v.toString();
		    case 'date':
		      return v.toISOString();
		    case 'number':
		    case 'string':
		    case 'boolean':
		    case 'array':
		    case 'object':
		    case 'function':
		      return v;
		    default:
		      return JSON.stringify(v);
		  }
		};
		
		/**
		 * Define a non-enumerable property
		 *
		 * @param {Object} obj
		 * @param {String} key
		 * @param {*} val
		 * @param {Boolean} [enumerable]
		 */
		
		var define = exports.define = function define(obj, key, val, enumerable) {
		  Object.defineProperty(obj, key, {
		    value: val,
		    enumerable: !!enumerable,
		    writable: true,
		    configurable: true
		  });
		};
		
		/**
		 * Manual indexOf because it's slightly faster than
		 * native.
		 *
		 * @param {Array} arr
		 * @param {*} obj
		 */
		
		var indexOf = exports.indexOf = function indexOf(arr, obj) {
		  for (var i = 0, l = arr.length; i < l; i++) {
		    if (arr[i] === obj) return i;
		  }
		  return -1;
		};
		
		/// debug.js
		
		var hasConsole = typeof console !== 'undefined';
		
		/**
		 * Log a message.
		 *
		 * @param {String} msg
		 */
		
		var log = exports.log = function log(msg) {
		  var _config = _config3.default || {};
		  if (hasConsole && _config.debug) {
		    console.log.call(undefined, '[info]: ', msg);
		  }
		};
		
		/**
		 * We've got a problem here.
		 *
		 * @param {String} msg
		 */
		
		var warn = exports.warn = function warn(msg) {
		  // if (hasConsole && (!config.silent || config.debug)) {
		  if (hasConsole) {
		    console.warn.call(undefined, '[warn]: ', msg);
		    /* istanbul ignore if */
		    // if (config.debug) {
		    //   /* jshint debug: true */
		    //   debugger
		    // }
		  }
		};
	
	/***/ },
	/* 82 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(global) {'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.require = exports.define = undefined;
		exports.clearCommonModules = clearCommonModules;
		exports.bootstrap = bootstrap;
		exports.register = register;
		exports.render = render;
		
		var _semver = __webpack_require__(83);
		
		var _semver2 = _interopRequireDefault(_semver);
		
		var _util = __webpack_require__(81);
		
		var _ = _interopRequireWildcard(_util);
		
		var _config = __webpack_require__(79);
		
		var config = _interopRequireWildcard(_config);
		
		var _perf = __webpack_require__(77);
		
		var perf = _interopRequireWildcard(_perf);
		
		var _vm = __webpack_require__(85);
		
		var _vm2 = _interopRequireDefault(_vm);
		
		var _downgrade = __webpack_require__(99);
		
		var downgrade = _interopRequireWildcard(_downgrade);
		
		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /**
		                                                                                                                                                                                                                   * @fileOverview
		                                                                                                                                                                                                                   * api that invoked by js bundle code
		                                                                                                                                                                                                                   *
		                                                                                                                                                                                                                   * - define(name, factory): define a new composed component type
		                                                                                                                                                                                                                   * - bootstrap(type, config, data): require a certain type &
		                                                                                                                                                                                                                   *         render with (optional) data
		                                                                                                                                                                                                                   *
		                                                                                                                                                                                                                   * deprecated:
		                                                                                                                                                                                                                   * - register(type, options): register a new composed component type
		                                                                                                                                                                                                                   * - render(type, data): render by a certain type with (optional) data
		                                                                                                                                                                                                                   * - require(type)(data): require a type then render with data
		                                                                                                                                                                                                                   */
		
		var WEEX_COMPONENT_REG = /^\@weex-component\//;
		var WEEX_MODULE_REG = /^\@weex-module\//;
		var NORMAL_MODULE_REG = /^\.{1,2}\//;
		var JS_SURFIX_REG = /\.js$/;
		
		var isWeexComponent = function isWeexComponent(name) {
		  return !!name.match(WEEX_COMPONENT_REG);
		};
		var isWeexModule = function isWeexModule(name) {
		  return !!name.match(WEEX_MODULE_REG);
		};
		var isNormalModule = function isNormalModule(name) {
		  return !!name.match(NORMAL_MODULE_REG);
		};
		var isNpmModule = function isNpmModule(name) {
		  return !isWeexComponent(name) && !isWeexModule(name) && !isNormalModule(name);
		};
		
		function removeWeexPrefix(str) {
		  return str.replace(WEEX_COMPONENT_REG, '').replace(WEEX_MODULE_REG, '');
		}
		
		function removeJSSurfix(str) {
		  return str.replace(JS_SURFIX_REG, '');
		}
		
		var commonModules = {};
		
		function clearCommonModules() {
		  commonModules = {};
		}
		
		// define(name, factory) for primary usage
		// or
		// define(name, deps, factory) for compatibility
		// Notice: DO NOT use function define() {},
		// it will cause error after builded by webpack
		var define = exports.define = function define(name, deps, factory) {
		  var _this = this;
		
		  perf.start('define', name);
		
		  if (_.typof(deps) === 'function') {
		    factory = deps;
		    deps = [];
		  }
		
		  var _require = function _require(name) {
		    var cleanName = void 0;
		
		    if (isWeexComponent(name)) {
		      cleanName = removeWeexPrefix(name);
		      return _this.requireComponent(cleanName);
		    }
		    if (isWeexModule(name)) {
		      cleanName = removeWeexPrefix(name);
		      return _this.requireModule(cleanName);
		    }
		    if (isNormalModule(name)) {
		      cleanName = removeJSSurfix(name);
		      return commonModules[name];
		    }
		    if (isNpmModule(name)) {
		      cleanName = removeJSSurfix(name);
		      return commonModules[name];
		    }
		  };
		  var _module = { exports: {} };
		
		  var cleanName = void 0;
		  if (isWeexComponent(name)) {
		    cleanName = removeWeexPrefix(name);
		
		    factory(_require, _module.exports, _module);
		
		    this.registerComponent(cleanName, _module.exports);
		  } else if (isWeexModule(name)) {
		    cleanName = removeWeexPrefix(name);
		
		    factory(_require, _module.exports, _module);
		
		    _vm2.default.registerModules(_defineProperty({}, cleanName, _module.exports));
		  } else if (isNormalModule(name)) {
		    cleanName = removeJSSurfix(name);
		
		    factory(_require, _module.exports, _module);
		
		    commonModules[cleanName] = _module.exports;
		  } else if (isNpmModule(name)) {
		    cleanName = removeJSSurfix(name);
		
		    factory(_require, _module.exports, _module);
		
		    var exports = _module.exports;
		    if (exports.template || exports.style || exports.methods) {
		      // downgrade to old define method (define('componentName', factory))
		      // the exports contain one key of template, style or methods
		      // but it has risk!!!
		      this.registerComponent(cleanName, exports);
		    } else {
		      commonModules[cleanName] = _module.exports;
		    }
		  }
		
		  perf.end('define', name);
		};
		
		function bootstrap(name, config, data) {
		  var cleanName = void 0;
		
		  if (isWeexComponent(name)) {
		    cleanName = removeWeexPrefix(name);
		  } else if (isNpmModule(name)) {
		    cleanName = removeJSSurfix(name);
		    // check if define by old 'define' method
		    if (!this.customComponentMap[cleanName]) {
		      return new Error('It\'s not a component: ' + name);
		    }
		  } else {
		    return new Error('Wrong component name: ' + name);
		  }
		
		  config = _.isPlainObject(config) ? config : {};
		
		  if (typeof config.transformerVersion === 'string' && typeof global.needTransformerVersion === 'string' && !_semver2.default.satisfies(config.transformerVersion, global.needTransformerVersion)) {
		    return new Error('JS Bundle version: ' + config.transformerVersion + ' ' + ('not compatible with ' + global.needTransformerVersion));
		  }
		
		  var _checkDowngrade = downgrade.check(config.downgrade);
		  if (_checkDowngrade.isDowngrade) {
		    this.callTasks([{
		      module: 'instanceWrap',
		      method: 'error',
		      args: [_checkDowngrade.errorType, _checkDowngrade.code, _checkDowngrade.errorMessage]
		    }]);
		    return new Error('Downgrade: ' + config.downgrade);
		  }
		
		  perf.start('create vm', cleanName);
		
		  this.vm = new _vm2.default(cleanName, { _app: this }, null, data, {
		    'hook:ready': function hookReady() {
		      perf.end('create vm', cleanName);
		    }
		  });
		}
		
		/**
		 * @deprecated
		 */
		function register(type, options) {
		  perf.start('register', type);
		  this.registerComponent(type, options);
		  perf.end('register', type);
		}
		
		/**
		 * @deprecated
		 */
		function render(type, data) {
		  return this.bootstrap(type, {}, data);
		}
		
		/**
		 * @deprecated
		 */
		function _require2(type) {
		  var _this2 = this;
		
		  return function (data) {
		    return _this2.bootstrap(type, {}, data);
		  };
		}
		exports.require = _require2;
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 83 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {'use strict';
		
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
		
		exports = module.exports = SemVer;
		
		// The debug function is excluded entirely from the minified version.
		/* nomin */var debug;
		/* nomin */if ((typeof process === 'undefined' ? 'undefined' : _typeof(process)) === 'object' &&
		/* nomin */process.env &&
		/* nomin */process.env.NODE_DEBUG &&
		/* nomin *//\bsemver\b/i.test(process.env.NODE_DEBUG))
		  /* nomin */debug = function debug() {
		    /* nomin */var args = Array.prototype.slice.call(arguments, 0);
		    /* nomin */args.unshift('SEMVER');
		    /* nomin */console.log.apply(console, args);
		    /* nomin */
		  };
		  /* nomin */else
		  /* nomin */debug = function debug() {};
		
		// Note: this is the semver.org version of the spec that it implements
		// Not necessarily the package version of this code.
		exports.SEMVER_SPEC_VERSION = '2.0.0';
		
		var MAX_LENGTH = 256;
		var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
		
		// The actual regexps go on exports.re
		var re = exports.re = [];
		var src = exports.src = [];
		var R = 0;
		
		// The following Regular Expressions can be used for tokenizing,
		// validating, and parsing SemVer version strings.
		
		// ## Numeric Identifier
		// A single `0`, or a non-zero digit followed by zero or more digits.
		
		var NUMERICIDENTIFIER = R++;
		src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
		var NUMERICIDENTIFIERLOOSE = R++;
		src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';
		
		// ## Non-numeric Identifier
		// Zero or more digits, followed by a letter or hyphen, and then zero or
		// more letters, digits, or hyphens.
		
		var NONNUMERICIDENTIFIER = R++;
		src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
		
		// ## Main Version
		// Three dot-separated numeric identifiers.
		
		var MAINVERSION = R++;
		src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')';
		
		var MAINVERSIONLOOSE = R++;
		src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')';
		
		// ## Pre-release Version Identifier
		// A numeric identifier, or a non-numeric identifier.
		
		var PRERELEASEIDENTIFIER = R++;
		src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')';
		
		var PRERELEASEIDENTIFIERLOOSE = R++;
		src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] + '|' + src[NONNUMERICIDENTIFIER] + ')';
		
		// ## Pre-release Version
		// Hyphen, followed by one or more dot-separated pre-release version
		// identifiers.
		
		var PRERELEASE = R++;
		src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] + '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';
		
		var PRERELEASELOOSE = R++;
		src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';
		
		// ## Build Metadata Identifier
		// Any combination of digits, letters, or hyphens.
		
		var BUILDIDENTIFIER = R++;
		src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
		
		// ## Build Metadata
		// Plus sign, followed by one or more period-separated build metadata
		// identifiers.
		
		var BUILD = R++;
		src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] + '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';
		
		// ## Full Version String
		// A main version, followed optionally by a pre-release version and
		// build metadata.
		
		// Note that the only major, minor, patch, and pre-release sections of
		// the version string are capturing groups.  The build metadata is not a
		// capturing group, because it should not ever be used in version
		// comparison.
		
		var FULL = R++;
		var FULLPLAIN = 'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?';
		
		src[FULL] = '^' + FULLPLAIN + '$';
		
		// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
		// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
		// common in the npm registry.
		var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + '?' + src[BUILD] + '?';
		
		var LOOSE = R++;
		src[LOOSE] = '^' + LOOSEPLAIN + '$';
		
		var GTLT = R++;
		src[GTLT] = '((?:<|>)?=?)';
		
		// Something like "2.*" or "1.2.x".
		// Note that "x.x" is a valid xRange identifer, meaning "any version"
		// Only the first item is strictly required.
		var XRANGEIDENTIFIERLOOSE = R++;
		src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
		var XRANGEIDENTIFIER = R++;
		src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';
		
		var XRANGEPLAIN = R++;
		src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:' + src[PRERELEASE] + ')?' + src[BUILD] + '?' + ')?)?';
		
		var XRANGEPLAINLOOSE = R++;
		src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[PRERELEASELOOSE] + ')?' + src[BUILD] + '?' + ')?)?';
		
		var XRANGE = R++;
		src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
		var XRANGELOOSE = R++;
		src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';
		
		// Tilde ranges.
		// Meaning is "reasonably at or greater than"
		var LONETILDE = R++;
		src[LONETILDE] = '(?:~>?)';
		
		var TILDETRIM = R++;
		src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
		re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
		var tildeTrimReplace = '$1~';
		
		var TILDE = R++;
		src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
		var TILDELOOSE = R++;
		src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';
		
		// Caret ranges.
		// Meaning is "at least and backwards compatible with"
		var LONECARET = R++;
		src[LONECARET] = '(?:\\^)';
		
		var CARETTRIM = R++;
		src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
		re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
		var caretTrimReplace = '$1^';
		
		var CARET = R++;
		src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
		var CARETLOOSE = R++;
		src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';
		
		// A simple gt/lt/eq thing, or just "" to indicate "any version"
		var COMPARATORLOOSE = R++;
		src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
		var COMPARATOR = R++;
		src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';
		
		// An expression to strip any whitespace between the gtlt and the thing
		// it modifies, so that `> 1.2.3` ==> `>1.2.3`
		var COMPARATORTRIM = R++;
		src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] + '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';
		
		// this one has to use the /g flag
		re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
		var comparatorTrimReplace = '$1$2$3';
		
		// Something like `1.2.3 - 1.2.4`
		// Note that these all use the loose form, because they'll be
		// checked against either the strict or loose comparator form
		// later.
		var HYPHENRANGE = R++;
		src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAIN] + ')' + '\\s*$';
		
		var HYPHENRANGELOOSE = R++;
		src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAINLOOSE] + ')' + '\\s*$';
		
		// Star ranges basically just allow anything at all.
		var STAR = R++;
		src[STAR] = '(<|>)?=?\\s*\\*';
		
		// Compile to actual regexp objects.
		// All are flag-free, unless they were created above with a flag.
		for (var i = 0; i < R; i++) {
		  debug(i, src[i]);
		  if (!re[i]) re[i] = new RegExp(src[i]);
		}
		
		exports.parse = parse;
		function parse(version, loose) {
		  if (version instanceof SemVer) return version;
		
		  if (typeof version !== 'string') return null;
		
		  if (version.length > MAX_LENGTH) return null;
		
		  var r = loose ? re[LOOSE] : re[FULL];
		  if (!r.test(version)) return null;
		
		  try {
		    return new SemVer(version, loose);
		  } catch (er) {
		    return null;
		  }
		}
		
		exports.valid = valid;
		function valid(version, loose) {
		  var v = parse(version, loose);
		  return v ? v.version : null;
		}
		
		exports.clean = clean;
		function clean(version, loose) {
		  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
		  return s ? s.version : null;
		}
		
		exports.SemVer = SemVer;
		
		function SemVer(version, loose) {
		  if (version instanceof SemVer) {
		    if (version.loose === loose) return version;else version = version.version;
		  } else if (typeof version !== 'string') {
		    throw new TypeError('Invalid Version: ' + version);
		  }
		
		  if (version.length > MAX_LENGTH) throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
		
		  if (!(this instanceof SemVer)) return new SemVer(version, loose);
		
		  debug('SemVer', version, loose);
		  this.loose = loose;
		  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);
		
		  if (!m) throw new TypeError('Invalid Version: ' + version);
		
		  this.raw = version;
		
		  // these are actually numbers
		  this.major = +m[1];
		  this.minor = +m[2];
		  this.patch = +m[3];
		
		  if (this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError('Invalid major version');
		
		  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError('Invalid minor version');
		
		  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError('Invalid patch version');
		
		  // numberify any prerelease numeric ids
		  if (!m[4]) this.prerelease = [];else this.prerelease = m[4].split('.').map(function (id) {
		    if (/^[0-9]+$/.test(id)) {
		      var num = +id;
		      if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
		    }
		    return id;
		  });
		
		  this.build = m[5] ? m[5].split('.') : [];
		  this.format();
		}
		
		SemVer.prototype.format = function () {
		  this.version = this.major + '.' + this.minor + '.' + this.patch;
		  if (this.prerelease.length) this.version += '-' + this.prerelease.join('.');
		  return this.version;
		};
		
		SemVer.prototype.toString = function () {
		  return this.version;
		};
		
		SemVer.prototype.compare = function (other) {
		  debug('SemVer.compare', this.version, this.loose, other);
		  if (!(other instanceof SemVer)) other = new SemVer(other, this.loose);
		
		  return this.compareMain(other) || this.comparePre(other);
		};
		
		SemVer.prototype.compareMain = function (other) {
		  if (!(other instanceof SemVer)) other = new SemVer(other, this.loose);
		
		  return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
		};
		
		SemVer.prototype.comparePre = function (other) {
		  if (!(other instanceof SemVer)) other = new SemVer(other, this.loose);
		
		  // NOT having a prerelease is > having one
		  if (this.prerelease.length && !other.prerelease.length) return -1;else if (!this.prerelease.length && other.prerelease.length) return 1;else if (!this.prerelease.length && !other.prerelease.length) return 0;
		
		  var i = 0;
		  do {
		    var a = this.prerelease[i];
		    var b = other.prerelease[i];
		    debug('prerelease compare', i, a, b);
		    if (a === undefined && b === undefined) return 0;else if (b === undefined) return 1;else if (a === undefined) return -1;else if (a === b) continue;else return compareIdentifiers(a, b);
		  } while (++i);
		};
		
		// preminor will bump the version up to the next minor release, and immediately
		// down to pre-release. premajor and prepatch work the same way.
		SemVer.prototype.inc = function (release, identifier) {
		  switch (release) {
		    case 'premajor':
		      this.prerelease.length = 0;
		      this.patch = 0;
		      this.minor = 0;
		      this.major++;
		      this.inc('pre', identifier);
		      break;
		    case 'preminor':
		      this.prerelease.length = 0;
		      this.patch = 0;
		      this.minor++;
		      this.inc('pre', identifier);
		      break;
		    case 'prepatch':
		      // If this is already a prerelease, it will bump to the next version
		      // drop any prereleases that might already exist, since they are not
		      // relevant at this point.
		      this.prerelease.length = 0;
		      this.inc('patch', identifier);
		      this.inc('pre', identifier);
		      break;
		    // If the input is a non-prerelease version, this acts the same as
		    // prepatch.
		    case 'prerelease':
		      if (this.prerelease.length === 0) this.inc('patch', identifier);
		      this.inc('pre', identifier);
		      break;
		
		    case 'major':
		      // If this is a pre-major version, bump up to the same major version.
		      // Otherwise increment major.
		      // 1.0.0-5 bumps to 1.0.0
		      // 1.1.0 bumps to 2.0.0
		      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) this.major++;
		      this.minor = 0;
		      this.patch = 0;
		      this.prerelease = [];
		      break;
		    case 'minor':
		      // If this is a pre-minor version, bump up to the same minor version.
		      // Otherwise increment minor.
		      // 1.2.0-5 bumps to 1.2.0
		      // 1.2.1 bumps to 1.3.0
		      if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
		      this.patch = 0;
		      this.prerelease = [];
		      break;
		    case 'patch':
		      // If this is not a pre-release version, it will increment the patch.
		      // If it is a pre-release it will bump up to the same patch version.
		      // 1.2.0-5 patches to 1.2.0
		      // 1.2.0 patches to 1.2.1
		      if (this.prerelease.length === 0) this.patch++;
		      this.prerelease = [];
		      break;
		    // This probably shouldn't be used publicly.
		    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
		    case 'pre':
		      if (this.prerelease.length === 0) this.prerelease = [0];else {
		        var i = this.prerelease.length;
		        while (--i >= 0) {
		          if (typeof this.prerelease[i] === 'number') {
		            this.prerelease[i]++;
		            i = -2;
		          }
		        }
		        if (i === -1) // didn't increment anything
		          this.prerelease.push(0);
		      }
		      if (identifier) {
		        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
		        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
		        if (this.prerelease[0] === identifier) {
		          if (isNaN(this.prerelease[1])) this.prerelease = [identifier, 0];
		        } else this.prerelease = [identifier, 0];
		      }
		      break;
		
		    default:
		      throw new Error('invalid increment argument: ' + release);
		  }
		  this.format();
		  this.raw = this.version;
		  return this;
		};
		
		exports.inc = inc;
		function inc(version, release, loose, identifier) {
		  if (typeof loose === 'string') {
		    identifier = loose;
		    loose = undefined;
		  }
		
		  try {
		    return new SemVer(version, loose).inc(release, identifier).version;
		  } catch (er) {
		    return null;
		  }
		}
		
		exports.diff = diff;
		function diff(version1, version2) {
		  if (eq(version1, version2)) {
		    return null;
		  } else {
		    var v1 = parse(version1);
		    var v2 = parse(version2);
		    if (v1.prerelease.length || v2.prerelease.length) {
		      for (var key in v1) {
		        if (key === 'major' || key === 'minor' || key === 'patch') {
		          if (v1[key] !== v2[key]) {
		            return 'pre' + key;
		          }
		        }
		      }
		      return 'prerelease';
		    }
		    for (var key in v1) {
		      if (key === 'major' || key === 'minor' || key === 'patch') {
		        if (v1[key] !== v2[key]) {
		          return key;
		        }
		      }
		    }
		  }
		}
		
		exports.compareIdentifiers = compareIdentifiers;
		
		var numeric = /^[0-9]+$/;
		function compareIdentifiers(a, b) {
		  var anum = numeric.test(a);
		  var bnum = numeric.test(b);
		
		  if (anum && bnum) {
		    a = +a;
		    b = +b;
		  }
		
		  return anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : a > b ? 1 : 0;
		}
		
		exports.rcompareIdentifiers = rcompareIdentifiers;
		function rcompareIdentifiers(a, b) {
		  return compareIdentifiers(b, a);
		}
		
		exports.major = major;
		function major(a, loose) {
		  return new SemVer(a, loose).major;
		}
		
		exports.minor = minor;
		function minor(a, loose) {
		  return new SemVer(a, loose).minor;
		}
		
		exports.patch = patch;
		function patch(a, loose) {
		  return new SemVer(a, loose).patch;
		}
		
		exports.compare = compare;
		function compare(a, b, loose) {
		  return new SemVer(a, loose).compare(b);
		}
		
		exports.compareLoose = compareLoose;
		function compareLoose(a, b) {
		  return compare(a, b, true);
		}
		
		exports.rcompare = rcompare;
		function rcompare(a, b, loose) {
		  return compare(b, a, loose);
		}
		
		exports.sort = sort;
		function sort(list, loose) {
		  return list.sort(function (a, b) {
		    return exports.compare(a, b, loose);
		  });
		}
		
		exports.rsort = rsort;
		function rsort(list, loose) {
		  return list.sort(function (a, b) {
		    return exports.rcompare(a, b, loose);
		  });
		}
		
		exports.gt = gt;
		function gt(a, b, loose) {
		  return compare(a, b, loose) > 0;
		}
		
		exports.lt = lt;
		function lt(a, b, loose) {
		  return compare(a, b, loose) < 0;
		}
		
		exports.eq = eq;
		function eq(a, b, loose) {
		  return compare(a, b, loose) === 0;
		}
		
		exports.neq = neq;
		function neq(a, b, loose) {
		  return compare(a, b, loose) !== 0;
		}
		
		exports.gte = gte;
		function gte(a, b, loose) {
		  return compare(a, b, loose) >= 0;
		}
		
		exports.lte = lte;
		function lte(a, b, loose) {
		  return compare(a, b, loose) <= 0;
		}
		
		exports.cmp = cmp;
		function cmp(a, op, b, loose) {
		  var ret;
		  switch (op) {
		    case '===':
		      if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') a = a.version;
		      if ((typeof b === 'undefined' ? 'undefined' : _typeof(b)) === 'object') b = b.version;
		      ret = a === b;
		      break;
		    case '!==':
		      if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') a = a.version;
		      if ((typeof b === 'undefined' ? 'undefined' : _typeof(b)) === 'object') b = b.version;
		      ret = a !== b;
		      break;
		    case '':case '=':case '==':
		      ret = eq(a, b, loose);break;
		    case '!=':
		      ret = neq(a, b, loose);break;
		    case '>':
		      ret = gt(a, b, loose);break;
		    case '>=':
		      ret = gte(a, b, loose);break;
		    case '<':
		      ret = lt(a, b, loose);break;
		    case '<=':
		      ret = lte(a, b, loose);break;
		    default:
		      throw new TypeError('Invalid operator: ' + op);
		  }
		  return ret;
		}
		
		exports.Comparator = Comparator;
		function Comparator(comp, loose) {
		  if (comp instanceof Comparator) {
		    if (comp.loose === loose) return comp;else comp = comp.value;
		  }
		
		  if (!(this instanceof Comparator)) return new Comparator(comp, loose);
		
		  debug('comparator', comp, loose);
		  this.loose = loose;
		  this.parse(comp);
		
		  if (this.semver === ANY) this.value = '';else this.value = this.operator + this.semver.version;
		
		  debug('comp', this);
		}
		
		var ANY = {};
		Comparator.prototype.parse = function (comp) {
		  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
		  var m = comp.match(r);
		
		  if (!m) throw new TypeError('Invalid comparator: ' + comp);
		
		  this.operator = m[1];
		  if (this.operator === '=') this.operator = '';
		
		  // if it literally is just '>' or '' then allow anything.
		  if (!m[2]) this.semver = ANY;else this.semver = new SemVer(m[2], this.loose);
		};
		
		Comparator.prototype.toString = function () {
		  return this.value;
		};
		
		Comparator.prototype.test = function (version) {
		  debug('Comparator.test', version, this.loose);
		
		  if (this.semver === ANY) return true;
		
		  if (typeof version === 'string') version = new SemVer(version, this.loose);
		
		  return cmp(version, this.operator, this.semver, this.loose);
		};
		
		exports.Range = Range;
		function Range(range, loose) {
		  if (range instanceof Range && range.loose === loose) return range;
		
		  if (!(this instanceof Range)) return new Range(range, loose);
		
		  this.loose = loose;
		
		  // First, split based on boolean or ||
		  this.raw = range;
		  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
		    return this.parseRange(range.trim());
		  }, this).filter(function (c) {
		    // throw out any that are not relevant for whatever reason
		    return c.length;
		  });
		
		  if (!this.set.length) {
		    throw new TypeError('Invalid SemVer Range: ' + range);
		  }
		
		  this.format();
		}
		
		Range.prototype.format = function () {
		  this.range = this.set.map(function (comps) {
		    return comps.join(' ').trim();
		  }).join('||').trim();
		  return this.range;
		};
		
		Range.prototype.toString = function () {
		  return this.range;
		};
		
		Range.prototype.parseRange = function (range) {
		  var loose = this.loose;
		  range = range.trim();
		  debug('range', range, loose);
		  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
		  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
		  range = range.replace(hr, hyphenReplace);
		  debug('hyphen replace', range);
		  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
		  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
		  debug('comparator trim', range, re[COMPARATORTRIM]);
		
		  // `~ 1.2.3` => `~1.2.3`
		  range = range.replace(re[TILDETRIM], tildeTrimReplace);
		
		  // `^ 1.2.3` => `^1.2.3`
		  range = range.replace(re[CARETTRIM], caretTrimReplace);
		
		  // normalize spaces
		  range = range.split(/\s+/).join(' ');
		
		  // At this point, the range is completely trimmed and
		  // ready to be split into comparators.
		
		  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
		  var set = range.split(' ').map(function (comp) {
		    return parseComparator(comp, loose);
		  }).join(' ').split(/\s+/);
		  if (this.loose) {
		    // in loose mode, throw out any that are not valid comparators
		    set = set.filter(function (comp) {
		      return !!comp.match(compRe);
		    });
		  }
		  set = set.map(function (comp) {
		    return new Comparator(comp, loose);
		  });
		
		  return set;
		};
		
		// Mostly just for testing and legacy API reasons
		exports.toComparators = toComparators;
		function toComparators(range, loose) {
		  return new Range(range, loose).set.map(function (comp) {
		    return comp.map(function (c) {
		      return c.value;
		    }).join(' ').trim().split(' ');
		  });
		}
		
		// comprised of xranges, tildes, stars, and gtlt's at this point.
		// already replaced the hyphen ranges
		// turn into a set of JUST comparators.
		function parseComparator(comp, loose) {
		  debug('comp', comp);
		  comp = replaceCarets(comp, loose);
		  debug('caret', comp);
		  comp = replaceTildes(comp, loose);
		  debug('tildes', comp);
		  comp = replaceXRanges(comp, loose);
		  debug('xrange', comp);
		  comp = replaceStars(comp, loose);
		  debug('stars', comp);
		  return comp;
		}
		
		function isX(id) {
		  return !id || id.toLowerCase() === 'x' || id === '*';
		}
		
		// ~, ~> --> * (any, kinda silly)
		// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
		// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
		// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
		// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
		// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
		function replaceTildes(comp, loose) {
		  return comp.trim().split(/\s+/).map(function (comp) {
		    return replaceTilde(comp, loose);
		  }).join(' ');
		}
		
		function replaceTilde(comp, loose) {
		  var r = loose ? re[TILDELOOSE] : re[TILDE];
		  return comp.replace(r, function (_, M, m, p, pr) {
		    debug('tilde', comp, _, M, m, p, pr);
		    var ret;
		
		    if (isX(M)) ret = '';else if (isX(m)) ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';else if (isX(p))
		      // ~1.2 == >=1.2.0- <1.3.0-
		      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';else if (pr) {
		      debug('replaceTilde pr', pr);
		      if (pr.charAt(0) !== '-') pr = '-' + pr;
		      ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + (+m + 1) + '.0';
		    } else
		      // ~1.2.3 == >=1.2.3 <1.3.0
		      ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
		
		    debug('tilde return', ret);
		    return ret;
		  });
		}
		
		// ^ --> * (any, kinda silly)
		// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
		// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
		// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
		// ^1.2.3 --> >=1.2.3 <2.0.0
		// ^1.2.0 --> >=1.2.0 <2.0.0
		function replaceCarets(comp, loose) {
		  return comp.trim().split(/\s+/).map(function (comp) {
		    return replaceCaret(comp, loose);
		  }).join(' ');
		}
		
		function replaceCaret(comp, loose) {
		  debug('caret', comp, loose);
		  var r = loose ? re[CARETLOOSE] : re[CARET];
		  return comp.replace(r, function (_, M, m, p, pr) {
		    debug('caret', comp, _, M, m, p, pr);
		    var ret;
		
		    if (isX(M)) ret = '';else if (isX(m)) ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';else if (isX(p)) {
		      if (M === '0') ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';else ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
		    } else if (pr) {
		      debug('replaceCaret pr', pr);
		      if (pr.charAt(0) !== '-') pr = '-' + pr;
		      if (M === '0') {
		        if (m === '0') ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + m + '.' + (+p + 1);else ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + (+m + 1) + '.0';
		      } else ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + (+M + 1) + '.0.0';
		    } else {
		      debug('no pr');
		      if (M === '0') {
		        if (m === '0') ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);else ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
		      } else ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
		    }
		
		    debug('caret return', ret);
		    return ret;
		  });
		}
		
		function replaceXRanges(comp, loose) {
		  debug('replaceXRanges', comp, loose);
		  return comp.split(/\s+/).map(function (comp) {
		    return replaceXRange(comp, loose);
		  }).join(' ');
		}
		
		function replaceXRange(comp, loose) {
		  comp = comp.trim();
		  var r = loose ? re[XRANGELOOSE] : re[XRANGE];
		  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
		    debug('xRange', comp, ret, gtlt, M, m, p, pr);
		    var xM = isX(M);
		    var xm = xM || isX(m);
		    var xp = xm || isX(p);
		    var anyX = xp;
		
		    if (gtlt === '=' && anyX) gtlt = '';
		
		    if (xM) {
		      if (gtlt === '>' || gtlt === '<') {
		        // nothing is allowed
		        ret = '<0.0.0';
		      } else {
		        // nothing is forbidden
		        ret = '*';
		      }
		    } else if (gtlt && anyX) {
		      // replace X with 0
		      if (xm) m = 0;
		      if (xp) p = 0;
		
		      if (gtlt === '>') {
		        // >1 => >=2.0.0
		        // >1.2 => >=1.3.0
		        // >1.2.3 => >= 1.2.4
		        gtlt = '>=';
		        if (xm) {
		          M = +M + 1;
		          m = 0;
		          p = 0;
		        } else if (xp) {
		          m = +m + 1;
		          p = 0;
		        }
		      } else if (gtlt === '<=') {
		        // <=0.7.x is actually <0.8.0, since any 0.7.x should
		        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
		        gtlt = '<';
		        if (xm) M = +M + 1;else m = +m + 1;
		      }
		
		      ret = gtlt + M + '.' + m + '.' + p;
		    } else if (xm) {
		      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
		    } else if (xp) {
		      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
		    }
		
		    debug('xRange return', ret);
		
		    return ret;
		  });
		}
		
		// Because * is AND-ed with everything else in the comparator,
		// and '' means "any version", just remove the *s entirely.
		function replaceStars(comp, loose) {
		  debug('replaceStars', comp, loose);
		  // Looseness is ignored here.  star is always as loose as it gets!
		  return comp.trim().replace(re[STAR], '');
		}
		
		// This function is passed to string.replace(re[HYPHENRANGE])
		// M, m, patch, prerelease, build
		// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
		// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
		// 1.2 - 3.4 => >=1.2.0 <3.5.0
		function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
		
		  if (isX(fM)) from = '';else if (isX(fm)) from = '>=' + fM + '.0.0';else if (isX(fp)) from = '>=' + fM + '.' + fm + '.0';else from = '>=' + from;
		
		  if (isX(tM)) to = '';else if (isX(tm)) to = '<' + (+tM + 1) + '.0.0';else if (isX(tp)) to = '<' + tM + '.' + (+tm + 1) + '.0';else if (tpr) to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;else to = '<=' + to;
		
		  return (from + ' ' + to).trim();
		}
		
		// if ANY of the sets match ALL of its comparators, then pass
		Range.prototype.test = function (version) {
		  if (!version) return false;
		
		  if (typeof version === 'string') version = new SemVer(version, this.loose);
		
		  for (var i = 0; i < this.set.length; i++) {
		    if (testSet(this.set[i], version)) return true;
		  }
		  return false;
		};
		
		function testSet(set, version) {
		  for (var i = 0; i < set.length; i++) {
		    if (!set[i].test(version)) return false;
		  }
		
		  if (version.prerelease.length) {
		    // Find the set of versions that are allowed to have prereleases
		    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
		    // That should allow `1.2.3-pr.2` to pass.
		    // However, `1.2.4-alpha.notready` should NOT be allowed,
		    // even though it's within the range set by the comparators.
		    for (var i = 0; i < set.length; i++) {
		      debug(set[i].semver);
		      if (set[i].semver === ANY) continue;
		
		      if (set[i].semver.prerelease.length > 0) {
		        var allowed = set[i].semver;
		        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return true;
		      }
		    }
		
		    // Version has a -pre, but it's not one of the ones we like.
		    return false;
		  }
		
		  return true;
		}
		
		exports.satisfies = satisfies;
		function satisfies(version, range, loose) {
		  try {
		    range = new Range(range, loose);
		  } catch (er) {
		    return false;
		  }
		  return range.test(version);
		}
		
		exports.maxSatisfying = maxSatisfying;
		function maxSatisfying(versions, range, loose) {
		  return versions.filter(function (version) {
		    return satisfies(version, range, loose);
		  }).sort(function (a, b) {
		    return rcompare(a, b, loose);
		  })[0] || null;
		}
		
		exports.validRange = validRange;
		function validRange(range, loose) {
		  try {
		    // Return '*' instead of '' so that truthiness works.
		    // This will throw if it's invalid anyway
		    return new Range(range, loose).range || '*';
		  } catch (er) {
		    return null;
		  }
		}
		
		// Determine if version is less than all the versions possible in the range
		exports.ltr = ltr;
		function ltr(version, range, loose) {
		  return outside(version, range, '<', loose);
		}
		
		// Determine if version is greater than all the versions possible in the range.
		exports.gtr = gtr;
		function gtr(version, range, loose) {
		  return outside(version, range, '>', loose);
		}
		
		exports.outside = outside;
		function outside(version, range, hilo, loose) {
		  version = new SemVer(version, loose);
		  range = new Range(range, loose);
		
		  var gtfn, ltefn, ltfn, comp, ecomp;
		  switch (hilo) {
		    case '>':
		      gtfn = gt;
		      ltefn = lte;
		      ltfn = lt;
		      comp = '>';
		      ecomp = '>=';
		      break;
		    case '<':
		      gtfn = lt;
		      ltefn = gte;
		      ltfn = gt;
		      comp = '<';
		      ecomp = '<=';
		      break;
		    default:
		      throw new TypeError('Must provide a hilo val of "<" or ">"');
		  }
		
		  // If it satisifes the range it is not outside
		  if (satisfies(version, range, loose)) {
		    return false;
		  }
		
		  // From now on, variable terms are as if we're in "gtr" mode.
		  // but note that everything is flipped for the "ltr" function.
		
		  for (var i = 0; i < range.set.length; ++i) {
		    var comparators = range.set[i];
		
		    var high = null;
		    var low = null;
		
		    comparators.forEach(function (comparator) {
		      if (comparator.semver === ANY) {
		        comparator = new Comparator('>=0.0.0');
		      }
		      high = high || comparator;
		      low = low || comparator;
		      if (gtfn(comparator.semver, high.semver, loose)) {
		        high = comparator;
		      } else if (ltfn(comparator.semver, low.semver, loose)) {
		        low = comparator;
		      }
		    });
		
		    // If the edge version comparator has a operator then our version
		    // isn't outside it
		    if (high.operator === comp || high.operator === ecomp) {
		      return false;
		    }
		
		    // If the lowest version comparator has an operator and our version
		    // is less than it then it isn't higher than the range
		    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
		      return false;
		    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
		      return false;
		    }
		  }
		  return true;
		}
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(84)))
	
	/***/ },
	/* 84 */
	/***/ function(module, exports) {
	
		'use strict';
		
		// shim for using process in browser
		
		var process = module.exports = {};
		var queue = [];
		var draining = false;
		var currentQueue;
		var queueIndex = -1;
		
		function cleanUpNextTick() {
		    if (!draining || !currentQueue) {
		        return;
		    }
		    draining = false;
		    if (currentQueue.length) {
		        queue = currentQueue.concat(queue);
		    } else {
		        queueIndex = -1;
		    }
		    if (queue.length) {
		        drainQueue();
		    }
		}
		
		function drainQueue() {
		    if (draining) {
		        return;
		    }
		    var timeout = setTimeout(cleanUpNextTick);
		    draining = true;
		
		    var len = queue.length;
		    while (len) {
		        currentQueue = queue;
		        queue = [];
		        while (++queueIndex < len) {
		            if (currentQueue) {
		                currentQueue[queueIndex].run();
		            }
		        }
		        queueIndex = -1;
		        len = queue.length;
		    }
		    currentQueue = null;
		    draining = false;
		    clearTimeout(timeout);
		}
		
		process.nextTick = function (fun) {
		    var args = new Array(arguments.length - 1);
		    if (arguments.length > 1) {
		        for (var i = 1; i < arguments.length; i++) {
		            args[i - 1] = arguments[i];
		        }
		    }
		    queue.push(new Item(fun, args));
		    if (queue.length === 1 && !draining) {
		        setTimeout(drainQueue, 0);
		    }
		};
		
		// v8 likes predictible objects
		function Item(fun, array) {
		    this.fun = fun;
		    this.array = array;
		}
		Item.prototype.run = function () {
		    this.fun.apply(null, this.array);
		};
		process.title = 'browser';
		process.browser = true;
		process.env = {};
		process.argv = [];
		process.version = ''; // empty string to avoid regexp issues
		process.versions = {};
		
		function noop() {}
		
		process.on = noop;
		process.addListener = noop;
		process.once = noop;
		process.off = noop;
		process.removeListener = noop;
		process.removeAllListeners = noop;
		process.emit = noop;
		
		process.binding = function (name) {
		    throw new Error('process.binding is not supported');
		};
		
		process.cwd = function () {
		    return '/';
		};
		process.chdir = function (dir) {
		    throw new Error('process.chdir is not supported');
		};
		process.umask = function () {
		    return 0;
		};
	
	/***/ },
	/* 85 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = Vm;
		
		var _util = __webpack_require__(81);
		
		var _scope = __webpack_require__(86);
		
		var scope = _interopRequireWildcard(_scope);
		
		var _compiler = __webpack_require__(93);
		
		var compiler = _interopRequireWildcard(_compiler);
		
		var _directive = __webpack_require__(94);
		
		var directive = _interopRequireWildcard(_directive);
		
		var _domHelper = __webpack_require__(96);
		
		var domHelper = _interopRequireWildcard(_domHelper);
		
		var _events = __webpack_require__(97);
		
		var events = _interopRequireWildcard(_events);
		
		var _register = __webpack_require__(98);
		
		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
		
		function callOldReadyEntry(vm, component) {
		  if (component.methods && component.methods.ready) {
		    component.methods.ready.call(vm);
		  }
		}
		
		/**
		 * ViewModel constructor
		 *
		 * @param {string} type
		 * @param {object} parentVm   which contains _app
		 * @param {object} parentEl   root element or frag block
		 * @param {object} mergedData external data
		 * @param {object} externalEvents external events
		 */
		
		// import * as modules from './../api/modules'
		// import * as api from './../api/api'
		
		/**
		 * @fileOverview
		 * ViewModel Constructor & definition
		 */
		
		function Vm(type, parentVm, parentEl, mergedData, externalEvents) {
		  this._parent = parentVm._realParent ? parentVm._realParent : parentVm;
		  this._app = parentVm._app;
		  parentVm._childrenVms && parentVm._childrenVms.push(this);
		
		  var component = this._app.customComponentMap[type] || {};
		  var data = component.data || {};
		
		  this._options = component;
		  this._methods = component.methods || {};
		  this._computed = component.computed || {};
		  this._css = component.style || {};
		  this._ids = {};
		  this._watchers = [];
		  this._vmEvents = {};
		  this._childrenVms = [];
		  this._type = type;
		
		  // bind events and lifecycles
		  this._initEvents(externalEvents);
		
		  this.$emit('hook:init');
		  this._inited = true;
		  // proxy data and methods
		  // observe data and add this to vms
		  this._data = typeof data === 'function' ? data() : data;
		  if (mergedData) {
		    (0, _util.extend)(this._data, mergedData);
		  }
		  this._initScope();
		
		  this.$emit('hook:created');
		  this._created = true;
		  // backward old ready entry
		  callOldReadyEntry(this, component);
		
		  // if no parentElement then specify the documentElement
		  this._parentEl = parentEl || this._app.doc.documentElement;
		  this._build();
		}
		
		(0, _util.extend)(Vm.prototype, scope, compiler, directive, domHelper, events);
		(0, _util.extend)(Vm, {
		  registerModules: _register.registerModules,
		  registerMethods: _register.registerMethods
		});
		// Vm.registerModules(modules)
	
	/***/ },
	/* 86 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _ = __webpack_require__(87);
		var Observer = __webpack_require__(88);
		var Dep = __webpack_require__(90);
		
		/**
		 * Setup the scope of an instance, which contains:
		 * - observed data
		 * - computed properties
		 * - user methods
		 * - meta properties
		 */
		
		exports._initScope = function () {
		  this._initData();
		  this._initComputed();
		  this._initMethods();
		  // this._initMeta()
		};
		
		/**
		 * Initialize the data. 
		 */
		
		var KEY_WORDS = ['$index', '$value', '$event'];
		exports._initData = function () {
		  // proxy data on instance
		  var data = this._data;
		  var i, key;
		  // // make sure all props properties are observed
		  // var props = this.$options.props
		  // if (props) {
		  //   i = props.length
		  //   while (i--) {
		  //     key = _.camelize(props[i])
		  //     if (!(key in data)) {
		  //       data[key] = null
		  //     }
		  //   }
		  // }
		  var keys = Object.keys(data);
		  i = keys.length;
		  while (i--) {
		    key = keys[i];
		    if (KEY_WORDS.indexOf(key) > -1 || !_.isReserved(key)) {
		      this._proxy(key);
		    }
		  }
		  // observe data
		  Observer.create(data).addVm(this);
		};
		
		// /**
		//  * Swap the isntance's $data. Called in $data's setter.
		//  *
		//  * @param {Object} newData
		//  */
		
		// exports._setData = function (newData) {
		//   newData = newData || {}
		//   var oldData = this._data
		//   this._data = newData
		//   var keys, key, i
		//   // unproxy keys not present in new data
		//   keys = Object.keys(oldData)
		//   i = keys.length
		//   while (i--) {
		//     key = keys[i]
		//     if (!_.isReserved(key) && !(key in newData)) {
		//       this._unproxy(key)
		//     }
		//   }
		//   // proxy keys not already proxied,
		//   // and trigger change for changed values
		//   keys = Object.keys(newData)
		//   i = keys.length
		//   while (i--) {
		//     key = keys[i]
		//     if (!this.hasOwnProperty(key) && !_.isReserved(key)) {
		//       // new property
		//       this._proxy(key)
		//     }
		//   }
		//   oldData.__ob__.removeVm(this)
		//   Observer.create(newData).addVm(this)
		//   this._digest()
		// }
		
		/**
		 * Proxy a property, so that
		 * vm.prop === vm._data.prop
		 *
		 * @param {String} key
		 */
		
		exports._proxy = function (key) {
		  // need to store ref to self here
		  // because these getter/setters might
		  // be called by child instances!
		  var self = this;
		  Object.defineProperty(self, key, {
		    configurable: true,
		    enumerable: true,
		    get: function proxyGetter() {
		      return self._data[key];
		    },
		    set: function proxySetter(val) {
		      self._data[key] = val;
		    }
		  });
		};
		
		/**
		 * Unproxy a property.
		 *
		 * @param {String} key
		 */
		
		exports._unproxy = function (key) {
		  delete this[key];
		};
		
		// /**
		//  * Force update on every watcher in scope.
		//  */
		
		// exports._digest = function () {
		//   var i = this._watchers.length
		//   while (i--) {
		//     this._watchers[i].update()
		//   }
		//   var children = this._children
		//   i = children.length
		//   while (i--) {
		//     var child = children[i]
		//     if (child.$options.inherit) {
		//       child._digest()
		//     }
		//   }
		// }
		
		/**
		 * Setup computed properties. They are essentially
		 * special getter/setters
		 */
		
		function noop() {}
		exports._initComputed = function () {
		  // var computed = this.$options.computed
		  var computed = this._computed;
		  if (computed) {
		    for (var key in computed) {
		      var userDef = computed[key];
		      var def = {
		        enumerable: true,
		        configurable: true
		      };
		      if (typeof userDef === 'function') {
		        def.get = _.bind(userDef, this);
		        def.set = noop;
		      } else {
		        def.get = userDef.get ? _.bind(userDef.get, this) : noop;
		        def.set = userDef.set ? _.bind(userDef.set, this) : noop;
		      }
		      Object.defineProperty(this, key, def);
		    }
		  }
		};
		
		/**
		 * Setup instance methods. Methods must be bound to the
		 * instance since they might be called by children
		 * inheriting them.
		 */
		
		exports._initMethods = function () {
		  // var methods = this.$options.methods
		  var methods = this._methods;
		  if (methods) {
		    for (var key in methods) {
		      this[key] = _.bind(methods[key], this);
		    }
		  }
		};
		
		// /**
		//  * Initialize meta information like $index, $key & $value.
		//  */
	
		// exports._initMeta = function () {
		//   var metas = this.$options._meta
		//   if (metas) {
		//     for (var key in metas) {
		//       this._defineMeta(key, metas[key])
		//     }
		//   }
		// }
	
		// /**
		//  * Define a meta property, e.g $index, $key, $value
		//  * which only exists on the vm instance but not in $data.
		//  *
		//  * @param {String} key
		//  * @param {*} value
		//  */
	
		// exports._defineMeta = function (key, value) {
		//   var dep = new Dep()
		//   Object.defineProperty(this, key, {
		//     enumerable: true,
		//     configurable: true,
		//     get: function metaGetter () {
		//       if (Observer.target) {
		//         Observer.target.addDep(dep)
		//       }
		//       return value
		//     },
		//     set: function metaSetter (val) {
		//       if (val !== value) {
		//         value = val
		//         dep.notify()
		//       }
		//     }
		//   })
		// }
	
	/***/ },
	/* 87 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		// required for code in instance/observer
		module.exports = __webpack_require__(81);
	
	/***/ },
	/* 88 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _ = __webpack_require__(87);
		var config = __webpack_require__(89);
		var Dep = __webpack_require__(90);
		var arrayMethods = __webpack_require__(91);
		var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
		__webpack_require__(92);
		
		var uid = 0;
		
		/**
		 * Type enums
		 */
		
		var ARRAY = 0;
		var OBJECT = 1;
		
		/**
		 * Augment an target Object or Array by intercepting
		 * the prototype chain using __proto__
		 *
		 * @param {Object|Array} target
		 * @param {Object} proto
		 */
		
		function protoAugment(target, src) {
		  target.__proto__ = src;
		}
		
		/**
		 * Augment an target Object or Array by defining
		 * hidden properties.
		 *
		 * @param {Object|Array} target
		 * @param {Object} proto
		 */
		
		function copyAugment(target, src, keys) {
		  var i = keys.length;
		  var key;
		  while (i--) {
		    key = keys[i];
		    _.define(target, key, src[key]);
		  }
		}
		
		/**
		 * Observer class that are attached to each observed
		 * object. Once attached, the observer converts target
		 * object's property keys into getter/setters that
		 * collect dependencies and dispatches updates.
		 *
		 * @param {Array|Object} value
		 * @param {Number} type
		 * @constructor
		 */
		
		function Observer(value, type) {
		  this.id = ++uid;
		  this.value = value;
		  this.active = true;
		  this.deps = [];
		  _.define(value, '__ob__', this);
		  if (type === ARRAY) {
		    var augment = config.proto && _.hasProto ? protoAugment : copyAugment;
		    augment(value, arrayMethods, arrayKeys);
		    this.observeArray(value);
		  } else if (type === OBJECT) {
		    this.walk(value);
		  }
		}
		
		Observer.target = null;
		
		var p = Observer.prototype;
		
		/**
		 * Attempt to create an observer instance for a value,
		 * returns the new observer if successfully observed,
		 * or the existing observer if the value already has one.
		 *
		 * @param {*} value
		 * @return {Observer|undefined}
		 * @static
		 */
		
		Observer.create = function (value) {
		  if (value && value.hasOwnProperty('__ob__') && value.__ob__ instanceof Observer) {
		    return value.__ob__;
		  } else if (_.isArray(value)) {
		    return new Observer(value, ARRAY);
		  } else if (_.isPlainObject(value) && !value._isVue // avoid Vue instance
		  ) {
		      return new Observer(value, OBJECT);
		    }
		};
		
		/**
		 * Walk through each property and convert them into
		 * getter/setters. This method should only be called when
		 * value type is Object. Properties prefixed with `$` or `_`
		 * and accessor properties are ignored.
		 *
		 * @param {Object} obj
		 */
		
		p.walk = function (obj) {
		  var keys = Object.keys(obj);
		  var i = keys.length;
		  var key, prefix;
		  while (i--) {
		    key = keys[i];
		    prefix = key.charCodeAt(0);
		    if (prefix !== 0x24 && prefix !== 0x5F) {
		      // skip $ or _
		      this.convert(key, obj[key]);
		    }
		  }
		};
		
		/**
		 * Try to carete an observer for a child value,
		 * and if value is array, link dep to the array.
		 *
		 * @param {*} val
		 * @return {Dep|undefined}
		 */
		
		p.observe = function (val) {
		  return Observer.create(val);
		};
		
		/**
		 * Observe a list of Array items.
		 *
		 * @param {Array} items
		 */
		
		p.observeArray = function (items) {
		  var i = items.length;
		  while (i--) {
		    this.observe(items[i]);
		  }
		};
		
		/**
		 * Convert a property into getter/setter so we can emit
		 * the events when the property is accessed/changed.
		 *
		 * @param {String} key
		 * @param {*} val
		 */
		
		p.convert = function (key, val) {
		  var ob = this;
		  var childOb = ob.observe(val);
		  var dep = new Dep();
		  if (childOb) {
		    childOb.deps.push(dep);
		  }
		  Object.defineProperty(ob.value, key, {
		    enumerable: true,
		    configurable: true,
		    get: function get() {
		      // Observer.target is a watcher whose getter is
		      // currently being evaluated.
		      if (ob.active && Observer.target) {
		        Observer.target.addDep(dep);
		      }
		      return val;
		    },
		    set: function set(newVal) {
		      if (newVal === val) return;
		      // remove dep from old value
		      var oldChildOb = val && val.__ob__;
		      if (oldChildOb) {
		        oldChildOb.deps.$remove(dep);
		      }
		      val = newVal;
		      // add dep to new value
		      var newChildOb = ob.observe(newVal);
		      if (newChildOb) {
		        newChildOb.deps.push(dep);
		      }
		      dep.notify();
		    }
		  });
		};
		
		/**
		 * Notify change on all self deps on an observer.
		 * This is called when a mutable value mutates. e.g.
		 * when an Array's mutating methods are called, or an
		 * Object's $add/$delete are called.
		 */
		
		p.notify = function () {
		  var deps = this.deps;
		  for (var i = 0, l = deps.length; i < l; i++) {
		    deps[i].notify();
		  }
		};
		
		/**
		 * Add an owner vm, so that when $add/$delete mutations
		 * happen we can notify owner vms to proxy the keys and
		 * digest the watchers. This is only called when the object
		 * is observed as an instance's root $data.
		 *
		 * @param {Vue} vm
		 */
		
		p.addVm = function (vm) {
		  (this.vms = this.vms || []).push(vm);
		};
		
		/**
		 * Remove an owner vm. This is called when the object is
		 * swapped out as an instance's $data object.
		 *
		 * @param {Vue} vm
		 */
		
		p.removeVm = function (vm) {
		  this.vms.$remove(vm);
		};
		
		module.exports = Observer;
	
	/***/ },
	/* 89 */
	/***/ function(module, exports) {
	
		"use strict";
		
		module.exports = { proto: true };
	
	/***/ },
	/* 90 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _ = __webpack_require__(87);
		
		/**
		 * A dep is an observable that can have multiple
		 * directives subscribing to it.
		 *
		 * @constructor
		 */
		
		function Dep() {
		  this.subs = [];
		}
		
		var p = Dep.prototype;
		
		/**
		 * Add a directive subscriber.
		 *
		 * @param {Directive} sub
		 */
		
		p.addSub = function (sub) {
		  this.subs.push(sub);
		};
		
		/**
		 * Remove a directive subscriber.
		 *
		 * @param {Directive} sub
		 */
		
		p.removeSub = function (sub) {
		  this.subs.$remove(sub);
		};
		
		/**
		 * Notify all subscribers of a new value.
		 */
		
		p.notify = function () {
		  // stablize the subscriber list first
		  var subs = _.toArray(this.subs);
		  for (var i = 0, l = subs.length; i < l; i++) {
		    subs[i].update();
		  }
		};
		
		module.exports = Dep;
	
	/***/ },
	/* 91 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _ = __webpack_require__(87);
		var arrayProto = Array.prototype;
		var arrayMethods = Object.create(arrayProto)
		
		/**
		 * Intercept mutating methods and emit events
		 */
		
		;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
		  // cache original method
		  var original = arrayProto[method];
		  _.define(arrayMethods, method, function mutator() {
		    // avoid leaking arguments:
		    // http://jsperf.com/closure-with-arguments
		    var i = arguments.length;
		    var args = new Array(i);
		    while (i--) {
		      args[i] = arguments[i];
		    }
		    var result = original.apply(this, args);
		    var ob = this.__ob__;
		    var inserted;
		    switch (method) {
		      case 'push':
		        inserted = args;
		        break;
		      case 'unshift':
		        inserted = args;
		        break;
		      case 'splice':
		        inserted = args.slice(2);
		        break;
		    }
		    if (inserted) ob.observeArray(inserted);
		    // notify change
		    ob.notify();
		    return result;
		  });
		});
		
		/**
		 * Swap the element at the given index with a new value
		 * and emits corresponding event.
		 *
		 * @param {Number} index
		 * @param {*} val
		 * @return {*} - replaced element
		 */
		
		_.define(arrayProto, '$set', function $set(index, val) {
		  if (index >= this.length) {
		    this.length = index + 1;
		  }
		  return this.splice(index, 1, val)[0];
		});
		
		/**
		 * Convenience method to remove the element at given index.
		 *
		 * @param {Number} index
		 * @param {*} val
		 */
		
		_.define(arrayProto, '$remove', function $remove(index) {
		  /* istanbul ignore if */
		  if (!this.length) return;
		  if (typeof index !== 'number') {
		    index = _.indexOf(this, index);
		  }
		  if (index > -1) {
		    this.splice(index, 1);
		  }
		});
		
		module.exports = arrayMethods;
	
	/***/ },
	/* 92 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _ = __webpack_require__(87);
		var objProto = Object.prototype;
		
		/**
		 * Add a new property to an observed object
		 * and emits corresponding event
		 *
		 * @param {String} key
		 * @param {*} val
		 * @public
		 */
		
		_.define(objProto, '$add', function $add(key, val) {
		  if (this.hasOwnProperty(key)) return;
		  var ob = this.__ob__;
		  if (!ob || _.isReserved(key)) {
		    this[key] = val;
		    return;
		  }
		  ob.convert(key, val);
		  ob.notify();
		  if (ob.vms) {
		    var i = ob.vms.length;
		    while (i--) {
		      var vm = ob.vms[i];
		      vm._proxy(key);
		      // vm._digest() // todo
		    }
		  }
		});
		
		/**
		 * Set a property on an observed object, calling add to
		 * ensure the property is observed.
		 *
		 * @param {String} key
		 * @param {*} val
		 * @public
		 */
		
		_.define(objProto, '$set', function $set(key, val) {
		  this.$add(key, val);
		  this[key] = val;
		});
		
		/**
		 * Deletes a property from an observed object
		 * and emits corresponding event
		 *
		 * @param {String} key
		 * @public
		 */
		
		_.define(objProto, '$delete', function $delete(key) {
		  if (!this.hasOwnProperty(key)) return;
		  delete this[key];
		  var ob = this.__ob__;
		  if (!ob || _.isReserved(key)) {
		    return;
		  }
		  ob.notify();
		  if (ob.vms) {
		    var i = ob.vms.length;
		    while (i--) {
		      var vm = ob.vms[i];
		      vm._unproxy(key);
		      // vm._digest() // todo
		    }
		  }
		});
	
	/***/ },
	/* 93 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
		
		exports._build = _build;
		exports._compile = _compile;
		exports._targetIsFragment = _targetIsFragment;
		exports._targetIsContent = _targetIsContent;
		exports._targetNeedCheckRepeat = _targetNeedCheckRepeat;
		exports._targetNeedCheckShown = _targetNeedCheckShown;
		exports._targetNeedCheckType = _targetNeedCheckType;
		exports._targetIsComposed = _targetIsComposed;
		exports._compileFragment = _compileFragment;
		exports._compileRepeat = _compileRepeat;
		exports._compileShown = _compileShown;
		exports._compileType = _compileType;
		exports._compileCustomComponent = _compileCustomComponent;
		exports._compileNativeComponent = _compileNativeComponent;
		exports._compileChildren = _compileChildren;
		exports._bindRepeat = _bindRepeat;
		exports._bindShown = _bindShown;
		exports._watchBlock = _watchBlock;
		exports._mergeContext = _mergeContext;
		/**
		 * @fileOverview
		 * ViewModel template parser & data-binding process
		 *
		 * required:
		 * index.js: Vm
		 * dom-helper.js: _createElement, _createBlock
		 * dom-helper.js: _attachTarget, _moveTarget, _removeTarget
		 * directive.js: _bindElement, _bindSubVm, _watch
		 * events.js: $on
		 */
		
		/**
		 * build(externalDirs)
		 *   createVm()
		 *   merge(externalDirs, dirs)
		 *   compile(template, parentNode)
		 *     if (type is content) create contentNode
		 *     else if (dirs have v-for) foreach -> create context
		 *       -> compile(templateWithoutFor, parentNode): diff(list) onchange
		 *     else if (dirs have v-if) assert
		 *       -> compile(templateWithoutIf, parentNode): toggle(shown) onchange
		 *     else if (type is native)
		 *       set(dirs): update(id/attr/style/class) onchange
		 *       append(template, parentNode)
		 *       foreach childNodes -> compile(childNode, template)
		 *     else if (type is custom)
		 *       addChildVm(vm, parentVm)
		 *       build(externalDirs)
		 *       foreach childNodes -> compile(childNode, template)
		 */
		function _build() {
		  var opt = this._options || {};
		  var template = opt.template || {};
		
		  if (opt.replace) {
		    if (template.children && template.children.length === 1) {
		      this._compile(template.children[0], this._parentEl);
		    } else {
		      this._compile(template.children, this._parentEl);
		    }
		  } else {
		    this._compile(template, this._parentEl);
		  }
		
		  this.$emit('hook:ready');
		  this._ready = true;
		}
		
		/**
		 * Generate elements by child or children and append to parent elements.
		 * Root element info would be merged if has. The first argument may be an array
		 * if the root element with options.replace has not only one child.
		 *
		 * @param {object|array} target
		 * @param {object}       dest
		 * @param {object}       meta
		 */
		function _compile(target, dest, meta) {
		  var context = this;
		  if (context._targetIsFragment(target)) {
		    context._compileFragment(target, dest, meta);
		    return;
		  }
		  meta = meta || {};
		  if (context._targetIsContent(target)) {
		    context._content = context._createBlock(dest);
		    return;
		  }
		
		  if (context._targetNeedCheckRepeat(target, meta)) {
		    context._compileRepeat(target, dest);
		    return;
		  }
		  if (context._targetNeedCheckShown(target, meta)) {
		    context._compileShown(target, dest, meta);
		    return;
		  }
		  var typeGetter = meta.type || target.type;
		  if (context._targetNeedCheckType(typeGetter, meta)) {
		    context._compileType(target, dest, typeGetter, meta);
		    return;
		  }
		  var type = typeGetter;
		  if (context._targetIsComposed(target, type)) {
		    context._compileCustomComponent(target, dest, type, meta);
		    return;
		  }
		  context._compileNativeComponent(target, dest, type);
		}
		
		/**
		 * Check if target is a fragment (an array).
		 *
		 * @param  {object}  target
		 * @return {boolean}
		 */
		function _targetIsFragment(target) {
		  return Array.isArray(target);
		}
		
		/**
		 * Check if target type is content/slot.
		 *
		 * @param  {object}  target
		 * @return {boolean}
		 */
		function _targetIsContent(target) {
		  return target.type === 'content' || target.type === 'slot';
		}
		
		/**
		 * Check if target need to compile by a list.
		 *
		 * @param  {object}  target
		 * @param  {object}  meta
		 * @return {boolean}
		 */
		function _targetNeedCheckRepeat(target, meta) {
		  return !meta.hasOwnProperty('repeat') && target.repeat;
		}
		
		/**
		 * Check if target need to compile by a boolean value.
		 *
		 * @param  {object}  target
		 * @param  {object}  meta
		 * @return {boolean}
		 */
		function _targetNeedCheckShown(target, meta) {
		  return !meta.hasOwnProperty('shown') && target.shown;
		}
		
		/**
		 * Check if target need to compile by a dynamic type.
		 *
		 * @param  {string|function} typeGetter
		 * @param  {object}          meta
		 * @return {boolean}
		 */
		function _targetNeedCheckType(typeGetter, meta) {
		  return typeof typeGetter === 'function' && !meta.hasOwnProperty('type');
		}
		
		/**
		 * Check if this kind of component is composed.
		 *
		 * @param  {string}  type
		 * @return {boolean}
		 */
		function _targetIsComposed(target, type) {
		  if (this._app && this._app.customComponentMap && type) {
		    return !!this._app.customComponentMap[type];
		  }
		  return !!target.component;
		}
		
		/**
		 * Compile a list of targets.
		 *
		 * @param {object} target
		 * @param {object} dest
		 * @param {object} meta
		 */
		function _compileFragment(target, dest, meta) {
		  var _this = this;
		
		  var fragBlock = this._createBlock(dest);
		  target.forEach(function (child) {
		    _this._compile(child, fragBlock, meta);
		  });
		}
		
		/**
		 * Compile a target with repeat directive.
		 *
		 * @param {object} target
		 * @param {object} dest
		 */
		function _compileRepeat(target, dest) {
		  var repeat = target.repeat;
		  var oldStyle = typeof repeat === 'function';
		  var getter = repeat.getter || repeat.expression || repeat;
		  if (typeof getter !== 'function') {
		    getter = function getter() {
		      return [];
		    };
		  }
		  var key = repeat.key || '$index';
		  var value = repeat.value || '$value';
		  var trackBy = repeat.trackBy || target.trackBy || target.attr && target.attr.trackBy || key;
		
		  var fragBlock = this._createBlock(dest);
		  fragBlock.children = [];
		  fragBlock.data = [];
		  fragBlock.vms = [];
		
		  this._bindRepeat(target, fragBlock, { getter: getter, key: key, value: value, trackBy: trackBy, oldStyle: oldStyle });
		}
		
		/**
		 * Compile a target with if directive.
		 *
		 * @param {object} target
		 * @param {object} dest
		 * @param {object} meta
		 */
		function _compileShown(target, dest, meta) {
		  var newMeta = { shown: true };
		  var fragBlock = this._createBlock(dest);
		
		  if (dest.element && dest.children) {
		    dest.children.push(fragBlock);
		  }
		
		  if (meta.repeat) {
		    newMeta.repeat = meta.repeat;
		  }
		
		  this._bindShown(target, fragBlock, newMeta);
		}
		
		/**
		 * Compile a target with dynamic component type.
		 *
		 * @param {object}   target
		 * @param {object}   dest
		 * @param {function} typeGetter
		 */
		function _compileType(target, dest, typeGetter, meta) {
		  var _this2 = this;
		
		  var type = typeGetter.call(this);
		  var newMeta = Object.assign({ type: type }, meta);
		  var fragBlock = this._createBlock(dest);
		
		  if (dest.element && dest.children) {
		    dest.children.push(fragBlock);
		  }
		
		  this._watch(typeGetter, function (value) {
		    var newMeta = Object.assign({ type: value }, meta);
		    _this2._removeBlock(fragBlock, true);
		    _this2._compile(target, fragBlock, newMeta);
		  });
		
		  this._compile(target, fragBlock, newMeta);
		}
		
		/**
		 * Compile a composed component.
		 *
		 * @param {object} target
		 * @param {object} dest
		 * @param {string} type
		 */
		function _compileCustomComponent(target, dest, type, meta) {
		  var Vm = this.constructor;
		  var context = this;
		  var subVm = new Vm(type, context, dest, undefined, {
		    'hook:init': function hookInit() {
		      context._setId(target.id, null, this);
		    },
		    'hook:created': function hookCreated() {
		      context._bindSubVm(this, target, meta.repeat);
		    },
		    'hook:ready': function hookReady() {
		      if (this._content) {
		        context._compileChildren(target, this._content);
		      }
		    }
		  });
		  this._bindSubVmAfterInitialized(subVm, target);
		}
		
		/**
		 * Generate element from template and attach to the dest if needed.
		 * The time to attach depends on whether the mode status is node or tree.
		 *
		 * @param {object} template
		 * @param {object} dest
		 * @param {string} type
		 */
		function _compileNativeComponent(template, dest, type) {
		
		  this._applyNaitveComponentOptions(template);
		
		  var element = void 0;
		  if (dest.ref === '_documentElement') {
		    // if its parent is documentElement then it's a body
		    element = this._createBody(type);
		  } else {
		    element = this._createElement(type);
		  }
		  // TODO it was a root element when not in a fragment
		  if (!this._rootEl) {
		    this._rootEl = element;
		  }
		
		  this._bindElement(element, template);
		
		  if (template.attr && template.attr.append) {
		    // backward, append prop in attr
		    template.append = template.attr.append;
		  }
		
		  if (template.append) {
		    // give the append attribute for ios adaptation
		    element.attr = element.attr || {};
		    element.attr.append = template.append;
		  }
		
		  var treeMode = template.append === 'tree';
		  if (!treeMode) {
		    this._attachTarget(element, dest);
		  }
		  this._compileChildren(template, element);
		  if (treeMode) {
		    this._attachTarget(element, dest);
		  }
		}
		
		/**
		 * Set all children to a certain parent element.
		 *
		 * @param {object} template
		 * @param {object} dest
		 */
		function _compileChildren(template, dest) {
		  var _this3 = this;
		
		  var children = template.children;
		  if (children && children.length) {
		    children.forEach(function (child) {
		      _this3._compile(child, dest);
		    });
		  }
		}
		
		/**
		 * Watch the list update and refresh the changes.
		 *
		 * @param {object} target
		 * @param {object} fragBlock {vms, data, children}
		 * @param {object} info      {getter, key, value, trackBy, oldStyle}
		 */
		function _bindRepeat(target, fragBlock, info) {
		  var _this4 = this;
		
		  var vms = fragBlock.vms;
		  var children = fragBlock.children;
		  var getter = info.getter;
		  var trackBy = info.trackBy;
		  var oldStyle = info.oldStyle;
		
		  var keyName = info.key;
		  var valueName = info.value;
		
		  function compileItem(item, index, context) {
		    var mergedData = void 0;
		    if (oldStyle) {
		      mergedData = item;
		      if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
		        mergedData[keyName] = index;
		        if (!mergedData.hasOwnProperty('INDEX')) {
		          Object.defineProperty(mergedData, 'INDEX', {
		            value: function value() {
		              nativeLog('[WARNING] "INDEX" in repeat is deprecated,' + ' please use "$index" instead');
		            }
		          });
		        }
		      }
		    } else {
		      mergedData = {};
		      mergedData[keyName] = index;
		      mergedData[valueName] = item;
		    }
		    context = context._mergeContext(mergedData);
		    // console.log(context)
		    vms.push(context);
		    context._compile(target, fragBlock, { repeat: item });
		  }
		
		  function diffItem(vm, item) {
		    var oldItem = vm._data;
		    var oldKeys = [];
		    for (var key in oldItem) {
		      if (!item.hasOwnProperty(key)) {
		        vm[key] = undefined;
		      }
		    }
		    for (var _key in item) {
		      vm[_key] = item[_key];
		    }
		  }
		
		  function setItemValue(item, index, vm) {
		    var mergedData = void 0;
		    if (oldStyle) {
		      if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
		        diffItem(vm, item);
		        vm.INDEX = index;
		      }
		    } else {
		      vm[keyName] = index;
		      vm[valueName] = item;
		    }
		  }
		
		  var list = this._watchBlock(fragBlock, getter, 'repeat', function (data) {
		    if (!fragBlock) {
		      return;
		    }
		
		    var oldChildren = children.slice();
		    var oldVms = vms.slice();
		    var oldData = fragBlock.data.slice();
		    // 1. collect all new refs track by
		    var trackMap = {};
		    var reusedMap = {};
		    data.forEach(function (item, index) {
		      var key = trackBy ? item[trackBy] : index;
		      /* istanbul ignore if */
		      if (key == null || key === '') {
		        return;
		      }
		      trackMap[key] = item;
		    });
		
		    // 2. remove unused element foreach old item
		    var reusedList = [];
		    oldData.forEach(function (item, index) {
		      var key = trackBy ? item[trackBy] : index;
		      if (trackMap.hasOwnProperty(key)) {
		        reusedMap[key] = {
		          item: item, index: index, key: key,
		          target: oldChildren[index],
		          vm: oldVms[index]
		        };
		        reusedList.push(item);
		      } else {
		        _this4._removeTarget(oldChildren[index]);
		      }
		    });
		
		    // 3. create new element foreach new item
		    children.length = 0;
		    vms.length = 0;
		    fragBlock.data = data.slice();
		    fragBlock.updateMark = fragBlock.start;
		
		    data.forEach(function (item, index) {
		      var key = trackBy ? item[trackBy] : index;
		      var reused = reusedMap[key];
		      if (reused) {
		        if (reused.item === reusedList[0]) {
		          reusedList.shift();
		        } else {
		          reusedList.$remove(reused.item);
		          _this4._moveTarget(reused.target, fragBlock.updateMark, true);
		        }
		        children.push(reused.target);
		        vms.push(reused.vm);
		        reused.vm[keyName] = index;
		        fragBlock.updateMark = reused.target;
		      } else {
		        compileItem(item, index, _this4);
		      }
		    });
		
		    delete fragBlock.updateMark;
		  });
		
		  fragBlock.data = list.slice(0);
		  list.forEach(function (item, index) {
		    compileItem(item, index, _this4);
		  });
		}
		
		/**
		 * Watch the display update and add/remove the element.
		 *
		 * @param  {object} target
		 * @param  {object} fragBlock
		 * @param  {object} context
		 */
		function _bindShown(target, fragBlock, meta) {
		  var _this5 = this;
		
		  var display = this._watchBlock(fragBlock, target.shown, 'shown', function (display) {
		    if (!fragBlock || !!fragBlock.display === !!display) {
		      return;
		    }
		    fragBlock.display = !!display;
		    if (display) {
		      _this5._compile(target, fragBlock, meta);
		    } else {
		      _this5._removeBlock(fragBlock, true);
		    }
		  });
		
		  fragBlock.display = !!display;
		  if (display) {
		    this._compile(target, fragBlock, meta);
		  }
		}
		
		/**
		 * Watch calc value changes and append certain type action to differ.
		 * It is used for if or repeat data-binding generator.
		 *
		 * @param  {object}   fragBlock
		 * @param  {function} calc
		 * @param  {string}   type
		 * @param  {function} handler
		 * @return {any}      init value of calc
		 */
		function _watchBlock(fragBlock, calc, type, handler) {
		  var differ = this && this._app && this._app.differ;
		  var config = {};
		  var depth = (fragBlock.element.depth || 0) + 1;
		
		  return this._watch(calc, function (value) {
		    config.latestValue = value;
		    if (differ && !config.recorded) {
		      differ.append(type, depth, fragBlock.blockId, function () {
		        var latestValue = config.latestValue;
		        handler(latestValue);
		        config.recorded = false;
		        config.latestValue = undefined;
		      });
		    }
		    config.recorded = true;
		  });
		}
		
		/**
		 * Clone a context and merge certain data.
		 *
		 * @param  {object} mergedData
		 * @return {object}
		 */
		function _mergeContext(mergedData) {
		  var context = Object.create(this);
		  context._data = mergedData;
		  context._initData();
		  context._realParent = this;
		  return context;
		}
	
	/***/ },
	/* 94 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; }; /**
		                                                                                                                                                                                                                                                   * @fileOverview
		                                                                                                                                                                                                                                                   * Directive Parser
		                                                                                                                                                                                                                                                   */
		
		exports._applyNaitveComponentOptions = _applyNaitveComponentOptions;
		exports._bindElement = _bindElement;
		exports._bindSubVm = _bindSubVm;
		exports._bindSubVmAfterInitialized = _bindSubVmAfterInitialized;
		exports._setId = _setId;
		exports._setAttr = _setAttr;
		exports._setClass = _setClass;
		exports._setStyle = _setStyle;
		exports._setEvent = _setEvent;
		exports._bindEvents = _bindEvents;
		exports._bindDir = _bindDir;
		exports._bindKey = _bindKey;
		exports._watch = _watch;
		
		var _util = __webpack_require__(81);
		
		var _watcher = __webpack_require__(95);
		
		var _watcher2 = _interopRequireDefault(_watcher);
		
		var _config = __webpack_require__(79);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		var SETTERS = {
		  attr: 'setAttr',
		  style: 'setStyle',
		  event: 'addEvent'
		};
		
		/**
		 * apply the native component's options(specified by template.type)
		 * to the template
		 */
		function _applyNaitveComponentOptions(template) {
		  var type = template.type;
		
		  var options = _config.nativeComponentMap[type];
		
		  if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
		    (0, _util.extend)(template, options);
		  }
		}
		
		/**
		 * bind all id, attr, classnames, style, events to an element
		 */
		function _bindElement(el, template) {
		  this._setId(template.id, el, this);
		  this._setAttr(el, template.attr);
		  this._setClass(el, template.classList);
		  this._setStyle(el, template.style);
		  this._bindEvents(el, template.events);
		}
		
		/**
		 * bind all props to sub vm and bind all style, events to the root element
		 * of the sub vm if it doesn't have a replaced multi-node fragment
		 */
		function _bindSubVm(subVm, template, repeatItem) {
		  subVm = subVm || {};
		  template = template || {};
		
		  var options = subVm._options || {};
		
		  // bind props
		  var props = options.props;
		
		  if (Array.isArray(props)) {
		    props = props.reduce(function (result, value) {
		      result[value] = true;
		      return result;
		    }, {});
		  }
		
		  mergeProps(repeatItem, props, this, subVm);
		  mergeProps(template.attr, props, this, subVm);
		}
		
		function _bindSubVmAfterInitialized(subVm, template) {
		  mergeClassStyle(template.classList, this, subVm);
		  mergeStyle(template.style, this, subVm);
		  mergeEvent(template.events, this, subVm);
		}
		
		function mergeProps(target, props, vm, subVm) {
		  if (!target) {
		    return;
		  }
		
		  var _loop = function _loop(key) {
		    if (!props || props[key]) {
		      var value = target[key];
		      if (typeof value === 'function') {
		        var returnValue = vm._watch(value, function (v) {
		          subVm[key] = v;
		        });
		        subVm[key] = returnValue;
		      } else {
		        subVm[key] = value;
		      }
		    }
		  };
		
		  for (var key in target) {
		    _loop(key);
		  }
		}
		
		function mergeStyle(target, vm, subVm) {
		  var _loop2 = function _loop2(key) {
		    var value = target[key];
		    if (typeof value === 'function') {
		      var returnValue = vm._watch(value, function (v) {
		        if (subVm._rootEl) {
		          subVm._rootEl.setStyle(key, v);
		        }
		      });
		      subVm._rootEl.setStyle(key, returnValue);
		    } else {
		      if (subVm._rootEl) {
		        subVm._rootEl.setStyle(key, value);
		      }
		    }
		  };
		
		  for (var key in target) {
		    _loop2(key);
		  }
		}
		
		function mergeClassStyle(target, vm, subVm) {
		  var css = vm._options && vm._options.style || {};
		
		  if (!subVm._rootEl) {
		    return;
		  }
		
		  if (typeof target === 'function') {
		    var _value = vm._watch(target, function (v) {
		      setClassStyle(subVm._rootEl, css, v);
		    });
		    setClassStyle(subVm._rootEl, css, _value);
		  } else if (target) {
		    setClassStyle(subVm._rootEl, css, target);
		  }
		}
		
		function mergeEvent(target, vm, subVm) {
		  if (target && subVm._rootEl) {
		    for (var type in target) {
		      var handler = vm[target[type]];
		      if (handler) {
		        subVm._rootEl.addEvent(type, (0, _util.bind)(handler, vm));
		      }
		    }
		  }
		}
		
		/**
		 * bind id to an element
		 * each id is unique in a whole vm
		 */
		function _setId(id, el, vm) {
		  var _this = this;
		
		  var map = Object.create(null);
		
		  Object.defineProperties(map, {
		    vm: {
		      value: vm,
		      writable: false,
		      configurable: false
		    },
		    el: {
		      get: function get() {
		        return el || vm._rootEl;
		      },
		      configurable: false
		    }
		  });
		
		  if (typeof id === 'function') {
		    var handler = id;
		    id = handler.call(this);
		    if (id) {
		      this._ids[id] = map;
		    }
		    this._watch(handler, function (newId) {
		      if (newId) {
		        _this._ids[newId] = map;
		      }
		    });
		  } else if (id && typeof id === 'string') {
		    this._ids[id] = map;
		  }
		}
		
		/**
		 * bind attr to an element
		 */
		function _setAttr(el, attr) {
		  this._bindDir(el, 'attr', attr);
		}
		
		function setClassStyle(el, css, classList) {
		  var classStyle = {};
		  var length = classList.length;
		
		  for (var i = 0; i < length; i++) {
		    var style = css[classList[i]];
		    if (style) {
		      for (var key in style) {
		        classStyle[key] = style[key];
		      }
		    }
		  }
		  el.setClassStyle(classStyle);
		}
		
		/**
		 * bind classnames to an element
		 */
		function _setClass(el, classList) {
		
		  if (typeof classList !== 'function' && !Array.isArray(classList)) {
		    return;
		  }
		  if (Array.isArray(classList) && !classList.length) {
		    el.setClassStyle({});
		    return;
		  }
		
		  var style = this._options && this._options.style || {};
		  if (typeof classList === 'function') {
		    var _value2 = this._watch(classList, function (v) {
		      setClassStyle(el, style, v);
		    });
		    setClassStyle(el, style, _value2);
		  } else {
		    setClassStyle(el, style, classList);
		  }
		}
		
		/**
		 * bind style to an element
		 */
		function _setStyle(el, style) {
		  this._bindDir(el, 'style', style);
		}
		
		/**
		 * add an event type and handler to an element and generate a dom update
		 */
		function _setEvent(el, type, handler) {
		  el.addEvent(type, (0, _util.bind)(handler, this));
		}
		
		/**
		 * add all events of an element
		 */
		function _bindEvents(el, events) {
		  if (!events) {
		    return;
		  }
		  var keys = Object.keys(events);
		  var i = keys.length;
		  while (i--) {
		    var key = keys[i];
		    var handler = events[key];
		    if (typeof handler === 'string') {
		      handler = this[handler];
		    }
		    this._setEvent(el, key, handler);
		  }
		}
		
		/**
		 * set a series of members as a kind of an element
		 * for example: style, attr, ...
		 * if the value is a function then bind the data changes
		 */
		function _bindDir(el, name, data) {
		  if (!data) {
		    return;
		  }
		  var keys = Object.keys(data);
		  var i = keys.length;
		  while (i--) {
		    var key = keys[i];
		    var _value3 = data[key];
		    if (typeof _value3 === 'function') {
		      var update = _value3;
		      this._bindKey(el, name, key, update);
		    } else {
		      el[SETTERS[name]](key, _value3);
		    }
		  }
		}
		
		/**
		 * bind data changes to a certain key to a name series in an element
		 */
		function _bindKey(el, name, key, calc) {
		  var _this2 = this;
		
		  var methodName = SETTERS[name];
		  var obj = el[name];
		  // watch the calc, and returns a value by calc.call()
		  var value = this._watch(calc, function (value) {
		    function handler() {
		      el[methodName](key, value);
		    }
		    var differ = _this2 && _this2._app && _this2._app.differ;
		    if (differ) {
		      differ.append('element', el.depth, el.ref, handler);
		    } else {
		      handler();
		    }
		  });
		
		  el[methodName](key, value);
		}
		
		/**
		 * watch a calc function and callback if the calc value changes
		 */
		function _watch(calc, callback) {
		  var watcher = new _watcher2.default(this, calc, function (value, oldValue) {
		    /* istanbul ignore if */
		    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' && value === oldValue) {
		      return;
		    }
		    callback(value);
		  });
		
		  return watcher.value;
		}
	
	/***/ },
	/* 95 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		/**
		 * The MIT License (MIT)
		 *
		 * Copyright (c) 2013-2015 Yuxi Evan You
		 *
		 * Permission is hereby granted, free of charge, to any person obtaining a copy
		 * of this software and associated documentation files (the "Software"), to deal
		 * in the Software without restriction, including without limitation the rights
		 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
		 * copies of the Software, and to permit persons to whom the Software is
		 * furnished to do so, subject to the following conditions:
		 *
		 * The above copyright notice and this permission notice shall be included in
		 * all copies or substantial portions of the Software.
		 *
		 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
		 * THE SOFTWARE.
		 */
		
		var _ = __webpack_require__(87);
		// var config = require('./config')
		var Observer = __webpack_require__(88);
		// var expParser = require('./parsers/expression')
		// var batcher = require('./batcher')
		var uid = 0;
		
		/**
		 * A watcher parses an expression, collects dependencies,
		 * and fires callback when the expression value changes.
		 * This is used for both the $watch() api and directives.
		 *
		 * @param {Vue} vm
		 * @param {String} expression
		 * @param {Function} cb
		 * @param {Object} options
		 *                 - {Array} filters
		 *                 - {Boolean} twoWay
		 *                 - {Boolean} deep
		 *                 - {Boolean} user
		 *                 - {Function} [preProcess]
		 * @constructor
		 */
		
		// function Watcher (vm, expression, cb, options) {
		function Watcher(vm, update, cb) {
		  this.vm = vm;
		  vm._watchers.push(this);
		  // this.expression = expression
		  this.cb = cb;
		  this.id = ++uid; // uid for batching
		  this.active = true;
		  // options = options || {}
		  // this.deep = !!options.deep
		  // this.user = !!options.user
		  // this.twoWay = !!options.twoWay
		  // this.filters = options.filters
		  // this.preProcess = options.preProcess
		  this.deps = [];
		  this.newDeps = [];
		  // parse expression for getter/setter
		  // var res = expParser.parse(expression, options.twoWay)
		  // this.getter = res.get
		  // this.setter = res.set
		  this.getter = update;
		  this.value = this.get();
		}
		
		var p = Watcher.prototype;
		
		/**
		 * Add a dependency to this directive.
		 *
		 * @param {Dep} dep
		 */
		
		p.addDep = function (dep) {
		  var newDeps = this.newDeps;
		  var old = this.deps;
		  if (_.indexOf(newDeps, dep) < 0) {
		    newDeps.push(dep);
		    var i = _.indexOf(old, dep);
		    if (i < 0) {
		      dep.addSub(this);
		    } else {
		      old[i] = null;
		    }
		  }
		};
		
		/**
		 * Evaluate the getter, and re-collect dependencies.
		 */
		
		p.get = function () {
		  this.beforeGet();
		  var vm = this.vm;
		  var value;
		  try {
		    value = this.getter.call(vm, vm);
		  } catch (e) {
		    // if (config.warnExpressionErrors) {
		    //   _.warn(
		    //     'Error when evaluating expression "' +
		    //     this.expression + '":\n   ' + e
		    //   )
		    // }
		    _.warn('Error when update"');
		  }
		  // "touch" every property so they are all tracked as
		  // dependencies for deep watching
		  if (this.deep) {
		    traverse(value);
		  }
		  if (this.preProcess) {
		    value = this.preProcess(value);
		  }
		  if (this.filters) {
		    value = vm._applyFilters(value, null, this.filters, false);
		  }
		  this.afterGet();
		  return value;
		};
		
		// /**
		//  * Set the corresponding value with the setter.
		//  *
		//  * @param {*} value
		//  */
		
		// p.set = function (value) {
		//   var vm = this.vm
		//   if (this.filters) {
		//     value = vm._applyFilters(
		//       value, this.value, this.filters, true)
		//   }
		//   try {
		//     this.setter.call(vm, vm, value)
		//   } catch (e) {
		//     // if (config.warnExpressionErrors) {
		//       _.warn(
		//         'Error when evaluating setter "' +
		//         this.expression + '":\n   ' + e
		//       )
		//     // }
		//   }
		// }
		
		/**
		 * Prepare for dependency collection.
		 */
		
		p.beforeGet = function () {
		  Observer.target = this;
		};
		
		/**
		 * Clean up for dependency collection.
		 */
		
		p.afterGet = function () {
		  Observer.target = null;
		  var i = this.deps.length;
		  while (i--) {
		    var dep = this.deps[i];
		    if (dep) {
		      dep.removeSub(this);
		    }
		  }
		  this.deps = this.newDeps;
		  this.newDeps = [];
		};
		
		/**
		 * Subscriber interface.
		 * Will be called when a dependency changes.
		 */
		
		// p.update = function () {
		//   if (!config.async || config.debug) {
		//     this.run()
		//   } else {
		//     batcher.push(this)
		//   }
		// }
		
		// /**
		//  * Batcher job interface.
		//  * Will be called by the batcher.
		//  */
		
		// p.run = function () {
		p.update = function () {
		  if (this.active) {
		    var value = this.get();
		    if (value !== this.value || Array.isArray(value) || this.deep) {
		      var oldValue = this.value;
		      this.value = value;
		      this.cb(value, oldValue);
		    }
		  }
		};
		
		/**
		 * Remove self from all dependencies' subcriber list.
		 */
		
		p.teardown = function () {
		  if (this.active) {
		    // remove self from vm's watcher list
		    // we can skip this if the vm if being destroyed
		    // which can improve teardown performance.
		    if (!this.vm._isBeingDestroyed) {
		      this.vm._watchers.$remove(this);
		    }
		    var i = this.deps.length;
		    while (i--) {
		      this.deps[i].removeSub(this);
		    }
		    this.active = false;
		    this.vm = this.cb = this.value = null;
		  }
		};
		
		/**
		 * Recrusively traverse an object to evoke all converted
		 * getters, so that every nested property inside the object
		 * is collected as a "deep" dependency.
		 *
		 * @param {Object} obj
		 */
		
		function traverse(obj) {
		  var key, val, i;
		  for (key in obj) {
		    val = obj[key];
		    if (_.isArray(val)) {
		      i = val.length;
		      while (i--) {
		        traverse(val[i]);
		      }
		    } else if (_.isObject(val)) {
		      traverse(val);
		    }
		  }
		}
		
		module.exports = Watcher;
	
	/***/ },
	/* 96 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports._createBody = _createBody;
		exports._createElement = _createElement;
		exports._createBlock = _createBlock;
		exports._createBlockStart = _createBlockStart;
		exports._createBlockEnd = _createBlockEnd;
		exports._attachTarget = _attachTarget;
		exports._moveTarget = _moveTarget;
		exports._moveElement = _moveElement;
		exports._moveBlock = _moveBlock;
		exports._removeTarget = _removeTarget;
		exports._removeElement = _removeElement;
		exports._removeBlock = _removeBlock;
		/**
		 * @fileOverview Document & Element Helpers.
		 *
		 * required:
		 * Document#: createElement, createComment, getRef
		 * Element#: appendChild, insertBefore, removeChild, nextSibling
		 */
		
		/**
		 * Create a body by type
		 * Using this._app.doc
		 *
		 * @param  {string} type
		 */
		function _createBody(type) {
		  var doc = this._app.doc;
		  return doc.createBody(type);
		}
		
		/**
		 * Create an element by type
		 * Using this._app.doc
		 *
		 * @param  {string} type
		 */
		function _createElement(type) {
		  var doc = this._app.doc;
		  return doc.createElement(type);
		}
		
		/**
		 * Create and return a frag block for an element.
		 * The frag block has a starter, ender and the element itself.
		 *
		 * @param  {object} element
		 */
		function _createBlock(element) {
		  var start = this._createBlockStart();
		  var end = this._createBlockEnd();
		  var blockId = lastestBlockId++;
		  if (element.element) {
		    element.element.insertBefore(start, element.end);
		    element.element.insertBefore(end, element.end);
		    element = element.element;
		  } else {
		    element.appendChild(start);
		    element.appendChild(end);
		  }
		  return { start: start, end: end, element: element, blockId: blockId };
		}
		
		var lastestBlockId = 1;
		
		/**
		 * Create and return a block starter.
		 * Using this._app.doc
		 */
		function _createBlockStart() {
		  var doc = this._app.doc;
		  var anchor = doc.createComment('start');
		  return anchor;
		}
		
		/**
		 * Create and return a block ender.
		 * Using this._app.doc
		 */
		function _createBlockEnd() {
		  var doc = this._app.doc;
		  var anchor = doc.createComment('end');
		  return anchor;
		}
		
		/**
		 * Attach target to a certain dest using appendChild by default.
		 * If the dest is a frag block then insert before the ender.
		 * If the target is a frag block then attach the starter and ender in order.
		 *
		 * @param  {object} target
		 * @param  {object} dest
		 */
		function _attachTarget(target, dest) {
		
		  if (dest.element) {
		    var before = dest.end;
		    var after = dest.updateMark;
		    // push new target for watch list update later
		    if (dest.children) {
		      dest.children.push(target);
		    }
		    // for check repeat case
		    if (after) {
		      this._moveTarget(target, after);
		      dest.updateMark = target.element ? target.end : target;
		    } else if (target.element) {
		      dest.element.insertBefore(target.start, before);
		      dest.element.insertBefore(target.end, before);
		    } else {
		      dest.element.insertBefore(target, before);
		    }
		  } else {
		    if (target.element) {
		      dest.appendChild(target.start);
		      dest.appendChild(target.end);
		    } else {
		      dest.appendChild(target);
		    }
		  }
		}
		
		/**
		 * Move target before a certain element. The target maybe block or element.
		 *
		 * @param  {object} target
		 * @param  {object} before
		 */
		function _moveTarget(target, after) {
		  if (target.element) {
		    this._moveBlock(target, after);
		  } else {
		    this._moveElement(target, after);
		  }
		}
		
		/**
		 * Move element before a certain element.
		 *
		 * @param  {object} element
		 * @param  {object} before
		 */
		function _moveElement(element, after) {
		  var doc = this._app.doc;
		  var parent = doc.getRef(after.parentRef);
		
		  if (parent) {
		    parent.insertAfter(element, after);
		  }
		}
		
		/**
		 * Move all elements of the block before a certain element.
		 *
		 * @param  {object} fragBlock
		 * @param  {object} before
		 */
		function _moveBlock(fragBlock, after) {
		  var doc = this._app.doc;
		  var parent = doc.getRef(after.parentRef);
		
		  if (parent) {
		    (function () {
		      var el = fragBlock.start;
		      var group = [el];
		
		      while (el && el !== fragBlock.end) {
		        el = el.next();
		        group.push(el);
		      }
		
		      var temp = after;
		      group.forEach(function (el) {
		        parent.insertAfter(el, temp);
		        temp = el;
		      });
		    })();
		  }
		}
		
		/**
		 * Remove target from DOM tree.
		 * If the target is a frag block then call _removeBlock
		 *
		 * @param  {object} target
		 */
		function _removeTarget(target) {
		
		  if (target.element) {
		    this._removeBlock(target);
		  } else {
		    this._removeElement(target);
		  }
		}
		
		/**
		 * Remove a certain element.
		 * Using this._app.doc
		 *
		 * @param  {object} target
		 */
		function _removeElement(target) {
		  var doc = this._app.doc;
		  var parent = doc.getRef(target.parentRef);
		
		  if (parent) {
		    parent.removeChild(target);
		  }
		}
		
		/**
		 * Remove a frag block.
		 * The second param decides whether the block self should be removed too.
		 *
		 * @param  {object}  fragBlock
		 * @param  {Boolean} preserveBlock=false
		 */
		function _removeBlock(fragBlock) {
		  var _this = this;
		
		  var preserveBlock = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
		
		  var result = [];
		  var el = fragBlock.start.next();
		
		  while (el && el !== fragBlock.end) {
		    result.push(el);
		    el = el.next();
		  }
		
		  if (!preserveBlock) {
		    this._removeElement(fragBlock.start);
		  }
		  result.forEach(function (el) {
		    _this._removeElement(el);
		  });
		  if (!preserveBlock) {
		    this._removeElement(fragBlock.end);
		  }
		}
	
	/***/ },
	/* 97 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.$emit = $emit;
		exports.$dispatch = $dispatch;
		exports.$broadcast = $broadcast;
		exports.$on = $on;
		exports.$off = $off;
		exports._initEvents = _initEvents;
		function Evt(type, detail) {
		  if (detail instanceof Evt) {
		    return detail;
		  }
		
		  this.timestamp = Date.now();
		  this.detail = detail;
		  this.type = type;
		
		  var shouldStop = false;
		  this.stop = function () {
		    shouldStop = true;
		  };
		  this.hasStopped = function () {
		    return shouldStop;
		  };
		}
		
		function $emit(type, detail) {
		  var _this = this;
		
		  var events = this._vmEvents;
		  var handlerList = events[type];
		  if (handlerList) {
		    (function () {
		      var evt = new Evt(type, detail);
		      handlerList.forEach(function (handler) {
		        handler.call(_this, evt);
		      });
		    })();
		  }
		}
		
		function $dispatch(type, detail) {
		  var evt = new Evt(type, detail);
		  this.$emit(type, evt);
		
		  if (!evt.hasStopped() && this._parent && this._parent.$dispatch) {
		    this._parent.$dispatch(type, evt);
		  }
		}
		
		function $broadcast(type, detail) {
		  var evt = new Evt(type, detail);
		  this.$emit(type, evt);
		
		  if (!evt.hasStopped() && this._childrenVms) {
		    this._childrenVms.forEach(function (subVm) {
		      subVm.$broadcast(type, evt);
		    });
		  }
		}
		
		function $on(type, handler) {
		  if (!type || typeof handler !== 'function') {
		    return;
		  }
		  var events = this._vmEvents;
		  var handlerList = events[type] || [];
		  handlerList.push(handler);
		  events[type] = handlerList;
		
		  // fixed old version lifecycle design
		  if (type === 'hook:ready' && this._ready) {
		    this.$emit('hook:ready');
		  }
		}
		
		function $off(type, handler) {
		  if (!type) {
		    return;
		  }
		  var events = this._vmEvents;
		  if (!handler) {
		    delete events[type];
		    return;
		  }
		  var handlerList = events[type];
		  if (!handlerList) {
		    return;
		  }
		  handlerList.$remove(handler);
		}
		
		var LIFE_CYCLE_TYPES = ['init', 'created', 'ready'];
		
		function _initEvents(externalEvents) {
		  var _this2 = this;
		
		  var options = this._options || {};
		  var events = options.events || {};
		  for (var type1 in events) {
		    this.$on(type1, events[type1]);
		  }
		  for (var type2 in externalEvents) {
		    this.$on(type2, externalEvents[type2]);
		  }
		  LIFE_CYCLE_TYPES.forEach(function (type) {
		    _this2.$on('hook:' + type, options[type]);
		  });
		}
	
	/***/ },
	/* 98 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.clearModules = clearModules;
		exports.getModule = getModule;
		exports.requireModule = requireModule;
		exports.registerModules = registerModules;
		exports.registerMethods = registerMethods;
		exports.requireComponent = requireComponent;
		exports.registerComponent = registerComponent;
		var nativeModules = {};
		
		function assignModules(modules, ifReplace) {
		  var _loop = function _loop(moduleName) {
		
		    // init `modules[moduleName][]`
		    var methods = nativeModules[moduleName];
		    if (!methods) {
		      methods = {};
		      nativeModules[moduleName] = methods;
		    }
		
		    // push each non-existed new method
		    modules[moduleName].forEach(function (method) {
		      if (typeof method === 'string') {
		        method = {
		          name: method
		        };
		      }
		
		      if (!methods[method.name] || ifReplace) {
		        methods[method.name] = method;
		      }
		    });
		  };
		
		  for (var moduleName in modules) {
		    _loop(moduleName);
		  }
		}
		
		function assignApis(Ctor, apis) {
		  var p = Ctor.prototype;
		
		  for (var apiName in apis) {
		    if (!p.hasOwnProperty(apiName)) {
		      p[apiName] = apis[apiName];
		    }
		  }
		}
		
		function clearModules() {
		  nativeModules = {};
		}
		
		function getModule(moduleName) {
		  return nativeModules[moduleName];
		}
		
		/**
		 * @context a instance of AppInstance
		 */
		function requireModule(moduleName) {
		  var _this = this;
		
		  var methods = nativeModules[moduleName];
		  var target = {};
		
		  var _loop2 = function _loop2(methodName) {
		    target[methodName] = function () {
		      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		        args[_key] = arguments[_key];
		      }
		
		      return _this.callTasks({
		        module: moduleName,
		        method: methodName,
		        args: args
		      });
		    };
		  };
		
		  for (var methodName in methods) {
		    _loop2(methodName);
		  }
		
		  return target;
		}
		
		/**
		 * @context Vm
		 */
		function registerModules(modules, ifReplace) {
		  assignModules(modules, ifReplace);
		}
		
		/**
		 * @context Vm
		 */
		function registerMethods(apis) {
		  assignApis(this, apis);
		}
		
		/**
		 * @context a instance of AppInstance
		 */
		function requireComponent(name) {
		  var customComponentMap = this.customComponentMap;
		
		  return customComponentMap[name];
		}
		
		/**
		 * @context a instance of AppInstance
		 */
		function registerComponent(name, exports) {
		  var customComponentMap = this.customComponentMap;
		
		
		  if (customComponentMap[name]) {
		    throw new Error('define a component(' + name + ') that already exists');
		  }
		
		  customComponentMap[name] = exports;
		}
	
	/***/ },
	/* 99 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(global) {'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.normalizeVersion = normalizeVersion;
		exports.getError = getError;
		exports.check = check;
		
		var _semver = __webpack_require__(83);
		
		var _semver2 = _interopRequireDefault(_semver);
		
		var _util = __webpack_require__(81);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		/**
		 * [normalizeVersion description]
		 * @param  {String} Version. ie: 1, 1.0, 1.0.0
		 * @return {String} Version
		 */
		function normalizeVersion(v) {
		  var isValid = _semver2.default.valid(v) ? true : false;
		  if (isValid) {
		    return v;
		  }
		
		  v = typeof v === 'string' ? v : '';
		  var split = v.split('.');
		  var i = 0;
		  var result = [];
		
		  while (i < 3) {
		    var s = typeof split[i] === 'string' && split[i] ? split[i] : '0';
		    result.push(s);
		    i++;
		  }
		
		  return result.join('.');
		}
		
		function getError(key, val, criteria) {
		  var result = {
		    isDowngrade: true,
		    errorType: 1,
		    code: 1000
		  };
		  var getMsg = function getMsg(key, val, criteria) {
		    return 'Downgrade[' + key + '] :: deviceInfo ' + val + ' matched criteria ' + criteria;
		  };
		  var _key = key.toLowerCase();
		
		  result.errorMessage = getMsg(key, val, criteria);
		
		  if (_key.indexOf('osversion') >= 0) {
		    result.code = 1001;
		  } else if (_key.indexOf('appversion') >= 0) {
		    result.code = 1002;
		  } else if (_key.indexOf('weexversion') >= 0) {
		    result.code = 1003;
		  } else if (_key.indexOf('devicemodel') >= 0) {
		    result.code = 1004;
		  }
		
		  return result;
		}
		
		/**
		 * WEEX framework input(deviceInfo)
		 * {
		 *   platform: 'iOS' or 'android'
		 *   osVersion: '1.0.0' or '1.0' or '1'
		 *   appVersion: '1.0.0' or '1.0' or '1'
		 *   weexVersion: '1.0.0' or '1.0' or '1'
		 *   dDeviceModel: 'MODEL_NAME'
		 * }
		 *
		 * downgrade config(config)
		 * {
		 *   ios: {
		 *     osVersion: '>1.0.0' or '>=1.0.0' or '<1.0.0' or '<=1.0.0' or '1.0.0'
		 *     appVersion: '>1.0.0' or '>=1.0.0' or '<1.0.0' or '<=1.0.0' or '1.0.0'
		 *     weexVersion: '>1.0.0' or '>=1.0.0' or '<1.0.0' or '<=1.0.0' or '1.0.0'
		 *     deviceModel: ['modelA', 'modelB', ...]
		 *   },
		 *   android: {
		 *     osVersion: '>1.0.0' or '>=1.0.0' or '<1.0.0' or '<=1.0.0' or '1.0.0'
		 *     appVersion: '>1.0.0' or '>=1.0.0' or '<1.0.0' or '<=1.0.0' or '1.0.0'
		 *     weexVersion: '>1.0.0' or '>=1.0.0' or '<1.0.0' or '<=1.0.0' or '1.0.0'
		 *     deviceModel: ['modelA', 'modelB', ...]
		 *   }
		 * }
		 *
		 *
		 * @param  {object} deviceInfo Weex SDK framework input
		 * @param  {object} config     user input
		 * @return {Object}            { isDowngrade: true/false, errorMessage... }
		 */
		function check(config, deviceInfo) {
		  deviceInfo = deviceInfo || global.WXEnvironment;
		  deviceInfo = (0, _util.isPlainObject)(deviceInfo) ? deviceInfo : {};
		  config = (0, _util.isPlainObject)(config) ? config : {};
		  var platform = deviceInfo.platform || 'unknow';
		  var dPlatform = platform.toLowerCase();
		  var cObj = config[dPlatform] || {};
		
		  var result = {
		    isDowngrade: false // defautl is pass
		  };
		
		  for (var i in deviceInfo) {
		    var key = i;
		    var keyLower = key.toLowerCase();
		    var val = deviceInfo[i];
		    var isVersion = keyLower.indexOf('version') >= 0 ? true : false;
		    var isDeviceModel = keyLower.indexOf('devicemodel') >= 0 ? true : false;
		    var criteria = cObj[i];
		
		    if (criteria && isVersion) {
		      var c = this.normalizeVersion(criteria);
		      var d = this.normalizeVersion(deviceInfo[i]);
		
		      if (_semver2.default.satisfies(d, c)) {
		        result = (0, _util.extend)(this.getError(key, val, criteria));
		        break;
		      }
		    } else if (isDeviceModel) {
		      var _criteria = (0, _util.typof)(criteria) === 'array' ? criteria : [criteria];
		      if (_criteria.indexOf(val) >= 0) {
		        result = (0, _util.extend)(this.getError(key, val, criteria));
		        break;
		      }
		    }
		  }
		
		  return result;
		}
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 100 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.init = init;
		exports.destroy = destroy;
		exports.getRootElement = getRootElement;
		exports.updateActions = updateActions;
		exports.fireEvent = fireEvent;
		exports.callback = callback;
		exports.refreshData = refreshData;
		
		var _util = __webpack_require__(81);
		
		var _perf = __webpack_require__(77);
		
		var perf = _interopRequireWildcard(_perf);
		
		var _domListener = __webpack_require__(101);
		
		var _domListener2 = _interopRequireDefault(_domListener);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
		
		function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**
		                                                                                                                                                                                                     * @fileOverview
		                                                                                                                                                                                                     * instance controls from native
		                                                                                                                                                                                                     *
		                                                                                                                                                                                                     * - init bundle
		                                                                                                                                                                                                     * - fire event
		                                                                                                                                                                                                     * - callback
		                                                                                                                                                                                                     * - destroy
		                                                                                                                                                                                                     *
		                                                                                                                                                                                                     * corresponded with the API of instance manager (framework.js)
		                                                                                                                                                                                                     */
		
		function init(code, data) {
		  var _this = this;
		
		  var result;
		  // @see: lib/app/bundle.js
		  var define = (0, _util.bind)(this.define, this);
		  var bootstrap = function bootstrap(name, config, _data) {
		    result = _this.bootstrap(name, config, _data || data);
		    _this.updateActions();
		    _this.doc.listener.createFinish();
		    _this.doc.close();
		  };
		
		  // backward(register/render)
		  var register = (0, _util.bind)(this.register, this);
		  var render = function render(name, _data) {
		    result = _this.bootstrap(name, {}, _data);
		  };
		
		  var require = function require(name) {
		    return function (_data) {
		      result = _this.bootstrap(name, {}, _data);
		    };
		  };
		
		  var document = this.doc;
		
		  perf.start('run bundle', this.id);
		
		  var functionBody = void 0;
		  /* istanbul ignore if */
		  if (typeof code === 'function') {
		    // `function () {...}` -> `{...}`
		    // not very strict
		    functionBody = code.toString().substr(12);
		  } else if (code) {
		    functionBody = code.toString();
		  }
		
		  var fn = new Function('define', 'require', 'document', 'bootstrap', 'register', 'render', '__weex_define__', // alias for define
		  '__weex_bootstrap__', // alias for bootstrap
		  functionBody);
		
		  fn(define, require, document, bootstrap, register, render, define, bootstrap);
		
		  perf.end('run bundle', this.id);
		  return result;
		}
		
		function destroy() {
		  this.id = '';
		  this.eventManager = null;
		  this.options = null;
		  this.blocks = null;
		  this.vm = null;
		  this.doc = null;
		  this.customComponentMap = null;
		  this.callbacks = null;
		}
		
		function getRootElement() {
		  var doc = this.doc || {};
		  var body = doc.body || {};
		  return body.toJSON ? body.toJSON() : {};
		}
		
		function updateActions(addonTasks) {
		  this.differ.flush();
		  var tasks = [];
		  if (this.listener && this.listener.updates.length) {
		    tasks.push.apply(tasks, _toConsumableArray(this.listener.updates));
		    this.listener.updates = [];
		  }
		  if (addonTasks && addonTasks.length) {
		    tasks.push.apply(tasks, _toConsumableArray(addonTasks));
		  }
		  if (tasks.length) {
		    this.callTasks(tasks);
		  }
		}
		
		function fireEvent(ref, type, e, domChanges) {
		  var _this2 = this;
		
		  if (Array.isArray(ref)) {
		    ref.some(function (ref) {
		      return _this2.fireEvent(ref, type, e) !== false;
		    });
		    return;
		  }
		
		  var el = this.doc.getRef(ref);
		
		  if (el) {
		    perf.start('manage event', ref + '-' + type);
		    e = e || {};
		    e.type = type;
		    e.target = el;
		    e.timestamp = Date.now();
		    if (domChanges) {
		      updateElement(el, domChanges);
		    }
		    var result = this.eventManager.fire(el, type, e);
		    perf.end('manage event', ref + '-' + type);
		    this.updateActions();
		    return result;
		  }
		
		  return new Error('invalid element reference "' + ref + '"');
		}
		
		function callback(callbackId, data, ifKeepAlive) {
		  var callback = this.callbacks[callbackId];
		
		  if (typeof callback === 'function') {
		    callback(data); // data is already a object, @see: lib/framework.js
		
		    if (typeof ifKeepAlive === 'undefined' || ifKeepAlive === false) {
		      this.callbacks[callbackId] = undefined;
		    }
		
		    this.updateActions();
		    return;
		  }
		
		  return new Error('invalid callback id "' + callbackId + '"');
		}
		
		function refreshData(data) {
		  var vm = this.vm;
		
		  if (vm && data) {
		    if (typeof vm.refreshData === 'function') {
		      vm.refreshData(data);
		    } else {
		      (0, _util.extend)(vm, data);
		    }
		    this.updateActions([(0, _domListener.createAction)('refreshFinish', [])]);
		    return;
		  }
		
		  return new Error('invalid data "' + data + '"');
		}
		
		function updateElement(el, changes) {
		  var attrs = changes.attrs || {};
		  for (var name in attrs) {
		    el.setAttr(name, attrs);
		  }
		  var style = changes.style || {};
		  for (var _name in style) {
		    el.setStyle(_name, style[_name]);
		  }
		}
	
	/***/ },
	/* 101 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.default = Listener;
		exports.createAction = createAction;
		function Listener(id, handler) {
		  this.id = id;
		  this.batched = false;
		  this.updates = [];
		  if (typeof handler === 'function') {
		    this.handler = handler;
		  }
		}
		
		Listener.prototype.createFinish = function (callback) {
		  var handler = this.handler;
		  handler([createAction('createFinish', [])], callback);
		};
		
		Listener.prototype.createBody = function (element, ref) {
		  var actions = [createAction('createBody', [element.toJSON()])];
		  this.addActions(actions);
		};
		
		Listener.prototype.addElement = function (element, ref, index) {
		  if (!(index >= 0)) {
		    index = -1;
		  }
		  this.addActions(createAction('addElement', [ref, element.toJSON(), index]));
		};
		
		Listener.prototype.removeElement = function (ref) {
		  if (Array.isArray(ref)) {
		    var actions = ref.map(function (r) {
		      return createAction('removeElement', [r]);
		    });
		    this.addActions(actions);
		  } else {
		    this.addActions(createAction('removeElement', [ref]));
		  }
		};
		
		Listener.prototype.moveElement = function (targetRef, parentRef, index) {
		  this.addActions(createAction('moveElement', [targetRef, parentRef, index]));
		};
		
		Listener.prototype.setAttr = function (ref, key, value) {
		  var result = {};
		  result[key] = value;
		  this.addActions(createAction('updateAttrs', [ref, result]));
		};
		
		Listener.prototype.setStyle = function (ref, key, value) {
		  var result = {};
		  result[key] = value;
		  this.addActions(createAction('updateStyle', [ref, result]));
		};
		
		Listener.prototype.setStyles = function (ref, style) {
		  this.addActions(createAction('updateStyle', [ref, style]));
		};
		
		Listener.prototype.addEvent = function (ref, type) {
		  this.addActions(createAction('addEvent', [ref, type]));
		};
		
		Listener.prototype.removeEvent = function (ref, type) {
		  this.addActions(createAction('removeEvent', [ref, type]));
		};
		
		Listener.prototype.handler = function (actions, cb) {
		  cb && cb();
		};
		
		Listener.prototype.addActions = function (actions) {
		  var updates = this.updates;
		  var handler = this.handler;
		
		  if (!Array.isArray(actions)) {
		    actions = [actions];
		  }
		
		  if (this.batched) {
		    updates.push.apply(updates, actions);
		  } else {
		    handler(actions);
		  }
		};
		
		function createAction(name, args) {
		  return { module: 'dom', method: name, args: args };
		}
	
	/***/ },
	/* 102 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var Differ = function () {
		  function Differ(id) {
		    _classCallCheck(this, Differ);
		
		    this.id = id;
		    this.map = [];
		    this.hooks = [];
		  }
		
		  _createClass(Differ, [{
		    key: 'isEmpty',
		    value: function isEmpty() {
		      return this.map.length === 0;
		    }
		  }, {
		    key: 'append',
		    value: function append(type, depth, ref, handler) {
		      var map = this.map;
		      if (!map[depth]) {
		        map[depth] = {};
		      }
		      var group = map[depth];
		      if (!group[type]) {
		        group[type] = {};
		      }
		      if (type === 'element') {
		        if (!group[type][ref]) {
		          group[type][ref] = [];
		        }
		        group[type][ref].push(handler);
		      } else {
		        group[type][ref] = handler;
		      }
		    }
		  }, {
		    key: 'flush',
		    value: function flush() {
		      var map = this.map.slice();
		      this.map.length = 0;
		      map.forEach(function (group) {
		        callTypeMap(group, 'repeat');
		        callTypeMap(group, 'shown');
		        callTypeList(group, 'element');
		      });
		
		      var hooks = this.hooks.slice();
		      this.hooks.length = 0;
		      hooks.forEach(function (fn) {
		        fn();
		      });
		
		      if (!this.isEmpty()) {
		        this.flush();
		      }
		    }
		  }, {
		    key: 'then',
		    value: function then(fn) {
		      this.hooks.push(fn);
		    }
		  }]);
		
		  return Differ;
		}();
		
		exports.default = Differ;
		
		
		function callTypeMap(group, type) {
		  var map = group[type];
		  for (var ref in map) {
		    map[ref]();
		  }
		}
		
		function callTypeList(group, type) {
		  var map = group[type];
		  for (var ref in map) {
		    var list = map[ref];
		    list.forEach(function (handler) {
		      handler();
		    });
		  }
		}
	
	/***/ },
	/* 103 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; }; /**
		                                                                                                                                                                                                                                                   * @fileOverview event manager
		                                                                                                                                                                                                                                                   */
		
		exports.default = EventManager;
		
		var _util = __webpack_require__(81);
		
		var _ = _interopRequireWildcard(_util);
		
		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
		
		function EventManager() {
		  this.els = [];
		  this.targets = [];
		}
		
		EventManager.prototype._get = function (el, force) {
		  var index = _.indexOf(this.els, el);
		  var target;
		  if (index >= 0) {
		    target = this.targets[index];
		  } else if (force) {
		    target = { el: el, events: {} };
		    this.els.push(el);
		    this.targets.push(target);
		  }
		  return target;
		};
		
		EventManager.prototype.add = function (el, type, handler) {
		  if ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) !== 'object' || !el || typeof type !== 'string' || !type || typeof handler !== 'function') {
		    return;
		  }
		  var target = this._get(el, true);
		  target.events[type] = handler;
		};
		
		EventManager.prototype.remove = function (el, type) {
		  if ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) !== 'object' || !el || typeof type !== 'string' || !type) {
		    return;
		  }
		  var target = this._get(el);
		  if (target) {
		    delete target.events[type];
		  }
		};
		
		EventManager.prototype.fire = function (el, type, e) {
		  var target = this._get(el);
		  var handler, el;
		  if (target) {
		    el = target.el;
		    handler = target.events[type];
		    if (typeof handler === 'function') {
		      return handler.call(el, e);
		    }
		  }
		};
	
	/***/ },
	/* 104 */
	/***/ function(module, exports) {
	
		'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.Document = Document;
		exports.destroyDocument = destroyDocument;
		exports.Node = Node;
		exports.Element = Element;
		exports.Comment = Comment;
		/**
		 * @fileOverview
		 * A simple virtual dom implementation
		 */
		
		var DEFAULT_TAG_NAME = 'div';
		
		var instanceMap = exports.instanceMap = {};
		
		function Document(id) {
		  id = id ? id.toString() : '';
		  this.id = id;
		  this.nextRef = 1;
		  this.nodeMap = {};
		  this.listener = null;
		  this.eventManager = null;
		  this.closed = false;
		  instanceMap[id] = this;
		
		  this.createDocumentElement();
		}
		
		function destroyDocument(id) {
		  delete instanceMap[id];
		}
		
		Document.prototype.open = function () {
		  this.closed = false;
		  if (this.listener) {
		    this.listener.batched = false;
		  }
		};
		Document.prototype.close = function () {
		  this.closed = true;
		  if (this.listener) {
		    this.listener.batched = true;
		  }
		};
		
		Document.prototype.setEventManager = function (eventManager) {
		  this.eventManager = eventManager;
		};
		
		Document.prototype.setListener = function (listener) {
		  this.listener = listener;
		  listener.batched = !!this.closed;
		};
		
		Document.prototype.addRef = function (el) {
		  el.ref = this.nextRef.toString();
		  this.nodeMap[el.ref] = el;
		  this.nextRef++;
		};
		
		Document.prototype.getRef = function (ref) {
		  return this.nodeMap[ref];
		};
		
		Document.prototype.removeRef = function (ref) {
		  delete this.nodeMap[ref];
		};
		
		Document.prototype.createDocumentElement = function (type, props) {
		  if (!this.documentElement) {
		    this.documentElement = new Element(type, props, this);
		    this.nodeMap._documentElement = this.documentElement;
		    this.documentElement.ref = '_documentElement';
		    this.documentElement.attached = true;
		  }
		
		  return this.documentElement;
		};
		
		Document.prototype.createBody = function (type, props) {
		  if (!this.body) {
		    this.body = new Element(type, props, this);
		    this.nodeMap._root = this.body;
		    this.body.ref = '_root';
		    this.body.depth = 1;
		  }
		
		  return this.body;
		};
		
		Document.prototype.createElement = function (tagName, props) {
		  return new Element(tagName, props, this);
		};
		
		Document.prototype.createComment = function (text) {
		  return new Comment(text, this);
		};
		
		function Node() {}
		
		Node.prototype.create = function (instanceId) {
		  this.parentRef = null;
		  this.attached = false;
		  if (instanceId) {
		    this.instanceId = instanceId;
		    var doc = instanceMap[instanceId];
		    doc.addRef(this);
		  }
		};
		
		Node.prototype.destroy = function () {
		  var ref = this.ref;
		  var instanceId = this.instanceId;
		  if (instanceId) {
		    var doc = instanceMap[instanceId];
		    doc.removeRef(ref);
		  }
		
		  var children = this.children || [];
		  var length = children.length;
		  for (var i = 0; i < length; i++) {
		    children[i].destroy();
		  }
		};
		
		Node.prototype.getRenderer = function () {
		  var doc = instanceMap[this.instanceId];
		  return doc.listener;
		};
		
		Node.prototype.next = function () {
		  var instanceId = this.instanceId;
		  var doc = instanceMap[instanceId];
		  var parent = doc.getRef(this.parentRef);
		  if (parent) {
		    return parent.children[parent.children.indexOf(this) + 1];
		  }
		};
		
		Node.prototype.prev = function () {
		  var instanceId = this.instanceId;
		  var doc = instanceMap[instanceId];
		  var parent = doc.getRef(this.parentRef);
		  if (parent) {
		    return parent.children[parent.children.indexOf(this) - 1];
		  }
		};
		
		function Element() {
		  var type = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_TAG_NAME : arguments[0];
		  var props = arguments[1];
		  var ownerDocument = arguments[2];
		
		  props = props || {};
		  this.create(ownerDocument.id);
		  this.ownerDocument = ownerDocument;
		  this.type = type;
		  this.attr = props.attr || {};
		  this.classStyle = props.classStyle || {};
		  this.style = props.style || {};
		  this.event = [];
		  this.children = [];
		  this.pureChildren = [];
		}
		
		Element.prototype = new Node();
		
		Element.prototype.appendChild = function (node) {
		
		  removeIfExisted(node);
		  node.parentRef = this.ref;
		  this.children.push(node);
		
		  if (this.attached) {
		    setAttached(node, this.depth);
		  } else {
		    setDetached(node);
		  }
		
		  if (node instanceof Element) {
		    this.pureChildren.push(node);
		
		    if (this.attached) {
		      var renderer = this.getRenderer();
		      if (renderer) {
		        if (this.ref === '_documentElement') {
		          // if its parent is documentElement then it's a body
		          renderer.createBody(node, this.ref);
		        } else {
		          renderer.addElement(node, this.ref);
		        }
		      }
		    }
		  }
		};
		
		Element.prototype.insertBefore = function (node, before) {
		
		  if (node.parentRef === this.ref) {
		    moveBefore(node, before, this.children);
		    if (node instanceof Element) {
		      var pureBeforeIndex = movePureBefore(node, before, this.pureChildren);
		      if (pureBeforeIndex >= 0 && this.attached) {
		        var renderer = this.getRenderer();
		        if (renderer) {
		          renderer.moveElement(node.ref, this.ref, pureBeforeIndex);
		        }
		      }
		    }
		    return;
		  }
		
		  removeIfExisted(node);
		
		  var children = this.children;
		  var index = children.indexOf(before);
		
		  node.parentRef = this.ref;
		  if (this.attached) {
		    setAttached(node, this.depth);
		  } else {
		    setDetached(node);
		  }
		  children.splice(index, 0, node);
		
		  if (node instanceof Element) {
		    var pureChildren = this.pureChildren;
		    var pureIndex = getPureAfter(before, pureChildren);
		
		    pureChildren.splice(pureIndex, 0, node);
		
		    if (this.attached) {
		      var _renderer = this.getRenderer();
		      if (_renderer) {
		        _renderer.addElement(node, this.ref, pureIndex);
		      }
		    }
		  }
		};
		
		Element.prototype.insertAfter = function (node, after) {
		
		  if (node.parentRef === this.ref) {
		    moveAfter(node, after, this.children);
		    if (node instanceof Element) {
		      var pureAfterIndex = movePureAfter(node, after, this.pureChildren);
		      if (pureAfterIndex >= 0 && this.attached) {
		        var renderer = this.getRenderer();
		        if (renderer) {
		          renderer.moveElement(node.ref, this.ref, pureAfterIndex);
		        }
		      }
		    }
		    return;
		  }
		
		  removeIfExisted(node);
		
		  var children = this.children;
		  var index = children.indexOf(after);
		
		  node.parentRef = this.ref;
		  if (this.attached) {
		    setAttached(node, this.depth);
		  } else {
		    setDetached(node);
		  }
		  children.splice(index + 1, 0, node);
		
		  if (node instanceof Element) {
		    var pureChildren = this.pureChildren;
		    var pureIndex = getPureBefore(after, pureChildren);
		
		    pureChildren.splice(pureIndex + 1, 0, node);
		
		    if (this.attached) {
		      var _renderer2 = this.getRenderer();
		      if (_renderer2) {
		        _renderer2.addElement(node, this.ref, pureIndex + 1);
		      }
		    }
		  }
		};
		
		Element.prototype.removeChild = function (node, preserved) {
		  var children = this.children;
		  var index = children.indexOf(node);
		
		  setDetached(node);
		
		  if (index >= 0) {
		    node.parentRef = null;
		    children.splice(index, 1);
		    if (!preserved) {
		      node.destroy();
		    }
		  }
		
		  if (node instanceof Element) {
		    this.pureChildren.$remove(node);
		    if (this.attached) {
		      var renderer = this.getRenderer();
		      if (renderer) {
		        renderer.removeElement(node.ref);
		      }
		    }
		  }
		};
		
		Element.prototype.clear = function () {
		  var children = this.children;
		  var length = children.length;
		  for (var i = 0; i < length; i++) {
		    var child = children[i];
		    child.parentRef = null;
		    setDetached(child);
		    child.destroy();
		  }
		  children.length = 0;
		
		  if (this.attached) {
		    var refs = this.pureChildren.map(function (child) {
		      return child.ref;
		    });
		    this.pureChildren.length = 0;
		    var renderer = this.getRenderer();
		    if (renderer) {
		      renderer.removeElement(refs);
		    }
		  }
		};
		
		function moveBefore(node, before, children) {
		  var targetIndex = children.indexOf(node);
		  var beforeIndex = children.indexOf(before);
		
		  /* istanbul ignore next */
		  if (targetIndex === beforeIndex || targetIndex + 1 === beforeIndex) {
		    return -1;
		  }
		
		  var newIndex = targetIndex < beforeIndex ? beforeIndex - 1 : beforeIndex;
		  children.splice(targetIndex, 1);
		  children.splice(newIndex, 0, node);
		
		  return beforeIndex;
		}
		
		function movePureBefore(node, before, pureChildren) {
		  var pureTargetIndex = pureChildren.indexOf(node);
		  var pureBeforeIndex = getPureAfter(before, pureChildren);
		
		  /* istanbul ignore next */
		  if (pureTargetIndex === pureBeforeIndex || pureTargetIndex + 1 === pureBeforeIndex) {
		    return -1;
		  }
		
		  var pureNewIndex = pureTargetIndex < pureBeforeIndex ? pureBeforeIndex - 1 : pureBeforeIndex;
		
		  pureChildren.splice(pureTargetIndex, 1);
		  pureChildren.splice(pureNewIndex, 0, node);
		
		  return pureBeforeIndex;
		}
		
		function getPureAfter(node, pureChildren) {
		  var pureIndex = pureChildren.indexOf(node);
		  while (node && pureIndex < 0) {
		    node = node.next();
		    pureIndex = pureChildren.indexOf(node);
		  }
		  if (pureIndex < 0) {
		    pureIndex = pureChildren.length;
		  }
		  return pureIndex;
		}
		
		function moveAfter(node, after, children) {
		  var targetIndex = children.indexOf(node);
		  var afterIndex = children.indexOf(after);
		
		  /* istanbul ignore next */
		  if (targetIndex === afterIndex || targetIndex === afterIndex + 1) {
		    return -1;
		  }
		
		  var newIndex = targetIndex < afterIndex ? afterIndex : afterIndex + 1;
		  children.splice(targetIndex, 1);
		  children.splice(newIndex, 0, node);
		
		  return afterIndex;
		}
		
		function movePureAfter(node, after, pureChildren) {
		  var pureTargetIndex = pureChildren.indexOf(node);
		  var pureAfterIndex = getPureBefore(after, pureChildren);
		
		  /* istanbul ignore next */
		  if (pureTargetIndex === pureAfterIndex || pureTargetIndex === pureAfterIndex + 1) {
		    return -1;
		  }
		
		  var pureNewIndex = pureTargetIndex < pureAfterIndex ? pureAfterIndex : pureAfterIndex + 1;
		
		  pureChildren.splice(pureTargetIndex, 1);
		  pureChildren.splice(pureNewIndex, 0, node);
		
		  return pureAfterIndex + 1;
		}
		
		function getPureBefore(node, pureChildren) {
		  var pureIndex = pureChildren.indexOf(node);
		  while (node && pureIndex < 0) {
		    node = node.prev();
		    pureIndex = pureChildren.indexOf(node);
		  }
		  /* istanbul ignore next */
		  if (pureIndex < 0) {
		    pureIndex = -1;
		  }
		  return pureIndex;
		}
		
		function setAttached(node, depth) {
		  if (node.ref === '_root') {
		    depth = 1;
		  } else {
		    depth = depth > 0 ? depth + 1 : 0;
		  }
		  node.attached = true;
		  node.depth = depth;
		  if (node.children) {
		    node.children.forEach(function (sub) {
		      setAttached(sub, depth);
		    });
		  }
		}
		
		function setDetached(node) {
		  node.attached = false;
		  node.depth = 0;
		  if (node.children) {
		    node.children.forEach(function (sub) {
		      setDetached(sub);
		    });
		  }
		}
		
		function removeIfExisted(node) {
		  var doc = instanceMap[node.instanceId];
		  if (doc) {
		    var existedNode = doc.getRef(node.ref);
		    if (existedNode) {
		      var existedParent = doc.getRef(existedNode.parentRef);
		      if (existedParent && existedParent.removeChild) {
		        existedParent.removeChild(existedNode, true);
		      }
		    }
		  }
		}
		
		Element.prototype.setAttr = function (key, value) {
		  if (this.attr[key] === value) {
		    return;
		  }
		  this.attr[key] = value;
		  if (this.attached) {
		    var renderer = this.getRenderer();
		    if (renderer) {
		      renderer.setAttr(this.ref, key, value);
		    }
		  }
		};
		
		Element.prototype.setStyle = function (key, value) {
		  if (this.style[key] === value) {
		    return;
		  }
		  this.style[key] = value;
		  if (this.attached) {
		    var renderer = this.getRenderer();
		    if (renderer) {
		      renderer.setStyle(this.ref, key, value);
		    }
		  }
		};
		
		Element.prototype.setClassStyle = function (classStyle) {
		  this.classStyle = classStyle;
		  if (this.attached) {
		    var renderer = this.getRenderer();
		    if (renderer) {
		      renderer.setStyles(this.ref, this.toStyle());
		    }
		  }
		};
		
		Element.prototype.addEvent = function (type, handler) {
		  var index = this.event.indexOf(type);
		
		  if (index < 0) {
		    this.event.push(type);
		    var eventManager = this.ownerDocument.eventManager;
		    eventManager.add(this, type, handler);
		
		    if (this.attached) {
		      var renderer = this.getRenderer();
		      if (renderer) {
		        renderer.addEvent(this.ref, type);
		      }
		    }
		  }
		};
		
		Element.prototype.removeEvent = function (type) {
		  var index = this.event.indexOf(type);
		
		  if (index >= 0) {
		    this.event.splice(index, 1);
		    var eventManager = this.ownerDocument.eventManager;
		    eventManager.remove(this, type);
		
		    if (this.attached) {
		      var renderer = this.getRenderer();
		      if (renderer) {
		        renderer.removeEvent(this.ref, type);
		      }
		    }
		  }
		};
		
		Element.prototype.toStyle = function () {
		  var result = {};
		  var classStyle = this.classStyle;
		  var style = this.style;
		  for (var name in classStyle) {
		    result[name] = classStyle[name];
		  }
		  for (var _name in style) {
		    result[_name] = style[_name];
		  }
		  return result;
		};
		
		Element.prototype.toJSON = function () {
		  var result = {
		    ref: this.ref.toString(),
		    type: this.type,
		    attr: this.attr,
		    style: this.toStyle()
		  };
		
		  if (this.event && this.event.length) {
		    result.event = this.event;
		  }
		  if (this.pureChildren && this.pureChildren.length) {
		    result.children = this.pureChildren.map(function (child) {
		      return child.toJSON();
		    });
		  }
		
		  return result;
		};
		
		Element.prototype.toString = function () {
		  return '<' + this.type + ' attr=' + JSON.stringify(this.attr) + ' style=' + JSON.stringify(this.toStyle()) + '>' + this.pureChildren.map(function (child) {
		    return child.toString();
		  }).join('') + '</' + this.type + '>';
		};
		
		function Comment(value, ownerDocument) {
		  this.create(ownerDocument.id);
		  this.type = 'comment';
		  this.value = value;
		}
		
		Comment.prototype = new Node();
		
		Comment.prototype.toString = function () {
		  return '<!-- ' + this.value + ' -->';
		};
	
	/***/ },
	/* 105 */
	/***/ function(module, exports) {
	
		module.exports = {
			"name": "weex-jsframework",
			"version": "0.13.9",
			"description": "JS Framework for Weex solution which is a extendable cross-platform solution for dynamic programming and publishing projects",
			"main": "index.js",
			"scripts": {
				"dev": "webpack --watch --config ./webpack.config.js",
				"build": "webpack --config ./webpack.config.js",
				"compress": "uglifyjs dist/index.js -o dist/index.min.js",
				"lint": "jscs --config .jscsrc polyfill/*.js polyfill/__test__/*.js lib/*.js lib/__test__/*.js lib/app/*.js lib/app/__test__/*.js lib/vm/*.js lib/vm/__test__/*.js",
				"test": "mocha --compilers js:babel-core/register polyfill/__test__/*.js lib/__test__/*.js lib/**/__test__/*.js",
				"cover": "babel-node node_modules/isparta/bin/isparta cover --report text node_modules/mocha/bin/_mocha -- --reporter dot lib/__test__/*.js lib/**/__test__/*.js",
				"ci": "npm run lint && npm run cover"
			},
			"repository": {
				"type": "git",
				"url": "git@github.com:alibaba/weex.git"
			},
			"author": [
				{
					"name": "jinjiang",
					"email": "zhaojinjiang@me.com"
				},
				{
					"name": "Terry King",
					"email": "terrykingcha@gmail.com"
				}
			],
			"contributors": [
				{
					"name": "pushiming",
					"email": "pushiming@gmail.com"
				},
				{
					"name": "iskenhuang",
					"email": "iskenhuang@gmail.com"
				},
				{
					"name": "yuanyan",
					"email": "yuanyan.cao@gmail.com"
				}
			],
			"keywords": [
				"weex",
				"mvvm",
				"browser",
				"hybrid",
				"framework"
			],
			"license": "Apache-2.0",
			"dependencies": {
				"semver": "~5.1.0",
				"core-js": "~2.1.1"
			},
			"devDependencies": {
				"babel-cli": "~6.4.5",
				"babel-core": "~6.4.5",
				"babel-loader": "~6.2.1",
				"babel-preset-es2015": "~6.3.13",
				"chai": "~3.2.0",
				"isparta": "~4.0.0",
				"istanbul": "~0.4.2",
				"jscs": "~2.9.0",
				"json-loader": "^0.5.4",
				"mocha": "~2.3.4",
				"sinon": "~1.17.2",
				"sinon-chai": "~2.8.0",
				"uglify-js": "^2.6.2",
				"watch-cli": "~0.2.1",
				"webpack": "~1.12.12"
			},
			"optionalDependencies": {
				"weex-transformer": ">=0.1.5 <0.4"
			}
		};
	
	/***/ },
	/* 106 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(global) {'use strict';
		
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports.$ = $;
		exports.$el = $el;
		exports.$vm = $vm;
		exports.$renderThen = $renderThen;
		exports.$scrollTo = $scrollTo;
		exports.$transition = $transition;
		exports.$getConfig = $getConfig;
		exports.$sendHttp = $sendHttp;
		exports.$openURL = $openURL;
		exports.$setTitle = $setTitle;
		exports.$call = $call;
		
		var _util = __webpack_require__(81);
		
		/**
		 * ==========================================================
		 * common
		 * ==========================================================
		 */
		
		/**
		 * @deprecated use $vm instead
		 * find the vm by id
		 * Note: there is only one id in whole component
		 * @param  {string} id
		 * @return {Vm}
		 */
		function $(id) {
		  nativeLog('[WARNING] the Vm#$ api is deprecated, please use Vm#$vm instead');
		  var info = this._ids[id];
		  if (info) {
		    return info.vm;
		  }
		}
		
		/**
		 * find the element by id
		 * Note: there is only one id in whole component
		 * @param  {string} id
		 * @return {Element}
		 */
		/**
		 * @fileOverview The api for invoking with "$" prefix
		 */
		function $el(id) {
		  var info = this._ids[id];
		  if (info) {
		    return info.el;
		  }
		}
		
		/**
		 * find the vm of the custom component by id
		 * Note: there is only one id in whole component
		 * @param  {string} id
		 * @return {Vm}
		 */
		function $vm(id) {
		  var info = this._ids[id];
		  if (info) {
		    return info.vm;
		  }
		}
		
		/**
		 * Fire when differ rendering finished
		 *
		 * @param  {Function} fn
		 */
		function $renderThen(fn) {
		  var app = this._app;
		  var differ = app.differ;
		  return differ.then(function () {
		    fn();
		  });
		}
		
		/**
		 * scroll an element specified by id into view, 
		 * moreover specify a number of offset optionally
		 * @param  {string} id
		 * @param  {number} offset
		 */
		function $scrollTo(id, offset) {
		  var el = this.$el(id);
		  if (el) {
		    var dom = this._app.requireModule('dom');
		    dom.scrollToElement(el.ref, { offset: offset });
		  }
		}
		
		/**
		 * perform transition animation on an element specified by id
		 * @param  {string}   id
		 * @param  {object}   options
		 * @param  {object}   options.styles
		 * @param  {object}   options.duration(ms)
		 * @param  {object}   [options.timingFunction]
		 * @param  {object}   [options.delay=0(ms)]
		 * @param  {Function} callback
		 */
		function $transition(id, options, callback) {
		  var _this = this;
		
		  var el = this.$el(id);
		  if (el && options && options.styles) {
		    var animation = this._app.requireModule('animation');
		    animation.transition(el.ref, options, function () {
		      _this._setStyle(el, options.styles);
		      callback && callback.apply(undefined, arguments);
		    });
		  }
		}
		
		/**
		 * get some config
		 * @return {object} some config for app instance
		 * @property {string} bundleUrl
		 * @property {boolean} debug
		 * @property {object} env
		 * @property {string} env.weexVersion(ex. 1.0.0)
		 * @property {string} env.appName(ex. TB/TM)
		 * @property {string} env.appVersion(ex. 5.0.0)
		 * @property {string} env.platform(ex. iOS/Android)
		 * @property {string} env.osVersion(ex. 7.0.0)
		 * @property {string} env.deviceModel **native only**
		 * @property {number} env.[deviceWidth=750]
		 * @property {number} env.deviceHeight
		 */
		function $getConfig(callback) {
		  var config = (0, _util.extend)({
		    env: global.WXEnvironment || {}
		  }, this._app.options);
		  if ((0, _util.typof)(callback) === 'function') {
		    nativeLog('[WARNING] the callback of Vm#$getConfig(callback) is deprecated, ' + 'this api now can directly RETURN config info.');
		    callback(config);
		  }
		  return config;
		}
		
		/**
		 * request network via http protocol
		 * @param  {object}   params
		 * @param  {Function} callback
		 */
		function $sendHttp(params, callback) {
		  var stream = this._app.requireModule('stream');
		  stream.sendHttp(params, callback);
		}
		
		/**
		 * open a url
		 * @param  {string} url
		 */
		function $openURL(url) {
		  var event = this._app.requireModule('event');
		  event.openURL(url);
		}
		
		/**
		 * set a title for page
		 * @param  {string} title
		 */
		function $setTitle(title) {
		  var pageInfo = this._app.requireModule('pageInfo');
		  pageInfo.setTitle(title);
		}
		
		/**
		 * invoke a native method by specifing the name of module and method
		 * @param  {string} moduleName
		 * @param  {string} methodName
		 * @param  {...*} the rest arguments
		 */
		function $call(moduleName, methodName) {
		  var module = this._app.requireModule(moduleName);
		  if (module && module[methodName]) {
		    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
		      args[_key - 2] = arguments[_key];
		    }
		
		    module[methodName].apply(module, args);
		  }
		}
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ }
	/******/ ]);
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNDBlMDBjYjE0M2YzYjdhM2ZkMjQiLCJ3ZWJwYWNrOi8vLy4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcG9seWZpbGwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vcG9seWZpbGwvb2JqZWN0QXNzaWduLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9mbi9vYmplY3QvYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19mYWlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vcG9seWZpbGwvcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19taWNyb3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwid2VicGFjazovLy8uL3BvbHlmaWxsL3NldFRpbWVvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vcG9seWZpbGwvY29uc29sZWxvZy5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZnJhbWV3b3JrLmpzIiwid2VicGFjazovLy8uL2xpYi9wZXJmLmpzIiwid2VicGFjazovLy8uL2xpYi9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9saWIvYXBwL2luZGV4LmpzIiwid2VicGFjazovLy8uL2xpYi91dGlsL2luZGV4LmpzIiwid2VicGFjazovLy8uL2xpYi9hcHAvYnVuZGxlLmpzIiwid2VicGFjazovLy8uL34vc2VtdmVyL3NlbXZlci5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL3ZtL2luZGV4LmpzIiwid2VicGFjazovLy8uL2xpYi92bS9pbnN0YW5jZS9zY29wZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvdm0vdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvdm0vb2JzZXJ2ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbGliL3ZtL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9saWIvdm0vb2JzZXJ2ZXIvZGVwLmpzIiwid2VicGFjazovLy8uL2xpYi92bS9vYnNlcnZlci9hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvdm0vb2JzZXJ2ZXIvb2JqZWN0LmpzIiwid2VicGFjazovLy8uL2xpYi92bS9jb21waWxlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvdm0vZGlyZWN0aXZlLmpzIiwid2VicGFjazovLy8uL2xpYi92bS93YXRjaGVyLmpzIiwid2VicGFjazovLy8uL2xpYi92bS9kb20taGVscGVyLmpzIiwid2VicGFjazovLy8uL2xpYi92bS9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2FwcC9yZWdpc3Rlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvYXBwL2Rvd25ncmFkZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvYXBwL2N0cmwuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2FwcC9kb20tbGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2FwcC9kaWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2FwcC9ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvYXBwL2RvbS5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlLmpzb24iLCJ3ZWJwYWNrOi8vLy4vbGliL2FwaS9tZXRob2RzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7O0FDdENBOztBQUNBOztLQUFZLFM7O0FBQ1o7Ozs7NEJBRVMsVTtBQUNMLFlBQU8sVUFBUCxJQUFxQixZQUFtQjtBQUNwQyxhQUFNLE1BQU0sVUFBVSxVQUFWLDZCQUFaO0FBQ0EsYUFBSSxlQUFlLEtBQW5CLEVBQTBCO0FBQ3RCLHFCQUFRLEtBQVIsQ0FBYyxJQUFJLFFBQUosRUFBZDtBQUNILFVBRkQsTUFFTyxJQUFJLGVBQWUsS0FBbkIsRUFBMEI7QUFDN0IsaUJBQUksT0FBSixDQUFZLGFBQUs7QUFDYixxQkFBSSxhQUFhLEtBQWpCLEVBQXdCO0FBQ3BCLDZCQUFRLEtBQVIsQ0FBYyxFQUFFLFFBQUYsRUFBZDtBQUNIO0FBQ0osY0FKRDtBQUtIO0FBQ0QsZ0JBQU8sR0FBUDtBQUNILE1BWkQ7OztBQURKLE1BQUssSUFBSSxVQUFULElBQXVCLFNBQXZCLEVBQWtDO0FBQUEsV0FBekIsVUFBeUI7QUFjakM7O0FBRUQsUUFBTyxNQUFQLENBQWMsTUFBZCxFQUFzQjtBQUNsQix1Q0FEa0I7QUFFbEIsNkJBQXdCLDhCQUFxQixrQkFBckI7QUFGTixFQUF0Qjs7Ozs7QUFRQSxL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UCxJQUF3QjtBQURULElBQVAsRUFFWixLQUFLLElBQUwsQ0FBVSxPQUZFLENBQWY7QUFHQSxPQUFJLGlCQUFNLFFBQU4sTUFBb0IsVUFBeEIsRUFBb0M7QUFDbEMsZUFBVSxzRUFDUiwrQ0FERjtBQUVBLGNBQVMsTUFBVDtBQUNEO0FBQ0QsVUFBTyxNQUFQO0FBQ0Q7Ozs7Ozs7QUFPTSxVQUFTLFNBQVQsQ0FBbUIsTUFBbkIsRUFBMkIsUUFBM0IsRUFBcUM7QUFDMUMsT0FBTSxTQUFTLEtBQUssSUFBTCxDQUFVLGFBQVYsQ0FBd0IsUUFBeEIsQ0FBZjtBQUNBLFVBQU8sUUFBUCxDQUFnQixNQUFoQixFQUF3QixRQUF4QjtBQUNEOzs7Ozs7QUFNTSxVQUFTLFFBQVQsQ0FBa0IsR0FBbEIsRUFBdUI7QUFDNUIsT0FBTSxRQUFRLEtBQUssSUFBTCxDQUFVLGFBQVYsQ0FBd0IsT0FBeEIsQ0FBZDtBQUNBLFNBQU0sT0FBTixDQUFjLEdBQWQ7QUFDRDs7Ozs7O0FBTU0sVUFBUyxTQUFULENBQW1CLEtBQW5CLEVBQTBCO0FBQy9CLE9BQU0sV0FBVyxLQUFLLElBQUwsQ0FBVSxhQUFWLENBQXdCLFVBQXhCLENBQWpCO0FBQ0EsWUFBUyxRQUFULENBQWtCLEtBQWxCO0FBQ0Q7Ozs7Ozs7O0FBUU0sVUFBUyxLQUFULENBQWUsVUFBZixFQUEyQixVQUEzQixFQUFnRDtBQUNyRCxPQUFNLFNBQVMsS0FBSyxJQUFMLENBQVUsYUFBVixDQUF3QixVQUF4QixDQUFmO0FBQ0EsT0FBSSxVQUFVLE9BQU8sVUFBUCxDQUFkLEVBQWtDO0FBQUEsdUNBRmEsSUFFYjtBQUZhLFdBRWI7QUFBQTs7QUFDaEMsWUFBTyxVQUFQLGdCQUFzQixJQUF0QjtBQUNEO0FBQ0YsRSIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgNDBlMDBjYjE0M2YzYjdhM2ZkMjRcbiAqKi8iLCJpbXBvcnQgJy4vcG9seWZpbGwnXG5pbXBvcnQgKiBhcyBmcmFtZXdvcmsgZnJvbSAnLi9saWIvZnJhbWV3b3JrJ1xuaW1wb3J0IHt2ZXJzaW9uLCBvcHRpb25hbERlcGVuZGVuY2llc30gZnJvbSAnLi9wYWNrYWdlLmpzb24nXG5cbmZvciAobGV0IG1ldGhvZE5hbWUgaW4gZnJhbWV3b3JrKSB7XG4gICAgZ2xvYmFsW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gZnJhbWV3b3JrW21ldGhvZE5hbWVdKC4uLmFyZ3MpXG4gICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXQudG9TdHJpbmcoKSlcbiAgICAgICAgfSBlbHNlIGlmIChyZXQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmV0LmZvckVhY2gociA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHIudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRcbiAgICB9XG59XG5cbk9iamVjdC5hc3NpZ24oZ2xvYmFsLCB7XG4gICAgZnJhbWV3b3JrVmVyc2lvbjogdmVyc2lvbixcbiAgICBuZWVkVHJhbnNmb3JtZXJWZXJzaW9uOiBvcHRpb25hbERlcGVuZGVuY2llc1snd2VleC10cmFuc2Zvcm1lciddXG59KVxuXG4vKipcbiAqIHJlZ2lzdGVyIG1ldGhvZHNcbiAqL1xuY29uc3QgbWV0aG9kcyA9IHJlcXVpcmUoJy4vbGliL2FwaS9tZXRob2RzJylcbmNvbnN0IHtyZWdpc3Rlck1ldGhvZHN9ID0gZ2xvYmFsXG5yZWdpc3Rlck1ldGhvZHMobWV0aG9kcylcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaW5kZXguanNcbiAqKi8iLCJpbXBvcnQgJy4vb2JqZWN0QXNzaWduJ1xuaW1wb3J0ICcuL3Byb21pc2UnXG5pbXBvcnQgJy4vc2V0VGltZW91dCdcbmltcG9ydCAnLi9jb25zb2xlbG9nJ1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9wb2x5ZmlsbC9pbmRleC5qc1xuICoqLyIsImltcG9ydCAnY29yZS1qcy9mbi9vYmplY3QvYXNzaWduJ1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9wb2x5ZmlsbC9vYmplY3RBc3NpZ24uanNcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuYXNzaWduO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL2ZuL29iamVjdC9hc3NpZ24uanNcbiAqKi8iLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7YXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyl9KTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmUgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pXG4gICAgLCBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYodGFyZ2V0KXJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmKGV4cG9ydHNba2V5XSAhPSBvdXQpaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qc1xuICoqLyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuMS41J307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzXG4gKiovIiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanNcbiAqKi8iLCJ2YXIgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBkUCAgICAgICAgICAgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpe1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qc1xuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XHJcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xyXG59KTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qc1xuICoqLyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanNcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xuICoqLyIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBTUkMgICAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJylcbiAgLCBUT19TVFJJTkcgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXVxuICAsIFRQTCAgICAgICA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBrZXksIHZhbCwgc2FmZSl7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYoT1trZXldID09PSB2YWwpcmV0dXJuO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZihPID09PSBnbG9iYWwpe1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBpZighc2FmZSl7XG4gICAgICBkZWxldGUgT1trZXldO1xuICAgICAgaGlkZShPLCBrZXksIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKE9ba2V5XSlPW2tleV0gPSB2YWw7XG4gICAgICBlbHNlIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanNcbiAqKi8iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19oYXMuanNcbiAqKi8iLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL191aWQuanNcbiAqKi8iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2N0eC5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgcElFICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCAkYXNzaWduICA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBBID0ge31cbiAgICAsIEIgPSB7fVxuICAgICwgUyA9IFN5bWJvbCgpXG4gICAgLCBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oayl7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgICAgID0gdG9PYmplY3QodGFyZ2V0KVxuICAgICwgYUxlbiAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBpbmRleCA9IDFcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmZcbiAgICAsIGlzRW51bSAgICAgPSBwSUUuZjtcbiAgd2hpbGUoYUxlbiA+IGluZGV4KXtcbiAgICB2YXIgUyAgICAgID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pXG4gICAgICAsIGtleXMgICA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaiAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gailpZihpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKVRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanNcbiAqKi8iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcclxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxyXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XHJcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcclxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qc1xuICoqLyIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxyXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXHJcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxyXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcclxuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcclxuICAgICwgaSAgICAgID0gMFxyXG4gICAgLCByZXN1bHQgPSBbXVxyXG4gICAgLCBrZXk7XHJcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xyXG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcclxuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XHJcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzXG4gKiovIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzXG4gKiovIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qc1xuICoqLyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fY29mLmpzXG4gKiovIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanNcbiAqKi8iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgdG9JbmRleCAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oSVNfSU5DTFVERVMpe1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoJHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGZyb21JbmRleCwgbGVuZ3RoKVxuICAgICAgLCB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgaWYoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpd2hpbGUobGVuZ3RoID4gaW5kZXgpe1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgaWYodmFsdWUgIT0gdmFsdWUpcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjdG9JbmRleCBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pe1xuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzXG4gKiovIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzXG4gKiovIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanNcbiAqKi8iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzXG4gKiovIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJylcclxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XHJcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcclxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzXG4gKiovIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcbiAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanNcbiAqKi8iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXHJcbm1vZHVsZS5leHBvcnRzID0gKFxyXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXHJcbikuc3BsaXQoJywnKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXG4gKiovIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qc1xuICoqLyIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanNcbiAqKi8iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4gKiovIiwiLy8gZml4IFByb21pc2UgUHJvYmxlbSBvbiBKU0NvbnRleHQgb2YgaU9TN344XG4vLyBAc2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzU4NjZcbmdsb2JhbC5Qcm9taXNlID0gbnVsbFxucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJylcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJylcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJylcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZScpXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9wb2x5ZmlsbC9wcm9taXNlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIHRlc3QgICAgPSB7fTtcbnRlc3RbcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyldID0gJ3onO1xuaWYodGVzdCArICcnICE9ICdbb2JqZWN0IHpdJyl7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG4gIH0sIHRydWUpO1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanNcbiAqKi8iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanNcbiAqKi8iLCJ2YXIgc3RvcmUgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFN5bWJvbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2xcbiAgLCBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbiAqKi8iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoYXQsIHBvcyl7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXG4gICAgICAsIGwgPSBzLmxlbmd0aFxuICAgICAgLCBhLCBiO1xuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXG4gICAgLCAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZVxuICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkYW55TmF0aXZlKXtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZighTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGRlc2NyaXB0b3IgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCl9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzXG4gKiovIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXHJcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXHJcbiAgLCBkUHMgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKVxyXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJylcclxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXHJcbiAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cclxuICAsIFBST1RPVFlQRSAgID0gJ3Byb3RvdHlwZSc7XHJcblxyXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXHJcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcclxuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xyXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpXHJcbiAgICAsIGkgICAgICA9IGVudW1CdWdLZXlzLmxlbmd0aFxyXG4gICAgLCBndCAgICAgPSAnPidcclxuICAgICwgaWZyYW1lRG9jdW1lbnQ7XHJcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XHJcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxyXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XHJcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xyXG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XHJcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xyXG4gIGlmcmFtZURvY3VtZW50LndyaXRlKCc8c2NyaXB0PmRvY3VtZW50LkY9T2JqZWN0PC9zY3JpcHQnICsgZ3QpO1xyXG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XHJcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XHJcbiAgd2hpbGUoaS0tKWRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xyXG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xyXG4gIHZhciByZXN1bHQ7XHJcbiAgaWYoTyAhPT0gbnVsbCl7XHJcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XHJcbiAgICByZXN1bHQgPSBuZXcgRW1wdHk7XHJcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcclxuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcclxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xyXG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XHJcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xyXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanNcbiAqKi8iLCJ2YXIgZFAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxyXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxyXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpe1xyXG4gIGFuT2JqZWN0KE8pO1xyXG4gIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXHJcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAsIGkgPSAwXHJcbiAgICAsIFA7XHJcbiAgd2hpbGUobGVuZ3RoID4gaSlkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xyXG4gIHJldHVybiBPO1xyXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19odG1sLmpzXG4gKiovIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBoYXMgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXG4gKiovIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcclxudmFyIGhhcyAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcclxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcclxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXHJcbiAgLCBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihPKXtcclxuICBPID0gdG9PYmplY3QoTyk7XHJcbiAgaWYoaGFzKE8sIElFX1BST1RPKSlyZXR1cm4gT1tJRV9QUk9UT107XHJcbiAgaWYodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcil7XHJcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XHJcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcclxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzXG4gKiovIiwidmFyICRpdGVyYXRvcnMgICAgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpXG4gICwgcmVkZWZpbmUgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBnbG9iYWwgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgSXRlcmF0b3JzICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgd2tzICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpXG4gICwgSVRFUkFUT1IgICAgICA9IHdrcygnaXRlcmF0b3InKVxuICAsIFRPX1NUUklOR19UQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJylcbiAgLCBBcnJheVZhbHVlcyAgID0gSXRlcmF0b3JzLkFycmF5O1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGVcbiAgICAsIGtleTtcbiAgaWYocHJvdG8pe1xuICAgIGlmKCFwcm90b1tJVEVSQVRPUl0paGlkZShwcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICBpZighcHJvdG9bVE9fU1RSSU5HX1RBR10paGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgZm9yKGtleSBpbiAkaXRlcmF0b3JzKWlmKCFwcm90b1trZXldKXJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpXG4gICwgc3RlcCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgdG9JT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXG4gKiovIiwiLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIFVOU0NPUEFCTEVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3Vuc2NvcGFibGVzJylcbiAgLCBBcnJheVByb3RvICA9IEFycmF5LnByb3RvdHlwZTtcbmlmKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZClyZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjbGFzc29mICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCAkZXhwb3J0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gICAgICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbkluc3RhbmNlICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgZm9yT2YgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCBzZXRQcm90byAgICAgICAgICAgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXRcbiAgLCBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgLCB0YXNrICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190YXNrJykuc2V0XG4gICwgbWljcm90YXNrICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJylcbiAgLCBQUk9NSVNFICAgICAgICAgICAgPSAnUHJvbWlzZSdcbiAgLCBUeXBlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCAkUHJvbWlzZSAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgICAgICAgICA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgZW1wdHkgICAgICAgICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIEludGVybmFsLCBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlICAgICA9ICRQcm9taXNlLnJlc29sdmUoMSlcbiAgICAgICwgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uKGV4ZWMpeyBleGVjKGVtcHR5LCBlbXB0eSk7IH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gd2l0aCBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIHJldHVybiBhID09PSBiIHx8IGEgPT09ICRQcm9taXNlICYmIGIgPT09IFdyYXBwZXI7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHJldHVybiBzYW1lQ29uc3RydWN0b3IoJFByb21pc2UsIEMpXG4gICAgPyBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICA6IG5ldyBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKCQkcmVzb2x2ZSwgJCRyZWplY3Qpe1xuICAgIGlmKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ICA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcbnZhciBwZXJmb3JtID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB7ZXJyb3I6IGV9O1xuICB9XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHByb21pc2UsIGlzUmVqZWN0KXtcbiAgaWYocHJvbWlzZS5fbilyZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIG9rICAgID0gcHJvbWlzZS5fcyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Rpb24pe1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbFxuICAgICAgICAsIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlXG4gICAgICAgICwgcmVqZWN0ICA9IHJlYWN0aW9uLnJlamVjdFxuICAgICAgICAsIGRvbWFpbiAgPSByZWFjdGlvbi5kb21haW5cbiAgICAgICAgLCByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihoYW5kbGVyKXtcbiAgICAgICAgICBpZighb2spe1xuICAgICAgICAgICAgaWYocHJvbWlzZS5faCA9PSAyKW9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGhhbmRsZXIgPT09IHRydWUpcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2Upe1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdCAmJiAhcHJvbWlzZS5faClvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBhYnJ1cHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSkpe1xuICAgICAgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgICBpZihpc05vZGUpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbil7XG4gICAgICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZX0pO1xuICAgICAgICB9IGVsc2UgaWYoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmKGFicnVwdCl0aHJvdyBhYnJ1cHQuZXJyb3I7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICBpZihwcm9taXNlLl9oID09IDEpcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2NcbiAgICAsIGkgICAgID0gMFxuICAgICwgcmVhY3Rpb247XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYoaXNOb2RlKXtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCl7XG4gICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3Z9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmKCFwcm9taXNlLl9hKXByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihwcm9taXNlID09PSB2YWx1ZSl0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge193OiBwcm9taXNlLCBfZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaChlcnIpe1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCl7XG4gICAgICB2YXIgcmVhY3Rpb24gICAgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rICAgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCAgID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fYSl0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fcylub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcHJvbWlzZSAgPSBuZXcgSW50ZXJuYWw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ICA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1Byb21pc2U6ICRQcm9taXNlfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZWplY3QgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiAkUHJvbWlzZSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcykpcmV0dXJuIHg7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdmFsdWVzICAgID0gW11cbiAgICAgICAgLCBpbmRleCAgICAgPSAwXG4gICAgICAgICwgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIHZhciAkaW5kZXggICAgICAgID0gaW5kZXgrK1xuICAgICAgICAgICwgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGlmKGFscmVhZHlDYWxsZWQpcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCl7XG4gIGlmKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKXtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanNcbiAqKi8iLCJ2YXIgY3R4ICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGNhbGwgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgZ2V0SXRlckZuICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKXtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKVxuICAgICwgZiAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yO1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZihpc0FycmF5SXRlcihpdGVyRm4pKWZvcihsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICB9IGVsc2UgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7ICl7XG4gICAgY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gIH1cbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZm9yLW9mLmpzXG4gKiovIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpe1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2goZSl7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZihyZXQgIT09IHVuZGVmaW5lZClhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzXG4gKiovIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIElURVJBVE9SICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzXG4gKiovIiwidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgIT0gdW5kZWZpbmVkKXJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanNcbiAqKi8iLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG4gIGFuT2JqZWN0KE8pO1xuICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzXG4gKiovIiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXHJcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxyXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcclxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcclxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcclxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxyXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xyXG5cclxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XHJcbiAgTyA9IHRvSU9iamVjdChPKTtcclxuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XHJcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcclxuICAgIHJldHVybiBnT1BEKE8sIFApO1xyXG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cclxuICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xyXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzXG4gKiovIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBTUEVDSUVTICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBEKXtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvciwgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXG4gKiovIiwidmFyIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaW52b2tlICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBodG1sICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19odG1sJylcbiAgLCBjZWwgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgc2V0VGFzayAgICAgICAgICAgID0gZ2xvYmFsLnNldEltbWVkaWF0ZVxuICAsIGNsZWFyVGFzayAgICAgICAgICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxuICAsIE1lc3NhZ2VDaGFubmVsICAgICA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbFxuICAsIGNvdW50ZXIgICAgICAgICAgICA9IDBcbiAgLCBxdWV1ZSAgICAgICAgICAgICAgPSB7fVxuICAsIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnXG4gICwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIGlmKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSl7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYoIXNldFRhc2sgfHwgIWNsZWFyVGFzayl7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pe1xuICAgIHZhciBhcmdzID0gW10sIGkgPSAxO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpe1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZihyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcycpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmKE1lc3NhZ2VDaGFubmVsKXtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsO1xuICAgIHBvcnQgICAgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZihPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbigpe1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogICBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanNcbiAqKi8iLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIGFyZ3MsIHRoYXQpe1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIE9ic2VydmVyICA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyXG4gICwgcHJvY2VzcyAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBQcm9taXNlICAgPSBnbG9iYWwuUHJvbWlzZVxuICAsIGlzTm9kZSAgICA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJ1xuICAsIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxudmFyIGZsdXNoID0gZnVuY3Rpb24oKXtcbiAgdmFyIHBhcmVudCwgZm47XG4gIGlmKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKXBhcmVudC5leGl0KCk7XG4gIHdoaWxlKGhlYWQpe1xuICAgIGZuID0gaGVhZC5mbjtcbiAgICBmbigpOyAvLyA8LSBjdXJyZW50bHkgd2UgdXNlIGl0IG9ubHkgZm9yIFByb21pc2UgLSB0cnkgLyBjYXRjaCBub3QgcmVxdWlyZWRcbiAgICBoZWFkID0gaGVhZC5uZXh0O1xuICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gIGlmKHBhcmVudClwYXJlbnQuZW50ZXIoKTtcbn07XG5cbi8vIE5vZGUuanNcbmlmKGlzTm9kZSl7XG4gIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gIH07XG4vLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbn0gZWxzZSBpZihPYnNlcnZlcil7XG4gIHZhciB0b2dnbGUgPSB0cnVlXG4gICAgLCBub2RlICAgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gIH07XG4vLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxufSBlbHNlIGlmKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKXtcbiAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZsdXNoKTtcbiAgfTtcbi8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4vLyAtIHNldEltbWVkaWF0ZVxuLy8gLSBNZXNzYWdlQ2hhbm5lbFxuLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2Vcbi8vIC0gc2V0VGltZW91dFxufSBlbHNlIHtcbiAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4pe1xuICB2YXIgdGFzayA9IHtmbjogZm4sIG5leHQ6IHVuZGVmaW5lZH07XG4gIGlmKGxhc3QpbGFzdC5uZXh0ID0gdGFzaztcbiAgaWYoIWhlYWQpe1xuICAgIGhlYWQgPSB0YXNrO1xuICAgIG5vdGlmeSgpO1xuICB9IGxhc3QgPSB0YXNrO1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19taWNyb3Rhc2suanNcbiAqKi8iLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIHNyYywgc2FmZSl7XG4gIGZvcih2YXIga2V5IGluIHNyYylyZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIHNhZmUpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS1hbGwuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBTUEVDSUVTICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSlkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanNcbiAqKi8iLCJ2YXIgSVRFUkFUT1IgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbigpeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbigpeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjLCBza2lwQ2xvc2luZyl7XG4gIGlmKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKXJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyICA9IFs3XVxuICAgICAgLCBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKCl7IHNhZmUgPSB0cnVlOyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbigpeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzXG4gKiovIiwiY29uc3Qge1xuICBzZXRUaW1lb3V0LCBzZXRUaW1lb3V0TmF0aXZlXG59ID0gZ2xvYmFsXG5cbi8vIGZpeCBubyBzZXRUaW1lb3V0IG9uIEFuZHJvaWQgVjhcbmlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIHNldFRpbWVvdXROYXRpdmUgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc3QgdGltZW91dE1hcCA9IHt9XG4gIGxldCB0aW1lb3V0SWQgPSAwXG4gIGdsb2JhbC5zZXRUaW1lb3V0ID0gKGNiLCB0aW1lKSA9PiB7XG4gICAgdGltZW91dE1hcFsrK3RpbWVvdXRJZF0gPSBjYlxuICAgIHNldFRpbWVvdXROYXRpdmUodGltZW91dElkLnRvU3RyaW5nKCksIHRpbWUpXG4gIH1cbiAgZ2xvYmFsLnNldFRpbWVvdXRDYWxsYmFjayA9IChpZCkgPT4ge1xuICAgIGlmICh0eXBlb2YgdGltZW91dE1hcFtpZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRpbWVvdXRNYXBbaWRdKClcbiAgICAgIGRlbGV0ZSB0aW1lb3V0TWFwW2lkXVxuICAgIH1cbiAgfVxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vcG9seWZpbGwvc2V0VGltZW91dC5qc1xuICoqLyIsImNvbnN0IHtjb25zb2xlfSA9IGdsb2JhbFxuXG5pZiAodHlwZW9mIGNvbnNvbGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIGdsb2JhbC5jb25zb2xlID0ge1xuICAgIGxvZzogKC4uLmFyZ3MpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgbmF0aXZlTG9nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG5hdGl2ZUxvZyguLi5hcmdzKVxuICAgICAgfVxuICAgIH0sXG4gICAgZXJyb3I6ICguLi5hcmdzKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYXJncylcbiAgICB9XG4gIH1cbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3BvbHlmaWxsL2NvbnNvbGVsb2cuanNcbiAqKi8iLCIvKipcbiAqIEBmaWxlT3ZlcnZpZXcgTWFpbiBlbnRyeSwgaW5zdGFuY2UgbWFuYWdlclxuICpcbiAqIC0gY3JlYXRlSW5zdGFuY2UoaW5zdGFuY2VJZCwgY29kZSwgb3B0aW9ucywgZGF0YSlcbiAqIC0gcmVmcmVzaEluc3RhbmNlKGluc3RhbmNlSWQsIGRhdGEpXG4gKiAtIGRlc3Ryb3lJbnN0YW5jZShpbnN0YW5jZUlkKVxuICogLSByZWdpc3RlckNvbXBvbmVudHMoY29tcG9uZW50cylcbiAqIC0gcmVnaXN0ZXJNb2R1bGVzKG1vZHVsZXMpXG4gKiAtIGdldFJvb3QoaW5zdGFuY2VJZClcbiAqIC0gaW5zdGFuY2VNYXBcbiAqIC0gY2FsbEpTKGluc3RhbmNlSWQsIHRhc2tzKVxuICogICAtIGZpcmVFdmVudChyZWYsIHR5cGUsIGRhdGEpXG4gKiAgIC0gY2FsbGJhY2soZnVuY0lkLCBkYXRhKVxuICovXG5cbmltcG9ydCAqIGFzIHBlcmYgZnJvbSAnLi9wZXJmJ1xuaW1wb3J0ICogYXMgY29uZmlnIGZyb20gJy4vY29uZmlnJ1xuaW1wb3J0IEFwcEluc3RhbmNlIGZyb20gJy4vYXBwJ1xuaW1wb3J0IFZtIGZyb20gJy4vdm0nXG5cbnZhciB7XG4gIG5hdGl2ZUNvbXBvbmVudE1hcFxufSA9IGNvbmZpZ1xudmFyIGluc3RhbmNlTWFwID0ge31cblxuLyoqXG4gKiBjcmVhdGUgYSBXZWV4IGluc3RhbmNlXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBpbnN0YW5jZUlkXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvZGVcbiAqIEBwYXJhbSAge29iamVjdH0gW29wdGlvbnNdIG9wdGlvbiBgSEFTX0xPR2AgZW5hYmxlIHByaW50IGxvZ1xuICogQHBhcmFtICB7b2JqZWN0fSBbZGF0YV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGluc3RhbmNlSWQsIGNvZGUsIG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIGluc3RhbmNlID0gaW5zdGFuY2VNYXBbaW5zdGFuY2VJZF1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBjb25maWcuZGVidWcgPSBvcHRpb25zLmRlYnVnXG5cbiAgdmFyIHJlc3VsdFxuICBpZiAoIWluc3RhbmNlKSB7XG4gICAgcGVyZi5zdGFydCgnY3JlYXRlSW5zdGFuY2UnLCBpbnN0YW5jZUlkKVxuICAgIGluc3RhbmNlID0gbmV3IEFwcEluc3RhbmNlKGluc3RhbmNlSWQsIG9wdGlvbnMpXG4gICAgaW5zdGFuY2VNYXBbaW5zdGFuY2VJZF0gPSBpbnN0YW5jZVxuICAgIHJlc3VsdCA9IGluc3RhbmNlLmluaXQoY29kZSwgZGF0YSlcbiAgICBwZXJmLmVuZCgnY3JlYXRlSW5zdGFuY2UnLCBpbnN0YW5jZUlkKVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0YW5jZSBpZCBcIiR7aW5zdGFuY2VJZH1cImApXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogcmVmcmVzaCBhIFdlZXggaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGluc3RhbmNlSWRcbiAqIEBwYXJhbSAge29iamVjdH0gZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVmcmVzaEluc3RhbmNlKGluc3RhbmNlSWQsIGRhdGEpIHtcbiAgdmFyIGluc3RhbmNlID0gaW5zdGFuY2VNYXBbaW5zdGFuY2VJZF1cbiAgdmFyIHJlc3VsdFxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBwZXJmLnN0YXJ0KCdyZWZyZXNoRGF0YScsIGluc3RhbmNlSWQpXG4gICAgcmVzdWx0ID0gaW5zdGFuY2UucmVmcmVzaERhdGEoZGF0YSlcbiAgICBwZXJmLmVuZCgncmVmcmVzaERhdGEnLCBpbnN0YW5jZUlkKVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0YW5jZSBpZCBcIiR7aW5zdGFuY2VJZH1cImApXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIGRlc3Ryb3kgYSBXZWV4IGluc3RhbmNlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGluc3RhbmNlSWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lJbnN0YW5jZShpbnN0YW5jZUlkKSB7XG4gIHZhciBpbnN0YW5jZSA9IGluc3RhbmNlTWFwW2luc3RhbmNlSWRdXG4gIGlmICghaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKGBpbnZhbGlkIGluc3RhbmNlIGlkIFwiJHtpbnN0YW5jZUlkfVwiYClcbiAgfVxuXG4gIHBlcmYuc3RhcnQoJ2Rlc3Ryb3lJbnN0YW5jZScsIGluc3RhbmNlSWQpXG4gIGluc3RhbmNlLmRlc3Ryb3koKVxuICBkZWxldGUgaW5zdGFuY2VNYXBbaW5zdGFuY2VJZF1cbiAgcGVyZi5lbmQoJ2Rlc3Ryb3lJbnN0YW5jZScsIGluc3RhbmNlSWQpXG5cbiAgcmV0dXJuIGluc3RhbmNlTWFwXG59XG5cbi8qKlxuICogcmVnaXN0ZXIgdGhlIG5hbWUgb2YgZWFjaCBuYXRpdmUgY29tcG9uZW50XG4gKiBAcGFyYW0gIHthcnJheX0gY29tcG9uZW50cyBhcnJheSBvZiBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckNvbXBvbmVudHMoY29tcG9uZW50cykge1xuICBpZiAoQXJyYXkuaXNBcnJheShjb21wb25lbnRzKSkge1xuICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiByZWdpc3RlcihuYW1lKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghbmFtZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmF0aXZlQ29tcG9uZW50TWFwW25hbWVdID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG5hbWUudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmF0aXZlQ29tcG9uZW50TWFwW25hbWUudHlwZV0gPSBuYW1lXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIHJlZ2lzdGVyIHRoZSBuYW1lIGFuZCBtZXRob2RzIG9mIGVhY2ggbW9kdWxlXG4gKiBAcGFyYW0gIHtvYmplY3R9IG1vZHVsZXMgYSBvYmplY3Qgb2YgbW9kdWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJNb2R1bGVzKG1vZHVsZXMpIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnb2JqZWN0Jykge1xuICAgIFZtLnJlZ2lzdGVyTW9kdWxlcyhtb2R1bGVzKVxuICB9XG59XG5cbi8qKlxuICogcmVnaXN0ZXIgdGhlIG5hbWUgYW5kIG1ldGhvZHMgb2YgZWFjaCBhcGlcbiAqIEBwYXJhbSAge29iamVjdH0gYXBpcyBhIG9iamVjdCBvZiBhcGlzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlck1ldGhvZHMoYXBpcykge1xuICBpZiAodHlwZW9mIGFwaXMgPT09ICdvYmplY3QnKSB7XG4gICAgVm0ucmVnaXN0ZXJNZXRob2RzKGFwaXMpXG4gIH1cbn1cblxuLyoqXG4gKiBnZXQgYSB3aG9sZSBlbGVtZW50IHRyZWUgb2YgYW4gaW5zdGFuY2VcbiAqIGZvciBkZWJ1Z2dpbmdcbiAqIEBwYXJhbSAge3N0cmluZ30gaW5zdGFuY2VJZFxuICogQHJldHVybiB7b2JqZWN0fSBhIHZpcnR1YWwgZG9tIHRyZWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJvb3QoaW5zdGFuY2VJZCkge1xuICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZU1hcFtpbnN0YW5jZUlkXVxuICB2YXIgcmVzdWx0XG4gIGlmIChpbnN0YW5jZSkge1xuICAgIHJlc3VsdCA9IGluc3RhbmNlLmdldFJvb3RFbGVtZW50KClcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBuZXcgRXJyb3IoYGludmFsaWQgaW5zdGFuY2UgaWQgXCIke2luc3RhbmNlSWR9XCJgKVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxudmFyIGpzSGFuZGxlcnMgPSB7XG4gIGZpcmVFdmVudDogZnVuY3Rpb24gZmlyZUV2ZW50KGluc3RhbmNlSWQsIHJlZiwgdHlwZSwgZGF0YSkge1xuICAgIHZhciBpbnN0YW5jZSA9IGluc3RhbmNlTWFwW2luc3RhbmNlSWRdXG4gICAgdmFyIHJlc3VsdFxuICAgIHBlcmYuc3RhcnQoJ2ZpcmVFdmVudCcsIGluc3RhbmNlSWQgKyAnLScgKyByZWYgKyAnLScgKyB0eXBlKVxuICAgIHJlc3VsdCA9IGluc3RhbmNlLmZpcmVFdmVudChyZWYsIHR5cGUsIGRhdGEpXG4gICAgcGVyZi5lbmQoJ2ZpcmVFdmVudCcsIGluc3RhbmNlSWQgKyAnLScgKyByZWYgKyAnLScgKyB0eXBlKVxuICAgIHJldHVybiByZXN1bHRcbiAgfSxcblxuICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2soaW5zdGFuY2VJZCwgZnVuY0lkLCBkYXRhLCBpZkxhc3QpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZU1hcFtpbnN0YW5jZUlkXVxuICAgIHZhciByZXN1bHRcbiAgICBwZXJmLnN0YXJ0KCdjYWxsYmFjaycsXG4gICAgICBpbnN0YW5jZUlkICsgJy0nICsgZnVuY0lkICsgJy0nICsgZGF0YSArICctJyArIGlmTGFzdClcbiAgICByZXN1bHQgPSBpbnN0YW5jZS5jYWxsYmFjayhmdW5jSWQsIGRhdGEsIGlmTGFzdClcbiAgICBwZXJmLmVuZCgnY2FsbGJhY2snLFxuICAgICAgaW5zdGFuY2VJZCArICctJyArIGZ1bmNJZCArICctJyArIGRhdGEgKyAnLScgKyBpZkxhc3QpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qKlxuICogYWNjZXB0IGNhbGxzIGZyb20gbmF0aXZlIChldmVudCBvciBjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGluc3RhbmNlSWRcbiAqIEBwYXJhbSAge2FycmF5fSB0YXNrcyBsaXN0IHdpdGggYG1ldGhvZGAgYW5kIGBhcmdzYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsbEpTKGluc3RhbmNlSWQsIHRhc2tzKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VNYXBbaW5zdGFuY2VJZF1cbiAgbGV0IHJlc3VsdHMgPSBbXVxuICBpZiAoaW5zdGFuY2UgJiYgQXJyYXkuaXNBcnJheSh0YXNrcykpIHtcbiAgICB0YXNrcy5mb3JFYWNoKCh0YXNrKSA9PiB7XG4gICAgICBjb25zdCBoYW5kbGVyID0ganNIYW5kbGVyc1t0YXNrLm1ldGhvZF1cbiAgICAgIGNvbnN0IGFyZ3MgPSBbLi4udGFzay5hcmdzXVxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxvZygnamF2YXNjcmlwdDonLCB0YXNrLm1ldGhvZCwgdGFzay5hcmdzKVxuICAgICAgICBhcmdzLnVuc2hpZnQoaW5zdGFuY2VJZClcbiAgICAgICAgcmVzdWx0cy5wdXNoKGhhbmRsZXIoLi4uYXJncykpXG4gICAgICB9XG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICByZXN1bHRzLnB1c2gobmV3IEVycm9yKGBpbnZhbGlkIGluc3RhbmNlIGlkIFwiJHtpbnN0YW5jZUlkfVwiIG9yIHRhc2tzYCkpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0c1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9saWIvZnJhbWV3b3JrLmpzXG4gKiovIiwiaW1wb3J0IGxvZyBmcm9tICcuL2xvZydcblxudmFyIGRhdGEgPSB7dHlwZTogJ3Jvb3QnLCBjaGlsZHJlbjogW119XG52YXIgY3VycmVudCA9IGRhdGFcbnZhciBzdGFjayA9IFtjdXJyZW50XVxuXG5mdW5jdGlvbiBzcGFjZXMobnVtKSB7XG4gIHJldHVybiBBcnJheShudW0pLmpvaW4oJyAnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnQodHlwZSwgaWQpIHtcbiAgdmFyIHRhc2sgPSB7dHlwZTogdHlwZSwgaWQ6IGlkLCBjaGlsZHJlbjogW10sIHN0YXJ0OiBEYXRlLm5vdygpfVxuICBjdXJyZW50LmNoaWxkcmVuLnB1c2godGFzaylcbiAgc3RhY2sucHVzaCh0YXNrKVxuICBjdXJyZW50ID0gdGFza1xuICBsb2coJ3BlcmY6JyArIHNwYWNlcyhzdGFjay5sZW5ndGggLSAxKSwgJ3N0YXJ0JywgdGFzay50eXBlLCB0YXNrLmlkKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5kKHR5cGUsIGlkKSB7XG4gIHZhciB0YXNrID0gc3RhY2sucG9wKClcbiAgdGFzay5lbmQgPSBEYXRlLm5vdygpXG4gIGN1cnJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXVxuICBsb2coJ3BlcmY6JyArIHNwYWNlcyhzdGFjay5sZW5ndGgpLCAnZW5kJyxcbiAgICAodGFzay5lbmQgLSB0YXNrLnN0YXJ0KSArICdtcycsIHRhc2sudHlwZSwgdGFzay5pZClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KCkge1xuICBkYXRhLmNoaWxkcmVuID0gW11cbiAgY3VycmVudCA9IGRhdGFcbiAgc3RhY2subGVuZ3RoID0gMFxuICBzdGFjay5wdXNoKGN1cnJlbnQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0pTT04oKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpKVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9saWIvcGVyZi5qc1xuICoqLyIsImltcG9ydCAqIGFzIGNvbmZpZyBmcm9tICcuL2NvbmZpZydcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbG9nKC4uLmFyZ3MpIHtcbiAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgIGdsb2JhbC5jb25zb2xlLmxvZyguLi5hcmdzKVxuICB9XG59XG5cbmdsb2JhbC5sb2cgPSBsb2dcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2xpYi9sb2cuanNcbiAqKi8iLCJleHBvcnQgY29uc3QgbmF0aXZlQ29tcG9uZW50TWFwID0ge1xuICB0ZXh0OiB0cnVlLFxuICBpbWFnZTogdHJ1ZSxcbiAgY29udGFpbmVyOiB0cnVlLFxuICBzbGlkZXI6IHtcbiAgICB0eXBlOiAnc2xpZGVyJyxcbiAgICBhcHBlbmQ6ICd0cmVlJ1xuICB9LFxuICBjZWxsOiB7XG4gICAgdHlwZTogJ2NlbGwnLFxuICAgIGFwcGVuZDogJ3RyZWUnXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGN1c3RvbUNvbXBvbmVudE1hcCA9IHt9XG5cbmV4cG9ydCB2YXIgZGVidWcgPSBmYWxzZVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2xpYi9jb25maWcuanNcbiAqKi8iLCIvKipcbiAqIEBmaWxlT3ZlcnZpZXdcbiAqIFdlZXggaW5zdGFuY2UgY29uc3RydWN0b3IgJiBkZWZpbml0aW9uXG4gKi9cblxuaW1wb3J0IHt0eXBvZiwgZXh0ZW5kfSBmcm9tICcuLi91dGlsJ1xuaW1wb3J0ICogYXMgcGVyZiBmcm9tICcuLi9wZXJmJ1xuaW1wb3J0ICogYXMgYnVuZGxlIGZyb20gJy4vYnVuZGxlJ1xuaW1wb3J0ICogYXMgY3RybCBmcm9tICcuL2N0cmwnXG5pbXBvcnQgRGlmZmVyIGZyb20gJy4vZGlmZmVyJ1xuXG5pbXBvcnQgRXZlbnRNYW5hZ2VyIGZyb20gJy4vZXZlbnQnXG5pbXBvcnQgTGlzdGVuZXIgZnJvbSAnLi9kb20tbGlzdGVuZXInXG5pbXBvcnQge0RvY3VtZW50LCBOb2RlfSBmcm9tICcuL2RvbSdcbmltcG9ydCB7cmVnaXN0ZXJDb21wb25lbnQsIHJlcXVpcmVDb21wb25lbnQsIHJlcXVpcmVNb2R1bGV9IGZyb20gJy4vcmVnaXN0ZXInXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFwcEluc3RhbmNlKGluc3RhbmNlSWQsIG9wdGlvbnMpIHtcbiAgcGVyZi5zdGFydCgnaW5pdEluc3RhbmNlJywgaW5zdGFuY2VJZClcbiAgdGhpcy5pZCA9IGluc3RhbmNlSWRcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB0aGlzLnZtID0gbnVsbFxuICB0aGlzLmRvYyA9IG5ldyBEb2N1bWVudChpbnN0YW5jZUlkKVxuICB0aGlzLmN1c3RvbUNvbXBvbmVudE1hcCA9IHt9XG4gIHRoaXMuY2FsbGJhY2tzID0ge31cbiAgdGhpcy5kaWZmZXIgPSBuZXcgRGlmZmVyKGluc3RhbmNlSWQpXG4gIHRoaXMudWlkID0gMFxuICB0aGlzLnJlbmRlcmVkID0gZmFsc2VcbiAgdGhpcy5ldmVudE1hbmFnZXIgPSBuZXcgRXZlbnRNYW5hZ2VyKClcbiAgdGhpcy5saXN0ZW5lciA9IG5ldyBMaXN0ZW5lcih0aGlzLmlkLCAodGFza3MpID0+IHtcbiAgICB0aGlzLmNhbGxUYXNrcyh0YXNrcylcbiAgfSlcbiAgdGhpcy5kb2Muc2V0RXZlbnRNYW5hZ2VyKHRoaXMuZXZlbnRNYW5hZ2VyKVxuICB0aGlzLmRvYy5zZXRMaXN0ZW5lcih0aGlzLmxpc3RlbmVyKVxuXG4gIHBlcmYuZW5kKCdpbml0SW5zdGFuY2UnLCBpbnN0YW5jZUlkKVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemUoYXBwLCB2KSB7XG4gIHZhciB0eXBlID0gdHlwb2YodilcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgIGNhc2UgJ251bGwnOlxuICAgICAgcmV0dXJuICcnXG4gICAgY2FzZSAncmVnZXhwJzpcbiAgICAgIHJldHVybiB2LnRvU3RyaW5nKClcbiAgICBjYXNlICdkYXRlJzpcbiAgICAgIHJldHVybiB2LnRvSVNPU3RyaW5nKClcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnYXJyYXknOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAodiBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHYucmVmXG4gICAgICB9XG4gICAgICByZXR1cm4gdlxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIGFwcC5jYWxsYmFja3NbKythcHAudWlkXSA9IHZcbiAgICAgIHJldHVybiBhcHAudWlkLnRvU3RyaW5nKClcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpXG4gIH1cbn1cblxuQXBwSW5zdGFuY2UucHJvdG90eXBlLmNhbGxUYXNrcyA9IGZ1bmN0aW9uICh0YXNrcykge1xuICBpZiAodHlwb2YodGFza3MpICE9PSAnYXJyYXknKSB7XG4gICAgdGFza3MgPSBbdGFza3NdXG4gIH1cblxuICB0YXNrcy5mb3JFYWNoKCh0YXNrKSA9PiB7XG4gICAgdGFzay5hcmdzID0gdGFzay5hcmdzLm1hcChhcmcgPT4gbm9ybWFsaXplKHRoaXMsIGFyZykpXG4gIH0pXG5cbiAgY2FsbE5hdGl2ZSh0aGlzLmlkLCB0YXNrcywgJy0xJylcbn1cblxuZXh0ZW5kKEFwcEluc3RhbmNlLnByb3RvdHlwZSwgYnVuZGxlLCBjdHJsLCB7XG4gIHJlZ2lzdGVyQ29tcG9uZW50LFxuICByZXF1aXJlQ29tcG9uZW50LFxuICByZXF1aXJlTW9kdWxlXG59KVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9saWIvYXBwL2luZGV4LmpzXG4gKiovIiwiLy8vIGxhbmcuanNcbmltcG9ydCBDb25maWcgZnJvbSAnLi4vY29uZmlnJ1xuXG4vKipcbiAqIENoZWNrIGlzIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0IHZhciBpc1Jlc2VydmVkID0gKHN0cikgPT4ge1xuICBzdHIgKz0gJydcbiAgbGV0IGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMClcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbG1pdGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxubGV0IGNhbWVsUkUgPSAvLShcXHcpL2dcbmZ1bmN0aW9uIHRvVXBwZXIgKF8sIGMpIHtcbiAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlICgpIDogJydcbn1cbmV4cG9ydCB2YXIgY2FtZWxpemUgPSAoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbFJFLCB0b1VwcGVyKVxufVxuXG4vKipcbiAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGN0eFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZXhwb3J0IHZhciBiaW5kID0gZnVuY3Rpb24gKGZuLCBjdHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgbGV0IGwgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LWxpa2V9IGxpc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRdIC0gc3RhcnQgaW5kZXhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmV4cG9ydCB2YXIgdG9BcnJheSA9IChsaXN0LCBzdGFydCkgPT4ge1xuICBzdGFydCA9IHN0YXJ0IHx8IDBcbiAgbGV0IGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0XG4gIGxldCByZXQgPSBuZXcgQXJyYXkoaSlcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gZnJvbVxuICovXG5cbmV4cG9ydCB2YXIgZXh0ZW5kID0gKHRhcmdldCwgLi4uc3JjKSA9PiB7XG4gIGlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCAuLi5zcmMpXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZmlyc3QgPSBzcmMuc2hpZnQoKVxuICAgIGZvciAoY29uc3Qga2V5IGluIGZpcnN0KSB7XG4gICAgICB0YXJnZXRba2V5XSA9IGZpcnN0W2tleV1cbiAgICB9XG4gICAgaWYgKHNyYy5sZW5ndGgpIHtcbiAgICAgIGV4dGVuZCh0YXJnZXQsIC4uLnNyYylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldFxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmV4cG9ydCB2YXIgaXNPYmplY3QgPSAob2JqKSA9PiB7XG4gIHJldHVybiAhIShvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5sZXQgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5leHBvcnQgdmFyIGlzUGxhaW5PYmplY3QgPSAob2JqKSA9PiB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbi8qKlxuICogQXJyYXkgdHlwZSBjaGVjay5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnQgdmFyIGlzQXJyYXkgPSAob2JqKSA9PiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9iailcbn1cblxuZXhwb3J0IHZhciBzdHJpbmdpZnkgPSAoeCkgPT4ge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICd1bmRlZmluZWQnIHx8IHggPT09IG51bGwgfHwgdHlwZW9mKHgpID09PSAnZnVuY3Rpb24nXG4gICAgPyAnJ1xuICAgIDogdHlwZW9mIHggPT09ICdvYmplY3QnXG4gICAgICA/IHggaW5zdGFuY2VvZiBSZWdFeHBcbiAgICAgICAgPyB4LnRvU3RyaW5nKClcbiAgICAgICAgOiB4IGluc3RhbmNlb2YgRGF0ZVxuICAgICAgICAgID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh4KSlcbiAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHgpXG4gICAgICA6IHgudG9TdHJpbmcoKVxufVxuXG5leHBvcnQgdmFyIHR5cG9mID0gKHYpID0+IHtcbiAgbGV0IHMgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodilcbiAgcmV0dXJuIHMuc3Vic3RyaW5nKDgsIHMubGVuZ3RoIC0gMSkudG9Mb3dlckNhc2UoKVxufVxuXG5leHBvcnQgdmFyIG5vcm1hbGl6ZSA9ICh2KSA9PiB7XG4gIGxldCB0eXBlID0gdHlwb2YodilcblxuICBzd2l0Y2godHlwZSkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgY2FzZSAnbnVsbCc6XG4gICAgICByZXR1cm4gJydcbiAgICBjYXNlICdyZWdleHAnOlxuICAgICAgcmV0dXJuIHYudG9TdHJpbmcoKVxuICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgcmV0dXJuIHYudG9JU09TdHJpbmcoKVxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICBjYXNlICdhcnJheSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gdlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodilcbiAgfVxufVxuXG4vKipcbiAqIERlZmluZSBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VudW1lcmFibGVdXG4gKi9cblxuZXhwb3J0IHZhciBkZWZpbmUgPSAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbn1cblxuLyoqXG4gKiBNYW51YWwgaW5kZXhPZiBiZWNhdXNlIGl0J3Mgc2xpZ2h0bHkgZmFzdGVyIHRoYW5cbiAqIG5hdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKi9cblxuZXhwb3J0IHZhciBpbmRleE9mID0gKGFyciwgb2JqKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGlcbiAgfVxuICByZXR1cm4gLTFcbn1cblxuXG4vLy8gZGVidWcuanNcblxuXG5jb25zdCBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG5cbi8qKlxuICogTG9nIGEgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnXG4gKi9cblxuZXhwb3J0IHZhciBsb2cgPSAobXNnKSA9PiB7XG4gIGNvbnN0IF9jb25maWcgPSBDb25maWcgfHwge31cbiAgaWYgKGhhc0NvbnNvbGUgJiYgX2NvbmZpZy5kZWJ1Zykge1xuICAgIGNvbnNvbGUubG9nLmNhbGwodGhpcywgJ1tpbmZvXTogJywgbXNnKVxuICB9XG59XG5cbi8qKlxuICogV2UndmUgZ290IGEgcHJvYmxlbSBoZXJlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2dcbiAqL1xuXG5leHBvcnQgdmFyIHdhcm4gPSAobXNnKSA9PiB7XG4gIC8vIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCB8fCBjb25maWcuZGVidWcpKSB7XG4gIGlmIChoYXNDb25zb2xlKSB7XG4gICAgY29uc29sZS53YXJuLmNhbGwodGhpcywgJ1t3YXJuXTogJywgbXNnKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIC8vIGlmIChjb25maWcuZGVidWcpIHtcbiAgICAvLyAgIC8qIGpzaGludCBkZWJ1ZzogdHJ1ZSAqL1xuICAgIC8vICAgZGVidWdnZXJcbiAgICAvLyB9XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL3V0aWwvaW5kZXguanNcbiAqKi8iLCIvKipcbiAqIEBmaWxlT3ZlcnZpZXdcbiAqIGFwaSB0aGF0IGludm9rZWQgYnkganMgYnVuZGxlIGNvZGVcbiAqXG4gKiAtIGRlZmluZShuYW1lLCBmYWN0b3J5KTogZGVmaW5lIGEgbmV3IGNvbXBvc2VkIGNvbXBvbmVudCB0eXBlXG4gKiAtIGJvb3RzdHJhcCh0eXBlLCBjb25maWcsIGRhdGEpOiByZXF1aXJlIGEgY2VydGFpbiB0eXBlICZcbiAqICAgICAgICAgcmVuZGVyIHdpdGggKG9wdGlvbmFsKSBkYXRhXG4gKlxuICogZGVwcmVjYXRlZDpcbiAqIC0gcmVnaXN0ZXIodHlwZSwgb3B0aW9ucyk6IHJlZ2lzdGVyIGEgbmV3IGNvbXBvc2VkIGNvbXBvbmVudCB0eXBlXG4gKiAtIHJlbmRlcih0eXBlLCBkYXRhKTogcmVuZGVyIGJ5IGEgY2VydGFpbiB0eXBlIHdpdGggKG9wdGlvbmFsKSBkYXRhXG4gKiAtIHJlcXVpcmUodHlwZSkoZGF0YSk6IHJlcXVpcmUgYSB0eXBlIHRoZW4gcmVuZGVyIHdpdGggZGF0YVxuICovXG5cbmltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJ1xuaW1wb3J0ICogYXMgXyBmcm9tICcuLi91dGlsJ1xuaW1wb3J0ICogYXMgY29uZmlnIGZyb20gJy4uL2NvbmZpZydcbmltcG9ydCAqIGFzIHBlcmYgZnJvbSAnLi4vcGVyZidcbmltcG9ydCBWbSBmcm9tICcuLi92bSdcbmltcG9ydCAqIGFzIGRvd25ncmFkZSBmcm9tICcuL2Rvd25ncmFkZSdcblxuY29uc3QgV0VFWF9DT01QT05FTlRfUkVHID0gL15cXEB3ZWV4LWNvbXBvbmVudFxcLy9cbmNvbnN0IFdFRVhfTU9EVUxFX1JFRyA9IC9eXFxAd2VleC1tb2R1bGVcXC8vXG5jb25zdCBOT1JNQUxfTU9EVUxFX1JFRyA9IC9eXFwuezEsMn1cXC8vXG5jb25zdCBKU19TVVJGSVhfUkVHID0gL1xcLmpzJC9cblxuY29uc3QgaXNXZWV4Q29tcG9uZW50ID0gbmFtZSA9PiAhIW5hbWUubWF0Y2goV0VFWF9DT01QT05FTlRfUkVHKVxuY29uc3QgaXNXZWV4TW9kdWxlID0gbmFtZSA9PiAhIW5hbWUubWF0Y2goV0VFWF9NT0RVTEVfUkVHKVxuY29uc3QgaXNOb3JtYWxNb2R1bGUgPSBuYW1lID0+ICEhbmFtZS5tYXRjaChOT1JNQUxfTU9EVUxFX1JFRylcbmNvbnN0IGlzTnBtTW9kdWxlID0gbmFtZSA9PiAhaXNXZWV4Q29tcG9uZW50KG5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXNXZWV4TW9kdWxlKG5hbWUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXNOb3JtYWxNb2R1bGUobmFtZSlcblxuZnVuY3Rpb24gcmVtb3ZlV2VleFByZWZpeChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFdFRVhfQ09NUE9ORU5UX1JFRywgJycpXG4gICAgICAgICAgLnJlcGxhY2UoV0VFWF9NT0RVTEVfUkVHLCAnJylcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSlNTdXJmaXgoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShKU19TVVJGSVhfUkVHLCAnJylcbn1cblxubGV0IGNvbW1vbk1vZHVsZXMgPSB7fVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDb21tb25Nb2R1bGVzKCkge1xuICBjb21tb25Nb2R1bGVzID0ge31cbn1cblxuLy8gZGVmaW5lKG5hbWUsIGZhY3RvcnkpIGZvciBwcmltYXJ5IHVzYWdlXG4vLyBvclxuLy8gZGVmaW5lKG5hbWUsIGRlcHMsIGZhY3RvcnkpIGZvciBjb21wYXRpYmlsaXR5XG4vLyBOb3RpY2U6IERPIE5PVCB1c2UgZnVuY3Rpb24gZGVmaW5lKCkge30sXG4vLyBpdCB3aWxsIGNhdXNlIGVycm9yIGFmdGVyIGJ1aWxkZWQgYnkgd2VicGFja1xuZXhwb3J0IHZhciBkZWZpbmUgPSBmdW5jdGlvbiAobmFtZSwgZGVwcywgZmFjdG9yeSkge1xuICBwZXJmLnN0YXJ0KCdkZWZpbmUnLCBuYW1lKVxuXG4gIGlmIChfLnR5cG9mKGRlcHMpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZmFjdG9yeSA9IGRlcHNcbiAgICBkZXBzID0gW11cbiAgfVxuXG4gIGxldCBfcmVxdWlyZSA9IChuYW1lKSA9PiB7XG4gICAgbGV0IGNsZWFuTmFtZVxuXG4gICAgaWYgKGlzV2VleENvbXBvbmVudChuYW1lKSkge1xuICAgICAgY2xlYW5OYW1lID0gcmVtb3ZlV2VleFByZWZpeChuYW1lKVxuICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZUNvbXBvbmVudChjbGVhbk5hbWUpXG4gICAgfVxuICAgIGlmIChpc1dlZXhNb2R1bGUobmFtZSkpIHtcbiAgICAgIGNsZWFuTmFtZSA9IHJlbW92ZVdlZXhQcmVmaXgobmFtZSlcbiAgICAgIHJldHVybiB0aGlzLnJlcXVpcmVNb2R1bGUoY2xlYW5OYW1lKVxuICAgIH1cbiAgICBpZiAoaXNOb3JtYWxNb2R1bGUobmFtZSkpIHtcbiAgICAgIGNsZWFuTmFtZSA9IHJlbW92ZUpTU3VyZml4KG5hbWUpXG4gICAgICByZXR1cm4gY29tbW9uTW9kdWxlc1tuYW1lXVxuICAgIH1cbiAgICBpZiAoaXNOcG1Nb2R1bGUobmFtZSkpIHtcbiAgICAgIGNsZWFuTmFtZSA9IHJlbW92ZUpTU3VyZml4KG5hbWUpXG4gICAgICByZXR1cm4gY29tbW9uTW9kdWxlc1tuYW1lXVxuICAgIH1cbiAgfVxuICBsZXQgX21vZHVsZSA9IHtleHBvcnRzOiB7fX1cblxuICBsZXQgY2xlYW5OYW1lXG4gIGlmIChpc1dlZXhDb21wb25lbnQobmFtZSkpIHtcbiAgICBjbGVhbk5hbWUgPSByZW1vdmVXZWV4UHJlZml4KG5hbWUpXG5cbiAgICBmYWN0b3J5KF9yZXF1aXJlLCBfbW9kdWxlLmV4cG9ydHMsIF9tb2R1bGUpXG5cbiAgICB0aGlzLnJlZ2lzdGVyQ29tcG9uZW50KGNsZWFuTmFtZSwgX21vZHVsZS5leHBvcnRzKVxuICB9IGVsc2UgaWYgKGlzV2VleE1vZHVsZShuYW1lKSkge1xuICAgIGNsZWFuTmFtZSA9IHJlbW92ZVdlZXhQcmVmaXgobmFtZSlcblxuICAgIGZhY3RvcnkoX3JlcXVpcmUsIF9tb2R1bGUuZXhwb3J0cywgX21vZHVsZSlcblxuICAgIFZtLnJlZ2lzdGVyTW9kdWxlcyh7XG4gICAgICBbY2xlYW5OYW1lXTogX21vZHVsZS5leHBvcnRzXG4gICAgfSlcbiAgfSBlbHNlIGlmIChpc05vcm1hbE1vZHVsZShuYW1lKSkge1xuICAgIGNsZWFuTmFtZSA9IHJlbW92ZUpTU3VyZml4KG5hbWUpXG5cbiAgICBmYWN0b3J5KF9yZXF1aXJlLCBfbW9kdWxlLmV4cG9ydHMsIF9tb2R1bGUpXG5cbiAgICBjb21tb25Nb2R1bGVzW2NsZWFuTmFtZV0gPSBfbW9kdWxlLmV4cG9ydHNcbiAgfSBlbHNlIGlmIChpc05wbU1vZHVsZShuYW1lKSkge1xuICAgIGNsZWFuTmFtZSA9IHJlbW92ZUpTU3VyZml4KG5hbWUpXG5cbiAgICBmYWN0b3J5KF9yZXF1aXJlLCBfbW9kdWxlLmV4cG9ydHMsIF9tb2R1bGUpXG5cbiAgICBsZXQgZXhwb3J0cyA9IF9tb2R1bGUuZXhwb3J0c1xuICAgIGlmIChleHBvcnRzLnRlbXBsYXRlIHx8XG4gICAgICAgIGV4cG9ydHMuc3R5bGUgfHxcbiAgICAgICAgZXhwb3J0cy5tZXRob2RzKSB7XG4gICAgICAvLyBkb3duZ3JhZGUgdG8gb2xkIGRlZmluZSBtZXRob2QgKGRlZmluZSgnY29tcG9uZW50TmFtZScsIGZhY3RvcnkpKVxuICAgICAgLy8gdGhlIGV4cG9ydHMgY29udGFpbiBvbmUga2V5IG9mIHRlbXBsYXRlLCBzdHlsZSBvciBtZXRob2RzXG4gICAgICAvLyBidXQgaXQgaGFzIHJpc2shISFcbiAgICAgIHRoaXMucmVnaXN0ZXJDb21wb25lbnQoY2xlYW5OYW1lLCBleHBvcnRzKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21tb25Nb2R1bGVzW2NsZWFuTmFtZV0gPSBfbW9kdWxlLmV4cG9ydHNcbiAgICB9XG4gIH1cblxuICBwZXJmLmVuZCgnZGVmaW5lJywgbmFtZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJvb3RzdHJhcChuYW1lLCBjb25maWcsIGRhdGEpIHtcbiAgbGV0IGNsZWFuTmFtZVxuXG4gIGlmIChpc1dlZXhDb21wb25lbnQobmFtZSkpIHtcbiAgICBjbGVhbk5hbWUgPSByZW1vdmVXZWV4UHJlZml4KG5hbWUpXG4gIH0gZWxzZSBpZiAoaXNOcG1Nb2R1bGUobmFtZSkpIHtcbiAgICBjbGVhbk5hbWUgPSByZW1vdmVKU1N1cmZpeChuYW1lKVxuICAgIC8vIGNoZWNrIGlmIGRlZmluZSBieSBvbGQgJ2RlZmluZScgbWV0aG9kXG4gICAgaWYgKCF0aGlzLmN1c3RvbUNvbXBvbmVudE1hcFtjbGVhbk5hbWVdKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKGBJdCdzIG5vdCBhIGNvbXBvbmVudDogJHtuYW1lfWApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgRXJyb3IoYFdyb25nIGNvbXBvbmVudCBuYW1lOiAke25hbWV9YClcbiAgfVxuXG4gIGNvbmZpZyA9IF8uaXNQbGFpbk9iamVjdChjb25maWcpID8gY29uZmlnIDoge31cblxuICBpZiAodHlwZW9mIGNvbmZpZy50cmFuc2Zvcm1lclZlcnNpb24gPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIGdsb2JhbC5uZWVkVHJhbnNmb3JtZXJWZXJzaW9uID09PSAnc3RyaW5nJyAmJlxuICAgICFzZW12ZXIuc2F0aXNmaWVzKGNvbmZpZy50cmFuc2Zvcm1lclZlcnNpb24sXG4gICAgICBnbG9iYWwubmVlZFRyYW5zZm9ybWVyVmVyc2lvbikpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKGBKUyBCdW5kbGUgdmVyc2lvbjogJHtjb25maWcudHJhbnNmb3JtZXJWZXJzaW9ufSBgICtcbiAgICAgIGBub3QgY29tcGF0aWJsZSB3aXRoICR7Z2xvYmFsLm5lZWRUcmFuc2Zvcm1lclZlcnNpb259YClcbiAgfVxuXG4gIGxldCBfY2hlY2tEb3duZ3JhZGUgPSBkb3duZ3JhZGUuY2hlY2soY29uZmlnLmRvd25ncmFkZSlcbiAgaWYgKF9jaGVja0Rvd25ncmFkZS5pc0Rvd25ncmFkZSkge1xuICAgIHRoaXMuY2FsbFRhc2tzKFt7XG4gICAgICBtb2R1bGU6ICdpbnN0YW5jZVdyYXAnLFxuICAgICAgbWV0aG9kOiAnZXJyb3InLFxuICAgICAgYXJnczogW1xuICAgICAgICBfY2hlY2tEb3duZ3JhZGUuZXJyb3JUeXBlLFxuICAgICAgICBfY2hlY2tEb3duZ3JhZGUuY29kZSxcbiAgICAgICAgX2NoZWNrRG93bmdyYWRlLmVycm9yTWVzc2FnZVxuICAgICAgXVxuICAgIH1dKVxuICAgIHJldHVybiBuZXcgRXJyb3IoYERvd25ncmFkZTogJHtjb25maWcuZG93bmdyYWRlfWApXG4gIH1cblxuICBwZXJmLnN0YXJ0KCdjcmVhdGUgdm0nLCBjbGVhbk5hbWUpXG5cbiAgdGhpcy52bSA9IG5ldyBWbShjbGVhbk5hbWUsIHtfYXBwOiB0aGlzfSwgbnVsbCwgZGF0YSwge1xuICAgICdob29rOnJlYWR5JzogKCkgPT4ge1xuICAgICAgcGVyZi5lbmQoJ2NyZWF0ZSB2bScsIGNsZWFuTmFtZSlcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyKHR5cGUsIG9wdGlvbnMpIHtcbiAgcGVyZi5zdGFydCgncmVnaXN0ZXInLCB0eXBlKVxuICB0aGlzLnJlZ2lzdGVyQ29tcG9uZW50KHR5cGUsIG9wdGlvbnMpXG4gIHBlcmYuZW5kKCdyZWdpc3RlcicsIHR5cGUpXG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcih0eXBlLCBkYXRhKSB7XG4gIHJldHVybiB0aGlzLmJvb3RzdHJhcCh0eXBlLCB7fSwgZGF0YSlcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVxdWlyZSh0eXBlKSB7XG4gIHJldHVybiAoZGF0YSkgPT4ge1xuICAgIHJldHVybiB0aGlzLmJvb3RzdHJhcCh0eXBlLCB7fSwgZGF0YSlcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9saWIvYXBwL2J1bmRsZS5qc1xuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFNlbVZlcjtcblxuLy8gVGhlIGRlYnVnIGZ1bmN0aW9uIGlzIGV4Y2x1ZGVkIGVudGlyZWx5IGZyb20gdGhlIG1pbmlmaWVkIHZlcnNpb24uXG4vKiBub21pbiAqLyB2YXIgZGVidWc7XG4vKiBub21pbiAqLyBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gICAgLyogbm9taW4gKi8gcHJvY2Vzcy5lbnYgJiZcbiAgICAvKiBub21pbiAqLyBwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmXG4gICAgLyogbm9taW4gKi8gL1xcYnNlbXZlclxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykpXG4gIC8qIG5vbWluICovIGRlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgLyogbm9taW4gKi8gdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIC8qIG5vbWluICovIGFyZ3MudW5zaGlmdCgnU0VNVkVSJyk7XG4gICAgLyogbm9taW4gKi8gY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgLyogbm9taW4gKi8gfTtcbi8qIG5vbWluICovIGVsc2VcbiAgLyogbm9taW4gKi8gZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuXG4vLyBOb3RlOiB0aGlzIGlzIHRoZSBzZW12ZXIub3JnIHZlcnNpb24gb2YgdGhlIHNwZWMgdGhhdCBpdCBpbXBsZW1lbnRzXG4vLyBOb3QgbmVjZXNzYXJpbHkgdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiB0aGlzIGNvZGUuXG5leHBvcnRzLlNFTVZFUl9TUEVDX1ZFUlNJT04gPSAnMi4wLjAnO1xuXG52YXIgTUFYX0xFTkdUSCA9IDI1NjtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcblxuLy8gVGhlIGFjdHVhbCByZWdleHBzIGdvIG9uIGV4cG9ydHMucmVcbnZhciByZSA9IGV4cG9ydHMucmUgPSBbXTtcbnZhciBzcmMgPSBleHBvcnRzLnNyYyA9IFtdO1xudmFyIFIgPSAwO1xuXG4vLyBUaGUgZm9sbG93aW5nIFJlZ3VsYXIgRXhwcmVzc2lvbnMgY2FuIGJlIHVzZWQgZm9yIHRva2VuaXppbmcsXG4vLyB2YWxpZGF0aW5nLCBhbmQgcGFyc2luZyBTZW1WZXIgdmVyc2lvbiBzdHJpbmdzLlxuXG4vLyAjIyBOdW1lcmljIElkZW50aWZpZXJcbi8vIEEgc2luZ2xlIGAwYCwgb3IgYSBub24temVybyBkaWdpdCBmb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgZGlnaXRzLlxuXG52YXIgTlVNRVJJQ0lERU5USUZJRVIgPSBSKys7XG5zcmNbTlVNRVJJQ0lERU5USUZJRVJdID0gJzB8WzEtOV1cXFxcZConO1xudmFyIE5VTUVSSUNJREVOVElGSUVSTE9PU0UgPSBSKys7XG5zcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gPSAnWzAtOV0rJztcblxuXG4vLyAjIyBOb24tbnVtZXJpYyBJZGVudGlmaWVyXG4vLyBaZXJvIG9yIG1vcmUgZGlnaXRzLCBmb2xsb3dlZCBieSBhIGxldHRlciBvciBoeXBoZW4sIGFuZCB0aGVuIHplcm8gb3Jcbi8vIG1vcmUgbGV0dGVycywgZGlnaXRzLCBvciBoeXBoZW5zLlxuXG52YXIgTk9OTlVNRVJJQ0lERU5USUZJRVIgPSBSKys7XG5zcmNbTk9OTlVNRVJJQ0lERU5USUZJRVJdID0gJ1xcXFxkKlthLXpBLVotXVthLXpBLVowLTktXSonO1xuXG5cbi8vICMjIE1haW4gVmVyc2lvblxuLy8gVGhyZWUgZG90LXNlcGFyYXRlZCBudW1lcmljIGlkZW50aWZpZXJzLlxuXG52YXIgTUFJTlZFUlNJT04gPSBSKys7XG5zcmNbTUFJTlZFUlNJT05dID0gJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJylcXFxcLicgK1xuICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUl0gKyAnKSc7XG5cbnZhciBNQUlOVkVSU0lPTkxPT1NFID0gUisrO1xuc3JjW01BSU5WRVJTSU9OTE9PU0VdID0gJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJylcXFxcLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJylcXFxcLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJyknO1xuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uIElkZW50aWZpZXJcbi8vIEEgbnVtZXJpYyBpZGVudGlmaWVyLCBvciBhIG5vbi1udW1lcmljIGlkZW50aWZpZXIuXG5cbnZhciBQUkVSRUxFQVNFSURFTlRJRklFUiA9IFIrKztcbnNyY1tQUkVSRUxFQVNFSURFTlRJRklFUl0gPSAnKD86JyArIHNyY1tOVU1FUklDSURFTlRJRklFUl0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd8JyArIHNyY1tOT05OVU1FUklDSURFTlRJRklFUl0gKyAnKSc7XG5cbnZhciBQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFID0gUisrO1xuc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdID0gJyg/OicgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3wnICsgc3JjW05PTk5VTUVSSUNJREVOVElGSUVSXSArICcpJztcblxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uXG4vLyBIeXBoZW4sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIGRvdC1zZXBhcmF0ZWQgcHJlLXJlbGVhc2UgdmVyc2lvblxuLy8gaWRlbnRpZmllcnMuXG5cbnZhciBQUkVSRUxFQVNFID0gUisrO1xuc3JjW1BSRVJFTEVBU0VdID0gJyg/Oi0oJyArIHNyY1tQUkVSRUxFQVNFSURFTlRJRklFUl0gK1xuICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuJyArIHNyY1tQUkVSRUxFQVNFSURFTlRJRklFUl0gKyAnKSopKSc7XG5cbnZhciBQUkVSRUxFQVNFTE9PU0UgPSBSKys7XG5zcmNbUFJFUkVMRUFTRUxPT1NFXSA9ICcoPzotPygnICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdICtcbiAgICAgICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuJyArIHNyY1tQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSArICcpKikpJztcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGEgSWRlbnRpZmllclxuLy8gQW55IGNvbWJpbmF0aW9uIG9mIGRpZ2l0cywgbGV0dGVycywgb3IgaHlwaGVucy5cblxudmFyIEJVSUxESURFTlRJRklFUiA9IFIrKztcbnNyY1tCVUlMRElERU5USUZJRVJdID0gJ1swLTlBLVphLXotXSsnO1xuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YVxuLy8gUGx1cyBzaWduLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBwZXJpb2Qtc2VwYXJhdGVkIGJ1aWxkIG1ldGFkYXRhXG4vLyBpZGVudGlmaWVycy5cblxudmFyIEJVSUxEID0gUisrO1xuc3JjW0JVSUxEXSA9ICcoPzpcXFxcKygnICsgc3JjW0JVSUxESURFTlRJRklFUl0gK1xuICAgICAgICAgICAgICcoPzpcXFxcLicgKyBzcmNbQlVJTERJREVOVElGSUVSXSArICcpKikpJztcblxuXG4vLyAjIyBGdWxsIFZlcnNpb24gU3RyaW5nXG4vLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4vLyBidWlsZCBtZXRhZGF0YS5cblxuLy8gTm90ZSB0aGF0IHRoZSBvbmx5IG1ham9yLCBtaW5vciwgcGF0Y2gsIGFuZCBwcmUtcmVsZWFzZSBzZWN0aW9ucyBvZlxuLy8gdGhlIHZlcnNpb24gc3RyaW5nIGFyZSBjYXB0dXJpbmcgZ3JvdXBzLiAgVGhlIGJ1aWxkIG1ldGFkYXRhIGlzIG5vdCBhXG4vLyBjYXB0dXJpbmcgZ3JvdXAsIGJlY2F1c2UgaXQgc2hvdWxkIG5vdCBldmVyIGJlIHVzZWQgaW4gdmVyc2lvblxuLy8gY29tcGFyaXNvbi5cblxudmFyIEZVTEwgPSBSKys7XG52YXIgRlVMTFBMQUlOID0gJ3Y/JyArIHNyY1tNQUlOVkVSU0lPTl0gK1xuICAgICAgICAgICAgICAgIHNyY1tQUkVSRUxFQVNFXSArICc/JyArXG4gICAgICAgICAgICAgICAgc3JjW0JVSUxEXSArICc/Jztcblxuc3JjW0ZVTExdID0gJ14nICsgRlVMTFBMQUlOICsgJyQnO1xuXG4vLyBsaWtlIGZ1bGwsIGJ1dCBhbGxvd3MgdjEuMi4zIGFuZCA9MS4yLjMsIHdoaWNoIHBlb3BsZSBkbyBzb21ldGltZXMuXG4vLyBhbHNvLCAxLjAuMGFscGhhMSAocHJlcmVsZWFzZSB3aXRob3V0IHRoZSBoeXBoZW4pIHdoaWNoIGlzIHByZXR0eVxuLy8gY29tbW9uIGluIHRoZSBucG0gcmVnaXN0cnkuXG52YXIgTE9PU0VQTEFJTiA9ICdbdj1cXFxcc10qJyArIHNyY1tNQUlOVkVSU0lPTkxPT1NFXSArXG4gICAgICAgICAgICAgICAgIHNyY1tQUkVSRUxFQVNFTE9PU0VdICsgJz8nICtcbiAgICAgICAgICAgICAgICAgc3JjW0JVSUxEXSArICc/JztcblxudmFyIExPT1NFID0gUisrO1xuc3JjW0xPT1NFXSA9ICdeJyArIExPT1NFUExBSU4gKyAnJCc7XG5cbnZhciBHVExUID0gUisrO1xuc3JjW0dUTFRdID0gJygoPzo8fD4pPz0/KSc7XG5cbi8vIFNvbWV0aGluZyBsaWtlIFwiMi4qXCIgb3IgXCIxLjIueFwiLlxuLy8gTm90ZSB0aGF0IFwieC54XCIgaXMgYSB2YWxpZCB4UmFuZ2UgaWRlbnRpZmVyLCBtZWFuaW5nIFwiYW55IHZlcnNpb25cIlxuLy8gT25seSB0aGUgZmlyc3QgaXRlbSBpcyBzdHJpY3RseSByZXF1aXJlZC5cbnZhciBYUkFOR0VJREVOVElGSUVSTE9PU0UgPSBSKys7XG5zcmNbWFJBTkdFSURFTlRJRklFUkxPT1NFXSA9IHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArICd8eHxYfFxcXFwqJztcbnZhciBYUkFOR0VJREVOVElGSUVSID0gUisrO1xuc3JjW1hSQU5HRUlERU5USUZJRVJdID0gc3JjW05VTUVSSUNJREVOVElGSUVSXSArICd8eHxYfFxcXFwqJztcblxudmFyIFhSQU5HRVBMQUlOID0gUisrO1xuc3JjW1hSQU5HRVBMQUlOXSA9ICdbdj1cXFxcc10qKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1tYUkFOR0VJREVOVElGSUVSXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJyg/OicgKyBzcmNbUFJFUkVMRUFTRV0gKyAnKT8nICtcbiAgICAgICAgICAgICAgICAgICBzcmNbQlVJTERdICsgJz8nICtcbiAgICAgICAgICAgICAgICAgICAnKT8pPyc7XG5cbnZhciBYUkFOR0VQTEFJTkxPT1NFID0gUisrO1xuc3JjW1hSQU5HRVBMQUlOTE9PU0VdID0gJ1t2PVxcXFxzXSooJyArIHNyY1tYUkFOR0VJREVOVElGSUVSTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKD86JyArIHNyY1tQUkVSRUxFQVNFTE9PU0VdICsgJyk/JyArXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNbQlVJTERdICsgJz8nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcpPyk/JztcblxudmFyIFhSQU5HRSA9IFIrKztcbnNyY1tYUkFOR0VdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xcXFxzKicgKyBzcmNbWFJBTkdFUExBSU5dICsgJyQnO1xudmFyIFhSQU5HRUxPT1NFID0gUisrO1xuc3JjW1hSQU5HRUxPT1NFXSA9ICdeJyArIHNyY1tHVExUXSArICdcXFxccyonICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyQnO1xuXG4vLyBUaWxkZSByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwicmVhc29uYWJseSBhdCBvciBncmVhdGVyIHRoYW5cIlxudmFyIExPTkVUSUxERSA9IFIrKztcbnNyY1tMT05FVElMREVdID0gJyg/On4+PyknO1xuXG52YXIgVElMREVUUklNID0gUisrO1xuc3JjW1RJTERFVFJJTV0gPSAnKFxcXFxzKiknICsgc3JjW0xPTkVUSUxERV0gKyAnXFxcXHMrJztcbnJlW1RJTERFVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1tUSUxERVRSSU1dLCAnZycpO1xudmFyIHRpbGRlVHJpbVJlcGxhY2UgPSAnJDF+JztcblxudmFyIFRJTERFID0gUisrO1xuc3JjW1RJTERFXSA9ICdeJyArIHNyY1tMT05FVElMREVdICsgc3JjW1hSQU5HRVBMQUlOXSArICckJztcbnZhciBUSUxERUxPT1NFID0gUisrO1xuc3JjW1RJTERFTE9PU0VdID0gJ14nICsgc3JjW0xPTkVUSUxERV0gKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnJCc7XG5cbi8vIENhcmV0IHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJhdCBsZWFzdCBhbmQgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aFwiXG52YXIgTE9ORUNBUkVUID0gUisrO1xuc3JjW0xPTkVDQVJFVF0gPSAnKD86XFxcXF4pJztcblxudmFyIENBUkVUVFJJTSA9IFIrKztcbnNyY1tDQVJFVFRSSU1dID0gJyhcXFxccyopJyArIHNyY1tMT05FQ0FSRVRdICsgJ1xcXFxzKyc7XG5yZVtDQVJFVFRSSU1dID0gbmV3IFJlZ0V4cChzcmNbQ0FSRVRUUklNXSwgJ2cnKTtcbnZhciBjYXJldFRyaW1SZXBsYWNlID0gJyQxXic7XG5cbnZhciBDQVJFVCA9IFIrKztcbnNyY1tDQVJFVF0gPSAnXicgKyBzcmNbTE9ORUNBUkVUXSArIHNyY1tYUkFOR0VQTEFJTl0gKyAnJCc7XG52YXIgQ0FSRVRMT09TRSA9IFIrKztcbnNyY1tDQVJFVExPT1NFXSA9ICdeJyArIHNyY1tMT05FQ0FSRVRdICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyQnO1xuXG4vLyBBIHNpbXBsZSBndC9sdC9lcSB0aGluZywgb3IganVzdCBcIlwiIHRvIGluZGljYXRlIFwiYW55IHZlcnNpb25cIlxudmFyIENPTVBBUkFUT1JMT09TRSA9IFIrKztcbnNyY1tDT01QQVJBVE9STE9PU0VdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xcXFxzKignICsgTE9PU0VQTEFJTiArICcpJHxeJCc7XG52YXIgQ09NUEFSQVRPUiA9IFIrKztcbnNyY1tDT01QQVJBVE9SXSA9ICdeJyArIHNyY1tHVExUXSArICdcXFxccyooJyArIEZVTExQTEFJTiArICcpJHxeJCc7XG5cblxuLy8gQW4gZXhwcmVzc2lvbiB0byBzdHJpcCBhbnkgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBndGx0IGFuZCB0aGUgdGhpbmdcbi8vIGl0IG1vZGlmaWVzLCBzbyB0aGF0IGA+IDEuMi4zYCA9PT4gYD4xLjIuM2BcbnZhciBDT01QQVJBVE9SVFJJTSA9IFIrKztcbnNyY1tDT01QQVJBVE9SVFJJTV0gPSAnKFxcXFxzKiknICsgc3JjW0dUTFRdICtcbiAgICAgICAgICAgICAgICAgICAgICAnXFxcXHMqKCcgKyBMT09TRVBMQUlOICsgJ3wnICsgc3JjW1hSQU5HRVBMQUlOXSArICcpJztcblxuLy8gdGhpcyBvbmUgaGFzIHRvIHVzZSB0aGUgL2cgZmxhZ1xucmVbQ09NUEFSQVRPUlRSSU1dID0gbmV3IFJlZ0V4cChzcmNbQ09NUEFSQVRPUlRSSU1dLCAnZycpO1xudmFyIGNvbXBhcmF0b3JUcmltUmVwbGFjZSA9ICckMSQyJDMnO1xuXG5cbi8vIFNvbWV0aGluZyBsaWtlIGAxLjIuMyAtIDEuMi40YFxuLy8gTm90ZSB0aGF0IHRoZXNlIGFsbCB1c2UgdGhlIGxvb3NlIGZvcm0sIGJlY2F1c2UgdGhleSdsbCBiZVxuLy8gY2hlY2tlZCBhZ2FpbnN0IGVpdGhlciB0aGUgc3RyaWN0IG9yIGxvb3NlIGNvbXBhcmF0b3IgZm9ybVxuLy8gbGF0ZXIuXG52YXIgSFlQSEVOUkFOR0UgPSBSKys7XG5zcmNbSFlQSEVOUkFOR0VdID0gJ15cXFxccyooJyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICdcXFxccystXFxcXHMrJyArXG4gICAgICAgICAgICAgICAgICAgJygnICsgc3JjW1hSQU5HRVBMQUlOXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJ1xcXFxzKiQnO1xuXG52YXIgSFlQSEVOUkFOR0VMT09TRSA9IFIrKztcbnNyY1tIWVBIRU5SQU5HRUxPT1NFXSA9ICdeXFxcXHMqKCcgKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFxzKy1cXFxccysnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxcXHMqJCc7XG5cbi8vIFN0YXIgcmFuZ2VzIGJhc2ljYWxseSBqdXN0IGFsbG93IGFueXRoaW5nIGF0IGFsbC5cbnZhciBTVEFSID0gUisrO1xuc3JjW1NUQVJdID0gJyg8fD4pPz0/XFxcXHMqXFxcXConO1xuXG4vLyBDb21waWxlIHRvIGFjdHVhbCByZWdleHAgb2JqZWN0cy5cbi8vIEFsbCBhcmUgZmxhZy1mcmVlLCB1bmxlc3MgdGhleSB3ZXJlIGNyZWF0ZWQgYWJvdmUgd2l0aCBhIGZsYWcuXG5mb3IgKHZhciBpID0gMDsgaSA8IFI7IGkrKykge1xuICBkZWJ1ZyhpLCBzcmNbaV0pO1xuICBpZiAoIXJlW2ldKVxuICAgIHJlW2ldID0gbmV3IFJlZ0V4cChzcmNbaV0pO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5mdW5jdGlvbiBwYXJzZSh2ZXJzaW9uLCBsb29zZSkge1xuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcilcbiAgICByZXR1cm4gdmVyc2lvbjtcblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHIgPSBsb29zZSA/IHJlW0xPT1NFXSA6IHJlW0ZVTExdO1xuICBpZiAoIXIudGVzdCh2ZXJzaW9uKSlcbiAgICByZXR1cm4gbnVsbDtcblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIGxvb3NlKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnRzLnZhbGlkID0gdmFsaWQ7XG5mdW5jdGlvbiB2YWxpZCh2ZXJzaW9uLCBsb29zZSkge1xuICB2YXIgdiA9IHBhcnNlKHZlcnNpb24sIGxvb3NlKTtcbiAgcmV0dXJuIHYgPyB2LnZlcnNpb24gOiBudWxsO1xufVxuXG5cbmV4cG9ydHMuY2xlYW4gPSBjbGVhbjtcbmZ1bmN0aW9uIGNsZWFuKHZlcnNpb24sIGxvb3NlKSB7XG4gIHZhciBzID0gcGFyc2UodmVyc2lvbi50cmltKCkucmVwbGFjZSgvXls9dl0rLywgJycpLCBsb29zZSk7XG4gIHJldHVybiBzID8gcy52ZXJzaW9uIDogbnVsbDtcbn1cblxuZXhwb3J0cy5TZW1WZXIgPSBTZW1WZXI7XG5cbmZ1bmN0aW9uIFNlbVZlcih2ZXJzaW9uLCBsb29zZSkge1xuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIGlmICh2ZXJzaW9uLmxvb3NlID09PSBsb29zZSlcbiAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgIGVsc2VcbiAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb247XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBWZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZlcnNpb24gaXMgbG9uZ2VyIHRoYW4gJyArIE1BWF9MRU5HVEggKyAnIGNoYXJhY3RlcnMnKVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTZW1WZXIpKVxuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIGxvb3NlKTtcblxuICBkZWJ1ZygnU2VtVmVyJywgdmVyc2lvbiwgbG9vc2UpO1xuICB0aGlzLmxvb3NlID0gbG9vc2U7XG4gIHZhciBtID0gdmVyc2lvbi50cmltKCkubWF0Y2gobG9vc2UgPyByZVtMT09TRV0gOiByZVtGVUxMXSk7XG5cbiAgaWYgKCFtKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgVmVyc2lvbjogJyArIHZlcnNpb24pO1xuXG4gIHRoaXMucmF3ID0gdmVyc2lvbjtcblxuICAvLyB0aGVzZSBhcmUgYWN0dWFsbHkgbnVtYmVyc1xuICB0aGlzLm1ham9yID0gK21bMV07XG4gIHRoaXMubWlub3IgPSArbVsyXTtcbiAgdGhpcy5wYXRjaCA9ICttWzNdO1xuXG4gIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1ham9yIHZlcnNpb24nKVxuXG4gIGlmICh0aGlzLm1pbm9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1pbm9yIDwgMClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1pbm9yIHZlcnNpb24nKVxuXG4gIGlmICh0aGlzLnBhdGNoID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLnBhdGNoIDwgMClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuXG4gIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICBpZiAoIW1bNF0pXG4gICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gIGVsc2VcbiAgICB0aGlzLnByZXJlbGVhc2UgPSBtWzRdLnNwbGl0KCcuJykubWFwKGZ1bmN0aW9uKGlkKSB7XG4gICAgICBpZiAoL15bMC05XSskLy50ZXN0KGlkKSkge1xuICAgICAgICB2YXIgbnVtID0gK2lkXG4gICAgICAgIGlmIChudW0gPj0gMCAmJiBudW0gPCBNQVhfU0FGRV9JTlRFR0VSKVxuICAgICAgICAgIHJldHVybiBudW1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpZDtcbiAgICB9KTtcblxuICB0aGlzLmJ1aWxkID0gbVs1XSA/IG1bNV0uc3BsaXQoJy4nKSA6IFtdO1xuICB0aGlzLmZvcm1hdCgpO1xufVxuXG5TZW1WZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnZlcnNpb24gPSB0aGlzLm1ham9yICsgJy4nICsgdGhpcy5taW5vciArICcuJyArIHRoaXMucGF0Y2g7XG4gIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKVxuICAgIHRoaXMudmVyc2lvbiArPSAnLScgKyB0aGlzLnByZXJlbGVhc2Uuam9pbignLicpO1xuICByZXR1cm4gdGhpcy52ZXJzaW9uO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy52ZXJzaW9uO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgZGVidWcoJ1NlbVZlci5jb21wYXJlJywgdGhpcy52ZXJzaW9uLCB0aGlzLmxvb3NlLCBvdGhlcik7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSlcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMubG9vc2UpO1xuXG4gIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlTWFpbiA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSlcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMubG9vc2UpO1xuXG4gIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlUHJlID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKVxuICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5sb29zZSk7XG5cbiAgLy8gTk9UIGhhdmluZyBhIHByZXJlbGVhc2UgaXMgPiBoYXZpbmcgb25lXG4gIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aClcbiAgICByZXR1cm4gLTE7XG4gIGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmIG90aGVyLnByZXJlbGVhc2UubGVuZ3RoKVxuICAgIHJldHVybiAxO1xuICBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpXG4gICAgcmV0dXJuIDA7XG5cbiAgdmFyIGkgPSAwO1xuICBkbyB7XG4gICAgdmFyIGEgPSB0aGlzLnByZXJlbGVhc2VbaV07XG4gICAgdmFyIGIgPSBvdGhlci5wcmVyZWxlYXNlW2ldO1xuICAgIGRlYnVnKCdwcmVyZWxlYXNlIGNvbXBhcmUnLCBpLCBhLCBiKTtcbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiAwO1xuICAgIGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhID09PSBiKVxuICAgICAgY29udGludWU7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKTtcbiAgfSB3aGlsZSAoKytpKTtcbn07XG5cbi8vIHByZW1pbm9yIHdpbGwgYnVtcCB0aGUgdmVyc2lvbiB1cCB0byB0aGUgbmV4dCBtaW5vciByZWxlYXNlLCBhbmQgaW1tZWRpYXRlbHlcbi8vIGRvd24gdG8gcHJlLXJlbGVhc2UuIHByZW1ham9yIGFuZCBwcmVwYXRjaCB3b3JrIHRoZSBzYW1lIHdheS5cblNlbVZlci5wcm90b3R5cGUuaW5jID0gZnVuY3Rpb24ocmVsZWFzZSwgaWRlbnRpZmllcikge1xuICBzd2l0Y2ggKHJlbGVhc2UpIHtcbiAgICBjYXNlICdwcmVtYWpvcic6XG4gICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5taW5vciA9IDA7XG4gICAgICB0aGlzLm1ham9yKys7XG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcik7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5taW5vcisrO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncHJlcGF0Y2gnOlxuICAgICAgLy8gSWYgdGhpcyBpcyBhbHJlYWR5IGEgcHJlcmVsZWFzZSwgaXQgd2lsbCBidW1wIHRvIHRoZSBuZXh0IHZlcnNpb25cbiAgICAgIC8vIGRyb3AgYW55IHByZXJlbGVhc2VzIHRoYXQgbWlnaHQgYWxyZWFkeSBleGlzdCwgc2luY2UgdGhleSBhcmUgbm90XG4gICAgICAvLyByZWxldmFudCBhdCB0aGlzIHBvaW50LlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKTtcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIElmIHRoZSBpbnB1dCBpcyBhIG5vbi1wcmVyZWxlYXNlIHZlcnNpb24sIHRoaXMgYWN0cyB0aGUgc2FtZSBhc1xuICAgIC8vIHByZXBhdGNoLlxuICAgIGNhc2UgJ3ByZXJlbGVhc2UnOlxuICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIpO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdtYWpvcic6XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1ham9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWFqb3IgdmVyc2lvbi5cbiAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWFqb3IuXG4gICAgICAvLyAxLjAuMC01IGJ1bXBzIHRvIDEuMC4wXG4gICAgICAvLyAxLjEuMCBidW1wcyB0byAyLjAuMFxuICAgICAgaWYgKHRoaXMubWlub3IgIT09IDAgfHwgdGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLm1ham9yKys7XG4gICAgICB0aGlzLm1pbm9yID0gMDtcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtaW5vcic6XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1pbm9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWlub3IgdmVyc2lvbi5cbiAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWlub3IuXG4gICAgICAvLyAxLjIuMC01IGJ1bXBzIHRvIDEuMi4wXG4gICAgICAvLyAxLjIuMSBidW1wcyB0byAxLjMuMFxuICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5taW5vcisrO1xuICAgICAgdGhpcy5wYXRjaCA9IDA7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3BhdGNoJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgbm90IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiwgaXQgd2lsbCBpbmNyZW1lbnQgdGhlIHBhdGNoLlxuICAgICAgLy8gSWYgaXQgaXMgYSBwcmUtcmVsZWFzZSBpdCB3aWxsIGJ1bXAgdXAgdG8gdGhlIHNhbWUgcGF0Y2ggdmVyc2lvbi5cbiAgICAgIC8vIDEuMi4wLTUgcGF0Y2hlcyB0byAxLjIuMFxuICAgICAgLy8gMS4yLjAgcGF0Y2hlcyB0byAxLjIuMVxuICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMucGF0Y2grKztcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgLy8gVGhpcyBwcm9iYWJseSBzaG91bGRuJ3QgYmUgdXNlZCBwdWJsaWNseS5cbiAgICAvLyAxLjAuMCBcInByZVwiIHdvdWxkIGJlY29tZSAxLjAuMC0wIHdoaWNoIGlzIHRoZSB3cm9uZyBkaXJlY3Rpb24uXG4gICAgY2FzZSAncHJlJzpcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbMF07XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnByZXJlbGVhc2UubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJlcmVsZWFzZVtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZVtpXSsrO1xuICAgICAgICAgICAgaSA9IC0yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gLTEpIC8vIGRpZG4ndCBpbmNyZW1lbnQgYW55dGhpbmdcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UucHVzaCgwKTtcbiAgICAgIH1cbiAgICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgIC8vIDEuMi4wLWJldGEuMSBidW1wcyB0byAxLjIuMC1iZXRhLjIsXG4gICAgICAgIC8vIDEuMi4wLWJldGEuZm9vYmx6IG9yIDEuMi4wLWJldGEgYnVtcHMgdG8gMS4yLjAtYmV0YS4wXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2VbMF0gPT09IGlkZW50aWZpZXIpIHtcbiAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSlcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogJyArIHJlbGVhc2UpO1xuICB9XG4gIHRoaXMuZm9ybWF0KCk7XG4gIHRoaXMucmF3ID0gdGhpcy52ZXJzaW9uO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmV4cG9ydHMuaW5jID0gaW5jO1xuZnVuY3Rpb24gaW5jKHZlcnNpb24sIHJlbGVhc2UsIGxvb3NlLCBpZGVudGlmaWVyKSB7XG4gIGlmICh0eXBlb2YobG9vc2UpID09PSAnc3RyaW5nJykge1xuICAgIGlkZW50aWZpZXIgPSBsb29zZTtcbiAgICBsb29zZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgbG9vc2UpLmluYyhyZWxlYXNlLCBpZGVudGlmaWVyKS52ZXJzaW9uO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydHMuZGlmZiA9IGRpZmY7XG5mdW5jdGlvbiBkaWZmKHZlcnNpb24xLCB2ZXJzaW9uMikge1xuICBpZiAoZXEodmVyc2lvbjEsIHZlcnNpb24yKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHZhciB2MSA9IHBhcnNlKHZlcnNpb24xKTtcbiAgICB2YXIgdjIgPSBwYXJzZSh2ZXJzaW9uMik7XG4gICAgaWYgKHYxLnByZXJlbGVhc2UubGVuZ3RoIHx8IHYyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdjEpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ21ham9yJyB8fCBrZXkgPT09ICdtaW5vcicgfHwga2V5ID09PSAncGF0Y2gnKSB7XG4gICAgICAgICAgaWYgKHYxW2tleV0gIT09IHYyW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiAncHJlJytrZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJ3ByZXJlbGVhc2UnO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gdjEpIHtcbiAgICAgIGlmIChrZXkgPT09ICdtYWpvcicgfHwga2V5ID09PSAnbWlub3InIHx8IGtleSA9PT0gJ3BhdGNoJykge1xuICAgICAgICBpZiAodjFba2V5XSAhPT0gdjJba2V5XSkge1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5jb21wYXJlSWRlbnRpZmllcnMgPSBjb21wYXJlSWRlbnRpZmllcnM7XG5cbnZhciBudW1lcmljID0gL15bMC05XSskLztcbmZ1bmN0aW9uIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKSB7XG4gIHZhciBhbnVtID0gbnVtZXJpYy50ZXN0KGEpO1xuICB2YXIgYm51bSA9IG51bWVyaWMudGVzdChiKTtcblxuICBpZiAoYW51bSAmJiBibnVtKSB7XG4gICAgYSA9ICthO1xuICAgIGIgPSArYjtcbiAgfVxuXG4gIHJldHVybiAoYW51bSAmJiAhYm51bSkgPyAtMSA6XG4gICAgICAgICAoYm51bSAmJiAhYW51bSkgPyAxIDpcbiAgICAgICAgIGEgPCBiID8gLTEgOlxuICAgICAgICAgYSA+IGIgPyAxIDpcbiAgICAgICAgIDA7XG59XG5cbmV4cG9ydHMucmNvbXBhcmVJZGVudGlmaWVycyA9IHJjb21wYXJlSWRlbnRpZmllcnM7XG5mdW5jdGlvbiByY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpIHtcbiAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhiLCBhKTtcbn1cblxuZXhwb3J0cy5tYWpvciA9IG1ham9yO1xuZnVuY3Rpb24gbWFqb3IoYSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yO1xufVxuXG5leHBvcnRzLm1pbm9yID0gbWlub3I7XG5mdW5jdGlvbiBtaW5vcihhLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkubWlub3I7XG59XG5cbmV4cG9ydHMucGF0Y2ggPSBwYXRjaDtcbmZ1bmN0aW9uIHBhdGNoKGEsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaDtcbn1cblxuZXhwb3J0cy5jb21wYXJlID0gY29tcGFyZTtcbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLmNvbXBhcmUoYik7XG59XG5cbmV4cG9ydHMuY29tcGFyZUxvb3NlID0gY29tcGFyZUxvb3NlO1xuZnVuY3Rpb24gY29tcGFyZUxvb3NlKGEsIGIpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgdHJ1ZSk7XG59XG5cbmV4cG9ydHMucmNvbXBhcmUgPSByY29tcGFyZTtcbmZ1bmN0aW9uIHJjb21wYXJlKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGIsIGEsIGxvb3NlKTtcbn1cblxuZXhwb3J0cy5zb3J0ID0gc29ydDtcbmZ1bmN0aW9uIHNvcnQobGlzdCwgbG9vc2UpIHtcbiAgcmV0dXJuIGxpc3Quc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuY29tcGFyZShhLCBiLCBsb29zZSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLnJzb3J0ID0gcnNvcnQ7XG5mdW5jdGlvbiByc29ydChsaXN0LCBsb29zZSkge1xuICByZXR1cm4gbGlzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5yY29tcGFyZShhLCBiLCBsb29zZSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmd0ID0gZ3Q7XG5mdW5jdGlvbiBndChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPiAwO1xufVxuXG5leHBvcnRzLmx0ID0gbHQ7XG5mdW5jdGlvbiBsdChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPCAwO1xufVxuXG5leHBvcnRzLmVxID0gZXE7XG5mdW5jdGlvbiBlcShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPT09IDA7XG59XG5cbmV4cG9ydHMubmVxID0gbmVxO1xuZnVuY3Rpb24gbmVxKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSAhPT0gMDtcbn1cblxuZXhwb3J0cy5ndGUgPSBndGU7XG5mdW5jdGlvbiBndGUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpID49IDA7XG59XG5cbmV4cG9ydHMubHRlID0gbHRlO1xuZnVuY3Rpb24gbHRlKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8PSAwO1xufVxuXG5leHBvcnRzLmNtcCA9IGNtcDtcbmZ1bmN0aW9uIGNtcChhLCBvcCwgYiwgbG9vc2UpIHtcbiAgdmFyIHJldDtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJz09PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSBhID0gYS52ZXJzaW9uO1xuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JykgYiA9IGIudmVyc2lvbjtcbiAgICAgIHJldCA9IGEgPT09IGI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICchPT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JykgYSA9IGEudmVyc2lvbjtcbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIGIgPSBiLnZlcnNpb247XG4gICAgICByZXQgPSBhICE9PSBiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJzogY2FzZSAnPSc6IGNhc2UgJz09JzogcmV0ID0gZXEoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICchPSc6IHJldCA9IG5lcShhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJz4nOiByZXQgPSBndChhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJz49JzogcmV0ID0gZ3RlKGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnPCc6IHJldCA9IGx0KGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnPD0nOiByZXQgPSBsdGUoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG9wZXJhdG9yOiAnICsgb3ApO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmV4cG9ydHMuQ29tcGFyYXRvciA9IENvbXBhcmF0b3I7XG5mdW5jdGlvbiBDb21wYXJhdG9yKGNvbXAsIGxvb3NlKSB7XG4gIGlmIChjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgIGlmIChjb21wLmxvb3NlID09PSBsb29zZSlcbiAgICAgIHJldHVybiBjb21wO1xuICAgIGVsc2VcbiAgICAgIGNvbXAgPSBjb21wLnZhbHVlO1xuICB9XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKVxuICAgIHJldHVybiBuZXcgQ29tcGFyYXRvcihjb21wLCBsb29zZSk7XG5cbiAgZGVidWcoJ2NvbXBhcmF0b3InLCBjb21wLCBsb29zZSk7XG4gIHRoaXMubG9vc2UgPSBsb29zZTtcbiAgdGhpcy5wYXJzZShjb21wKTtcblxuICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSlcbiAgICB0aGlzLnZhbHVlID0gJyc7XG4gIGVsc2VcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5vcGVyYXRvciArIHRoaXMuc2VtdmVyLnZlcnNpb247XG5cbiAgZGVidWcoJ2NvbXAnLCB0aGlzKTtcbn1cblxudmFyIEFOWSA9IHt9O1xuQ29tcGFyYXRvci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihjb21wKSB7XG4gIHZhciByID0gdGhpcy5sb29zZSA/IHJlW0NPTVBBUkFUT1JMT09TRV0gOiByZVtDT01QQVJBVE9SXTtcbiAgdmFyIG0gPSBjb21wLm1hdGNoKHIpO1xuXG4gIGlmICghbSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNvbXBhcmF0b3I6ICcgKyBjb21wKTtcblxuICB0aGlzLm9wZXJhdG9yID0gbVsxXTtcbiAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICc9JylcbiAgICB0aGlzLm9wZXJhdG9yID0gJyc7XG5cbiAgLy8gaWYgaXQgbGl0ZXJhbGx5IGlzIGp1c3QgJz4nIG9yICcnIHRoZW4gYWxsb3cgYW55dGhpbmcuXG4gIGlmICghbVsyXSlcbiAgICB0aGlzLnNlbXZlciA9IEFOWTtcbiAgZWxzZVxuICAgIHRoaXMuc2VtdmVyID0gbmV3IFNlbVZlcihtWzJdLCB0aGlzLmxvb3NlKTtcbn07XG5cbkNvbXBhcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnZhbHVlO1xufTtcblxuQ29tcGFyYXRvci5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgZGVidWcoJ0NvbXBhcmF0b3IudGVzdCcsIHZlcnNpb24sIHRoaXMubG9vc2UpO1xuXG4gIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpXG4gICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5sb29zZSk7XG5cbiAgcmV0dXJuIGNtcCh2ZXJzaW9uLCB0aGlzLm9wZXJhdG9yLCB0aGlzLnNlbXZlciwgdGhpcy5sb29zZSk7XG59O1xuXG5cbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcbmZ1bmN0aW9uIFJhbmdlKHJhbmdlLCBsb29zZSkge1xuICBpZiAoKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpICYmIHJhbmdlLmxvb3NlID09PSBsb29zZSlcbiAgICByZXR1cm4gcmFuZ2U7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJhbmdlKSlcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSk7XG5cbiAgdGhpcy5sb29zZSA9IGxvb3NlO1xuXG4gIC8vIEZpcnN0LCBzcGxpdCBiYXNlZCBvbiBib29sZWFuIG9yIHx8XG4gIHRoaXMucmF3ID0gcmFuZ2U7XG4gIHRoaXMuc2V0ID0gcmFuZ2Uuc3BsaXQoL1xccypcXHxcXHxcXHMqLykubWFwKGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VSYW5nZShyYW5nZS50cmltKCkpO1xuICB9LCB0aGlzKS5maWx0ZXIoZnVuY3Rpb24oYykge1xuICAgIC8vIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHJlbGV2YW50IGZvciB3aGF0ZXZlciByZWFzb25cbiAgICByZXR1cm4gYy5sZW5ndGg7XG4gIH0pO1xuXG4gIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBTZW1WZXIgUmFuZ2U6ICcgKyByYW5nZSk7XG4gIH1cblxuICB0aGlzLmZvcm1hdCgpO1xufVxuXG5SYW5nZS5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmFuZ2UgPSB0aGlzLnNldC5tYXAoZnVuY3Rpb24oY29tcHMpIHtcbiAgICByZXR1cm4gY29tcHMuam9pbignICcpLnRyaW0oKTtcbiAgfSkuam9pbignfHwnKS50cmltKCk7XG4gIHJldHVybiB0aGlzLnJhbmdlO1xufTtcblxuUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJhbmdlO1xufTtcblxuUmFuZ2UucHJvdG90eXBlLnBhcnNlUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xuICB2YXIgbG9vc2UgPSB0aGlzLmxvb3NlO1xuICByYW5nZSA9IHJhbmdlLnRyaW0oKTtcbiAgZGVidWcoJ3JhbmdlJywgcmFuZ2UsIGxvb3NlKTtcbiAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gIHZhciBociA9IGxvb3NlID8gcmVbSFlQSEVOUkFOR0VMT09TRV0gOiByZVtIWVBIRU5SQU5HRV07XG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSk7XG4gIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKTtcbiAgLy8gYD4gMS4yLjMgPCAxLjIuNWAgPT4gYD4xLjIuMyA8MS4yLjVgXG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVtDT01QQVJBVE9SVFJJTV0sIGNvbXBhcmF0b3JUcmltUmVwbGFjZSk7XG4gIGRlYnVnKCdjb21wYXJhdG9yIHRyaW0nLCByYW5nZSwgcmVbQ09NUEFSQVRPUlRSSU1dKTtcblxuICAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2BcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW1RJTERFVFJJTV0sIHRpbGRlVHJpbVJlcGxhY2UpO1xuXG4gIC8vIGBeIDEuMi4zYCA9PiBgXjEuMi4zYFxuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbQ0FSRVRUUklNXSwgY2FyZXRUcmltUmVwbGFjZSk7XG5cbiAgLy8gbm9ybWFsaXplIHNwYWNlc1xuICByYW5nZSA9IHJhbmdlLnNwbGl0KC9cXHMrLykuam9pbignICcpO1xuXG4gIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IHRyaW1tZWQgYW5kXG4gIC8vIHJlYWR5IHRvIGJlIHNwbGl0IGludG8gY29tcGFyYXRvcnMuXG5cbiAgdmFyIGNvbXBSZSA9IGxvb3NlID8gcmVbQ09NUEFSQVRPUkxPT1NFXSA6IHJlW0NPTVBBUkFUT1JdO1xuICB2YXIgc2V0ID0gcmFuZ2Uuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgbG9vc2UpO1xuICB9KS5qb2luKCcgJykuc3BsaXQoL1xccysvKTtcbiAgaWYgKHRoaXMubG9vc2UpIHtcbiAgICAvLyBpbiBsb29zZSBtb2RlLCB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCB2YWxpZCBjb21wYXJhdG9yc1xuICAgIHNldCA9IHNldC5maWx0ZXIoZnVuY3Rpb24oY29tcCkge1xuICAgICAgcmV0dXJuICEhY29tcC5tYXRjaChjb21wUmUpO1xuICAgIH0pO1xuICB9XG4gIHNldCA9IHNldC5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiBuZXcgQ29tcGFyYXRvcihjb21wLCBsb29zZSk7XG4gIH0pO1xuXG4gIHJldHVybiBzZXQ7XG59O1xuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5leHBvcnRzLnRvQ29tcGFyYXRvcnMgPSB0b0NvbXBhcmF0b3JzO1xuZnVuY3Rpb24gdG9Db21wYXJhdG9ycyhyYW5nZSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpLnNldC5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiBjb21wLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICByZXR1cm4gYy52YWx1ZTtcbiAgICB9KS5qb2luKCcgJykudHJpbSgpLnNwbGl0KCcgJyk7XG4gIH0pO1xufVxuXG4vLyBjb21wcmlzZWQgb2YgeHJhbmdlcywgdGlsZGVzLCBzdGFycywgYW5kIGd0bHQncyBhdCB0aGlzIHBvaW50LlxuLy8gYWxyZWFkeSByZXBsYWNlZCB0aGUgaHlwaGVuIHJhbmdlc1xuLy8gdHVybiBpbnRvIGEgc2V0IG9mIEpVU1QgY29tcGFyYXRvcnMuXG5mdW5jdGlvbiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgbG9vc2UpIHtcbiAgZGVidWcoJ2NvbXAnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgbG9vc2UpO1xuICBkZWJ1ZygnY2FyZXQnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VUaWxkZXMoY29tcCwgbG9vc2UpO1xuICBkZWJ1ZygndGlsZGVzJywgY29tcCk7XG4gIGNvbXAgPSByZXBsYWNlWFJhbmdlcyhjb21wLCBsb29zZSk7XG4gIGRlYnVnKCd4cmFuZ2UnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBsb29zZSk7XG4gIGRlYnVnKCdzdGFycycsIGNvbXApO1xuICByZXR1cm4gY29tcDtcbn1cblxuZnVuY3Rpb24gaXNYKGlkKSB7XG4gIHJldHVybiAhaWQgfHwgaWQudG9Mb3dlckNhc2UoKSA9PT0gJ3gnIHx8IGlkID09PSAnKic7XG59XG5cbi8vIH4sIH4+IC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMFxuLy8gfjIuMCwgfjIuMC54LCB+PjIuMCwgfj4yLjAueCAtLT4gPj0yLjAuMCA8Mi4xLjBcbi8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wXG4vLyB+MS4yLjMsIH4+MS4yLjMgLS0+ID49MS4yLjMgPDEuMy4wXG4vLyB+MS4yLjAsIH4+MS4yLjAgLS0+ID49MS4yLjAgPDEuMy4wXG5mdW5jdGlvbiByZXBsYWNlVGlsZGVzKGNvbXAsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VUaWxkZShjb21wLCBsb29zZSk7XG4gIH0pLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVRpbGRlKGNvbXAsIGxvb3NlKSB7XG4gIHZhciByID0gbG9vc2UgPyByZVtUSUxERUxPT1NFXSA6IHJlW1RJTERFXTtcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbihfLCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCd0aWxkZScsIGNvbXAsIF8sIE0sIG0sIHAsIHByKTtcbiAgICB2YXIgcmV0O1xuXG4gICAgaWYgKGlzWChNKSlcbiAgICAgIHJldCA9ICcnO1xuICAgIGVsc2UgaWYgKGlzWChtKSlcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICBlbHNlIGlmIChpc1gocCkpXG4gICAgICAvLyB+MS4yID09ID49MS4yLjAtIDwxLjMuMC1cbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlVGlsZGUgcHInLCBwcik7XG4gICAgICBpZiAocHIuY2hhckF0KDApICE9PSAnLScpXG4gICAgICAgIHByID0gJy0nICsgcHI7XG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgcHIgK1xuICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgfSBlbHNlXG4gICAgICAvLyB+MS4yLjMgPT0gPj0xLjIuMyA8MS4zLjBcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG5cbiAgICBkZWJ1ZygndGlsZGUgcmV0dXJuJywgcmV0KTtcbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cblxuLy8gXiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIF4yLCBeMi54LCBeMi54LnggLS0+ID49Mi4wLjAgPDMuMC4wXG4vLyBeMi4wLCBeMi4wLnggLS0+ID49Mi4wLjAgPDMuMC4wXG4vLyBeMS4yLCBeMS4yLnggLS0+ID49MS4yLjAgPDIuMC4wXG4vLyBeMS4yLjMgLS0+ID49MS4yLjMgPDIuMC4wXG4vLyBeMS4yLjAgLS0+ID49MS4yLjAgPDIuMC4wXG5mdW5jdGlvbiByZXBsYWNlQ2FyZXRzKGNvbXAsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VDYXJldChjb21wLCBsb29zZSk7XG4gIH0pLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUNhcmV0KGNvbXAsIGxvb3NlKSB7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXAsIGxvb3NlKTtcbiAgdmFyIHIgPSBsb29zZSA/IHJlW0NBUkVUTE9PU0VdIDogcmVbQ0FSRVRdO1xuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIGZ1bmN0aW9uKF8sIE0sIG0sIHAsIHByKSB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpO1xuICAgIHZhciByZXQ7XG5cbiAgICBpZiAoaXNYKE0pKVxuICAgICAgcmV0ID0gJyc7XG4gICAgZWxzZSBpZiAoaXNYKG0pKVxuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLjAuMCA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgaWYgKE0gPT09ICcwJylcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VDYXJldCBwcicsIHByKTtcbiAgICAgIGlmIChwci5jaGFyQXQoMCkgIT09ICctJylcbiAgICAgICAgcHIgPSAnLScgKyBwcjtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJylcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgcHIgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgbSArICcuJyArICgrcCArIDEpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgcHIgK1xuICAgICAgICAgICAgICAnIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdubyBwcicpO1xuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKVxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgbSArICcuJyArICgrcCArIDEpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAgICcgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICB9XG5cbiAgICBkZWJ1ZygnY2FyZXQgcmV0dXJuJywgcmV0KTtcbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVhSYW5nZXMoY29tcCwgbG9vc2UpIHtcbiAgZGVidWcoJ3JlcGxhY2VYUmFuZ2VzJywgY29tcCwgbG9vc2UpO1xuICByZXR1cm4gY29tcC5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VYUmFuZ2UoY29tcCwgbG9vc2UpO1xuICB9KS5qb2luKCcgJyk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VYUmFuZ2UoY29tcCwgbG9vc2UpIHtcbiAgY29tcCA9IGNvbXAudHJpbSgpO1xuICB2YXIgciA9IGxvb3NlID8gcmVbWFJBTkdFTE9PU0VdIDogcmVbWFJBTkdFXTtcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbihyZXQsIGd0bHQsIE0sIG0sIHAsIHByKSB7XG4gICAgZGVidWcoJ3hSYW5nZScsIGNvbXAsIHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpO1xuICAgIHZhciB4TSA9IGlzWChNKTtcbiAgICB2YXIgeG0gPSB4TSB8fCBpc1gobSk7XG4gICAgdmFyIHhwID0geG0gfHwgaXNYKHApO1xuICAgIHZhciBhbnlYID0geHA7XG5cbiAgICBpZiAoZ3RsdCA9PT0gJz0nICYmIGFueVgpXG4gICAgICBndGx0ID0gJyc7XG5cbiAgICBpZiAoeE0pIHtcbiAgICAgIGlmIChndGx0ID09PSAnPicgfHwgZ3RsdCA9PT0gJzwnKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgYWxsb3dlZFxuICAgICAgICByZXQgPSAnPDAuMC4wJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuXG4gICAgICAgIHJldCA9ICcqJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGd0bHQgJiYgYW55WCkge1xuICAgICAgLy8gcmVwbGFjZSBYIHdpdGggMFxuICAgICAgaWYgKHhtKVxuICAgICAgICBtID0gMDtcbiAgICAgIGlmICh4cClcbiAgICAgICAgcCA9IDA7XG5cbiAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgLy8gPjEgPT4gPj0yLjAuMFxuICAgICAgICAvLyA+MS4yID0+ID49MS4zLjBcbiAgICAgICAgLy8gPjEuMi4zID0+ID49IDEuMi40XG4gICAgICAgIGd0bHQgPSAnPj0nO1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxO1xuICAgICAgICAgIG0gPSAwO1xuICAgICAgICAgIHAgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICAgICAgbSA9ICttICsgMTtcbiAgICAgICAgICBwID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7XG4gICAgICAgIC8vIDw9MC43LnggaXMgYWN0dWFsbHkgPDAuOC4wLCBzaW5jZSBhbnkgMC43Lnggc2hvdWxkXG4gICAgICAgIC8vIHBhc3MuICBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLlxuICAgICAgICBndGx0ID0gJzwnXG4gICAgICAgIGlmICh4bSlcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICB9XG5cbiAgICAgIHJldCA9IGd0bHQgKyBNICsgJy4nICsgbSArICcuJyArIHA7XG4gICAgfSBlbHNlIGlmICh4bSkge1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLjAuMCA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH0gZWxzZSBpZiAoeHApIHtcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgfVxuXG4gICAgZGVidWcoJ3hSYW5nZSByZXR1cm4nLCByZXQpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG5cbi8vIEJlY2F1c2UgKiBpcyBBTkQtZWQgd2l0aCBldmVyeXRoaW5nIGVsc2UgaW4gdGhlIGNvbXBhcmF0b3IsXG4vLyBhbmQgJycgbWVhbnMgXCJhbnkgdmVyc2lvblwiLCBqdXN0IHJlbW92ZSB0aGUgKnMgZW50aXJlbHkuXG5mdW5jdGlvbiByZXBsYWNlU3RhcnMoY29tcCwgbG9vc2UpIHtcbiAgZGVidWcoJ3JlcGxhY2VTdGFycycsIGNvbXAsIGxvb3NlKTtcbiAgLy8gTG9vc2VuZXNzIGlzIGlnbm9yZWQgaGVyZS4gIHN0YXIgaXMgYWx3YXlzIGFzIGxvb3NlIGFzIGl0IGdldHMhXG4gIHJldHVybiBjb21wLnRyaW0oKS5yZXBsYWNlKHJlW1NUQVJdLCAnJyk7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgcGFzc2VkIHRvIHN0cmluZy5yZXBsYWNlKHJlW0hZUEhFTlJBTkdFXSlcbi8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZFxuLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4vLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMCBBbnkgMy40Lnggd2lsbCBkb1xuLy8gMS4yIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wXG5mdW5jdGlvbiBoeXBoZW5SZXBsYWNlKCQwLFxuICAgICAgICAgICAgICAgICAgICAgICBmcm9tLCBmTSwgZm0sIGZwLCBmcHIsIGZiLFxuICAgICAgICAgICAgICAgICAgICAgICB0bywgdE0sIHRtLCB0cCwgdHByLCB0Yikge1xuXG4gIGlmIChpc1goZk0pKVxuICAgIGZyb20gPSAnJztcbiAgZWxzZSBpZiAoaXNYKGZtKSlcbiAgICBmcm9tID0gJz49JyArIGZNICsgJy4wLjAnO1xuICBlbHNlIGlmIChpc1goZnApKVxuICAgIGZyb20gPSAnPj0nICsgZk0gKyAnLicgKyBmbSArICcuMCc7XG4gIGVsc2VcbiAgICBmcm9tID0gJz49JyArIGZyb207XG5cbiAgaWYgKGlzWCh0TSkpXG4gICAgdG8gPSAnJztcbiAgZWxzZSBpZiAoaXNYKHRtKSlcbiAgICB0byA9ICc8JyArICgrdE0gKyAxKSArICcuMC4wJztcbiAgZWxzZSBpZiAoaXNYKHRwKSlcbiAgICB0byA9ICc8JyArIHRNICsgJy4nICsgKCt0bSArIDEpICsgJy4wJztcbiAgZWxzZSBpZiAodHByKVxuICAgIHRvID0gJzw9JyArIHRNICsgJy4nICsgdG0gKyAnLicgKyB0cCArICctJyArIHRwcjtcbiAgZWxzZVxuICAgIHRvID0gJzw9JyArIHRvO1xuXG4gIHJldHVybiAoZnJvbSArICcgJyArIHRvKS50cmltKCk7XG59XG5cblxuLy8gaWYgQU5ZIG9mIHRoZSBzZXRzIG1hdGNoIEFMTCBvZiBpdHMgY29tcGFyYXRvcnMsIHRoZW4gcGFzc1xuUmFuZ2UucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbih2ZXJzaW9uKSB7XG4gIGlmICghdmVyc2lvbilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJylcbiAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLmxvb3NlKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRlc3RTZXQodGhpcy5zZXRbaV0sIHZlcnNpb24pKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gdGVzdFNldChzZXQsIHZlcnNpb24pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAvLyBGaW5kIHRoZSBzZXQgb2YgdmVyc2lvbnMgdGhhdCBhcmUgYWxsb3dlZCB0byBoYXZlIHByZXJlbGVhc2VzXG4gICAgLy8gRm9yIGV4YW1wbGUsIF4xLjIuMy1wci4xIGRlc3VnYXJzIHRvID49MS4yLjMtcHIuMSA8Mi4wLjBcbiAgICAvLyBUaGF0IHNob3VsZCBhbGxvdyBgMS4yLjMtcHIuMmAgdG8gcGFzcy5cbiAgICAvLyBIb3dldmVyLCBgMS4yLjQtYWxwaGEubm90cmVhZHlgIHNob3VsZCBOT1QgYmUgYWxsb3dlZCxcbiAgICAvLyBldmVuIHRob3VnaCBpdCdzIHdpdGhpbiB0aGUgcmFuZ2Ugc2V0IGJ5IHRoZSBjb21wYXJhdG9ycy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgZGVidWcoc2V0W2ldLnNlbXZlcik7XG4gICAgICBpZiAoc2V0W2ldLnNlbXZlciA9PT0gQU5ZKVxuICAgICAgICBjb250aW51ZTtcblxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBhbGxvd2VkID0gc2V0W2ldLnNlbXZlcjtcbiAgICAgICAgaWYgKGFsbG93ZWQubWFqb3IgPT09IHZlcnNpb24ubWFqb3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQubWlub3IgPT09IHZlcnNpb24ubWlub3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQucGF0Y2ggPT09IHZlcnNpb24ucGF0Y2gpXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmVyc2lvbiBoYXMgYSAtcHJlLCBidXQgaXQncyBub3Qgb25lIG9mIHRoZSBvbmVzIHdlIGxpa2UuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydHMuc2F0aXNmaWVzID0gc2F0aXNmaWVzO1xuZnVuY3Rpb24gc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBsb29zZSkge1xuICB0cnkge1xuICAgIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiByYW5nZS50ZXN0KHZlcnNpb24pO1xufVxuXG5leHBvcnRzLm1heFNhdGlzZnlpbmcgPSBtYXhTYXRpc2Z5aW5nO1xuZnVuY3Rpb24gbWF4U2F0aXNmeWluZyh2ZXJzaW9ucywgcmFuZ2UsIGxvb3NlKSB7XG4gIHJldHVybiB2ZXJzaW9ucy5maWx0ZXIoZnVuY3Rpb24odmVyc2lvbikge1xuICAgIHJldHVybiBzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIGxvb3NlKTtcbiAgfSkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIHJjb21wYXJlKGEsIGIsIGxvb3NlKTtcbiAgfSlbMF0gfHwgbnVsbDtcbn1cblxuZXhwb3J0cy52YWxpZFJhbmdlID0gdmFsaWRSYW5nZTtcbmZ1bmN0aW9uIHZhbGlkUmFuZ2UocmFuZ2UsIGxvb3NlKSB7XG4gIHRyeSB7XG4gICAgLy8gUmV0dXJuICcqJyBpbnN0ZWFkIG9mICcnIHNvIHRoYXQgdHJ1dGhpbmVzcyB3b3Jrcy5cbiAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgaXQncyBpbnZhbGlkIGFueXdheVxuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKS5yYW5nZSB8fCAnKic7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgbGVzcyB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlXG5leHBvcnRzLmx0ciA9IGx0cjtcbmZ1bmN0aW9uIGx0cih2ZXJzaW9uLCByYW5nZSwgbG9vc2UpIHtcbiAgcmV0dXJuIG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc8JywgbG9vc2UpO1xufVxuXG4vLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2UuXG5leHBvcnRzLmd0ciA9IGd0cjtcbmZ1bmN0aW9uIGd0cih2ZXJzaW9uLCByYW5nZSwgbG9vc2UpIHtcbiAgcmV0dXJuIG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc+JywgbG9vc2UpO1xufVxuXG5leHBvcnRzLm91dHNpZGUgPSBvdXRzaWRlO1xuZnVuY3Rpb24gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgaGlsbywgbG9vc2UpIHtcbiAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgbG9vc2UpO1xuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpO1xuXG4gIHZhciBndGZuLCBsdGVmbiwgbHRmbiwgY29tcCwgZWNvbXA7XG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0O1xuICAgICAgbHRlZm4gPSBsdGU7XG4gICAgICBsdGZuID0gbHQ7XG4gICAgICBjb21wID0gJz4nO1xuICAgICAgZWNvbXAgPSAnPj0nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHQ7XG4gICAgICBsdGVmbiA9IGd0ZTtcbiAgICAgIGx0Zm4gPSBndDtcbiAgICAgIGNvbXAgPSAnPCc7XG4gICAgICBlY29tcCA9ICc8PSc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKTtcbiAgfVxuXG4gIC8vIElmIGl0IHNhdGlzaWZlcyB0aGUgcmFuZ2UgaXQgaXMgbm90IG91dHNpZGVcbiAgaWYgKHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgbG9vc2UpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXTtcblxuICAgIHZhciBoaWdoID0gbnVsbDtcbiAgICB2YXIgbG93ID0gbnVsbDtcblxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goZnVuY3Rpb24oY29tcGFyYXRvcikge1xuICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJylcbiAgICAgIH1cbiAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3I7XG4gICAgICBsb3cgPSBsb3cgfHwgY29tcGFyYXRvcjtcbiAgICAgIGlmIChndGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBoaWdoLnNlbXZlciwgbG9vc2UpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yO1xuICAgICAgfSBlbHNlIGlmIChsdGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBsb3cuc2VtdmVyLCBsb29zZSkpIHtcbiAgICAgICAgbG93ID0gY29tcGFyYXRvcjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIElmIHRoZSBlZGdlIHZlcnNpb24gY29tcGFyYXRvciBoYXMgYSBvcGVyYXRvciB0aGVuIG91ciB2ZXJzaW9uXG4gICAgLy8gaXNuJ3Qgb3V0c2lkZSBpdFxuICAgIGlmIChoaWdoLm9wZXJhdG9yID09PSBjb21wIHx8IGhpZ2gub3BlcmF0b3IgPT09IGVjb21wKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxvd2VzdCB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGFuIG9wZXJhdG9yIGFuZCBvdXIgdmVyc2lvblxuICAgIC8vIGlzIGxlc3MgdGhhbiBpdCB0aGVuIGl0IGlzbid0IGhpZ2hlciB0aGFuIHRoZSByYW5nZVxuICAgIGlmICgoIWxvdy5vcGVyYXRvciB8fCBsb3cub3BlcmF0b3IgPT09IGNvbXApICYmXG4gICAgICAgIGx0ZWZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vc2VtdmVyL3NlbXZlci5qc1xuICoqLyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKi8iLCIvKipcbiAqIEBmaWxlT3ZlcnZpZXdcbiAqIFZpZXdNb2RlbCBDb25zdHJ1Y3RvciAmIGRlZmluaXRpb25cbiAqL1xuXG5pbXBvcnQge2V4dGVuZCwgdG9BcnJheX0gZnJvbSAnLi4vdXRpbCdcblxuaW1wb3J0ICogYXMgc2NvcGUgZnJvbSAnLi9pbnN0YW5jZS9zY29wZSdcbmltcG9ydCAqIGFzIGNvbXBpbGVyIGZyb20gJy4vY29tcGlsZXInXG5pbXBvcnQgKiBhcyBkaXJlY3RpdmUgZnJvbSAnLi9kaXJlY3RpdmUnXG5pbXBvcnQgKiBhcyBkb21IZWxwZXIgZnJvbSAnLi9kb20taGVscGVyJ1xuaW1wb3J0ICogYXMgZXZlbnRzIGZyb20gJy4vZXZlbnRzJ1xuLy8gaW1wb3J0ICogYXMgbW9kdWxlcyBmcm9tICcuLy4uL2FwaS9tb2R1bGVzJ1xuLy8gaW1wb3J0ICogYXMgYXBpIGZyb20gJy4vLi4vYXBpL2FwaSdcblxuaW1wb3J0IHtyZWdpc3Rlck1vZHVsZXMsIHJlZ2lzdGVyTWV0aG9kc30gZnJvbSAnLi4vYXBwL3JlZ2lzdGVyJ1xuXG5mdW5jdGlvbiBjYWxsT2xkUmVhZHlFbnRyeSh2bSwgY29tcG9uZW50KSB7XG4gIGlmIChjb21wb25lbnQubWV0aG9kcyAmJlxuICAgICAgY29tcG9uZW50Lm1ldGhvZHMucmVhZHkpIHtcbiAgICBjb21wb25lbnQubWV0aG9kcy5yZWFkeS5jYWxsKHZtKVxuICB9XG59XG5cbi8qKlxuICogVmlld01vZGVsIGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRWbSAgIHdoaWNoIGNvbnRhaW5zIF9hcHBcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRFbCAgIHJvb3QgZWxlbWVudCBvciBmcmFnIGJsb2NrXG4gKiBAcGFyYW0ge29iamVjdH0gbWVyZ2VkRGF0YSBleHRlcm5hbCBkYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gZXh0ZXJuYWxFdmVudHMgZXh0ZXJuYWwgZXZlbnRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFZtKFxuICB0eXBlLFxuICBwYXJlbnRWbSxcbiAgcGFyZW50RWwsXG4gIG1lcmdlZERhdGEsXG4gIGV4dGVybmFsRXZlbnRzXG4pIHtcbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50Vm0uX3JlYWxQYXJlbnQgPyBwYXJlbnRWbS5fcmVhbFBhcmVudCA6IHBhcmVudFZtXG4gIHRoaXMuX2FwcCA9IHBhcmVudFZtLl9hcHBcbiAgcGFyZW50Vm0uX2NoaWxkcmVuVm1zICYmIHBhcmVudFZtLl9jaGlsZHJlblZtcy5wdXNoKHRoaXMpXG5cbiAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5fYXBwLmN1c3RvbUNvbXBvbmVudE1hcFt0eXBlXSB8fCB7fVxuICBjb25zdCBkYXRhID0gY29tcG9uZW50LmRhdGEgfHwge31cblxuICB0aGlzLl9vcHRpb25zID0gY29tcG9uZW50XG4gIHRoaXMuX21ldGhvZHMgPSBjb21wb25lbnQubWV0aG9kcyB8fCB7fVxuICB0aGlzLl9jb21wdXRlZCA9IGNvbXBvbmVudC5jb21wdXRlZCB8fCB7fVxuICB0aGlzLl9jc3MgPSBjb21wb25lbnQuc3R5bGUgfHwge31cbiAgdGhpcy5faWRzID0ge31cbiAgdGhpcy5fd2F0Y2hlcnMgPSBbXVxuICB0aGlzLl92bUV2ZW50cyA9IHt9XG4gIHRoaXMuX2NoaWxkcmVuVm1zID0gW11cbiAgdGhpcy5fdHlwZSA9IHR5cGVcblxuICAvLyBiaW5kIGV2ZW50cyBhbmQgbGlmZWN5Y2xlc1xuICB0aGlzLl9pbml0RXZlbnRzKGV4dGVybmFsRXZlbnRzKVxuXG4gIHRoaXMuJGVtaXQoJ2hvb2s6aW5pdCcpXG4gIHRoaXMuX2luaXRlZCA9IHRydWVcbiAgLy8gcHJveHkgZGF0YSBhbmQgbWV0aG9kc1xuICAvLyBvYnNlcnZlIGRhdGEgYW5kIGFkZCB0aGlzIHRvIHZtc1xuICB0aGlzLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicgPyBkYXRhKCkgOiBkYXRhXG4gIGlmIChtZXJnZWREYXRhKSB7XG4gICAgZXh0ZW5kKHRoaXMuX2RhdGEsIG1lcmdlZERhdGEpXG4gIH1cbiAgdGhpcy5faW5pdFNjb3BlKClcblxuICB0aGlzLiRlbWl0KCdob29rOmNyZWF0ZWQnKVxuICB0aGlzLl9jcmVhdGVkID0gdHJ1ZVxuICAvLyBiYWNrd2FyZCBvbGQgcmVhZHkgZW50cnlcbiAgY2FsbE9sZFJlYWR5RW50cnkodGhpcywgY29tcG9uZW50KVxuXG4gIC8vIGlmIG5vIHBhcmVudEVsZW1lbnQgdGhlbiBzcGVjaWZ5IHRoZSBkb2N1bWVudEVsZW1lbnRcbiAgdGhpcy5fcGFyZW50RWwgPSBwYXJlbnRFbCB8fCB0aGlzLl9hcHAuZG9jLmRvY3VtZW50RWxlbWVudFxuICB0aGlzLl9idWlsZCgpXG59XG5cbmV4dGVuZChWbS5wcm90b3R5cGUsIHNjb3BlLCBjb21waWxlciwgZGlyZWN0aXZlLCBkb21IZWxwZXIsIGV2ZW50cylcbmV4dGVuZChWbSwge1xuICByZWdpc3Rlck1vZHVsZXMsXG4gIHJlZ2lzdGVyTWV0aG9kc1xufSlcbi8vIFZtLnJlZ2lzdGVyTW9kdWxlcyhtb2R1bGVzKVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9saWIvdm0vaW5kZXguanNcbiAqKi8iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxudmFyIE9ic2VydmVyID0gcmVxdWlyZSgnLi4vb2JzZXJ2ZXInKVxudmFyIERlcCA9IHJlcXVpcmUoJy4uL29ic2VydmVyL2RlcCcpXG5cbi8qKlxuICogU2V0dXAgdGhlIHNjb3BlIG9mIGFuIGluc3RhbmNlLCB3aGljaCBjb250YWluczpcbiAqIC0gb2JzZXJ2ZWQgZGF0YVxuICogLSBjb21wdXRlZCBwcm9wZXJ0aWVzXG4gKiAtIHVzZXIgbWV0aG9kc1xuICogLSBtZXRhIHByb3BlcnRpZXNcbiAqL1xuXG5leHBvcnRzLl9pbml0U2NvcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2luaXREYXRhKClcbiAgdGhpcy5faW5pdENvbXB1dGVkKClcbiAgdGhpcy5faW5pdE1ldGhvZHMoKVxuICAvLyB0aGlzLl9pbml0TWV0YSgpXG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgZGF0YS4gXG4gKi9cblxuY29uc3QgS0VZX1dPUkRTID0gWyckaW5kZXgnLCAnJHZhbHVlJywgJyRldmVudCddXG5leHBvcnRzLl9pbml0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIgZGF0YSA9IHRoaXMuX2RhdGFcbiAgdmFyIGksIGtleVxuICAvLyAvLyBtYWtlIHN1cmUgYWxsIHByb3BzIHByb3BlcnRpZXMgYXJlIG9ic2VydmVkXG4gIC8vIHZhciBwcm9wcyA9IHRoaXMuJG9wdGlvbnMucHJvcHNcbiAgLy8gaWYgKHByb3BzKSB7XG4gIC8vICAgaSA9IHByb3BzLmxlbmd0aFxuICAvLyAgIHdoaWxlIChpLS0pIHtcbiAgLy8gICAgIGtleSA9IF8uY2FtZWxpemUocHJvcHNbaV0pXG4gIC8vICAgICBpZiAoIShrZXkgaW4gZGF0YSkpIHtcbiAgLy8gICAgICAgZGF0YVtrZXldID0gbnVsbFxuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy8gfVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpXG4gIGkgPSBrZXlzLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAga2V5ID0ga2V5c1tpXVxuICAgIGlmIChLRVlfV09SRFMuaW5kZXhPZihrZXkpID4gLTEgfHwgIV8uaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICB0aGlzLl9wcm94eShrZXkpXG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBPYnNlcnZlci5jcmVhdGUoZGF0YSkuYWRkVm0odGhpcylcbn1cblxuLy8gLyoqXG4vLyAgKiBTd2FwIHRoZSBpc250YW5jZSdzICRkYXRhLiBDYWxsZWQgaW4gJGRhdGEncyBzZXR0ZXIuXG4vLyAgKlxuLy8gICogQHBhcmFtIHtPYmplY3R9IG5ld0RhdGFcbi8vICAqL1xuXG4vLyBleHBvcnRzLl9zZXREYXRhID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbi8vICAgbmV3RGF0YSA9IG5ld0RhdGEgfHwge31cbi8vICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhXG4vLyAgIHRoaXMuX2RhdGEgPSBuZXdEYXRhXG4vLyAgIHZhciBrZXlzLCBrZXksIGlcbi8vICAgLy8gdW5wcm94eSBrZXlzIG5vdCBwcmVzZW50IGluIG5ldyBkYXRhXG4vLyAgIGtleXMgPSBPYmplY3Qua2V5cyhvbGREYXRhKVxuLy8gICBpID0ga2V5cy5sZW5ndGhcbi8vICAgd2hpbGUgKGktLSkge1xuLy8gICAgIGtleSA9IGtleXNbaV1cbi8vICAgICBpZiAoIV8uaXNSZXNlcnZlZChrZXkpICYmICEoa2V5IGluIG5ld0RhdGEpKSB7XG4vLyAgICAgICB0aGlzLl91bnByb3h5KGtleSlcbi8vICAgICB9XG4vLyAgIH1cbi8vICAgLy8gcHJveHkga2V5cyBub3QgYWxyZWFkeSBwcm94aWVkLFxuLy8gICAvLyBhbmQgdHJpZ2dlciBjaGFuZ2UgZm9yIGNoYW5nZWQgdmFsdWVzXG4vLyAgIGtleXMgPSBPYmplY3Qua2V5cyhuZXdEYXRhKVxuLy8gICBpID0ga2V5cy5sZW5ndGhcbi8vICAgd2hpbGUgKGktLSkge1xuLy8gICAgIGtleSA9IGtleXNbaV1cbi8vICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhXy5pc1Jlc2VydmVkKGtleSkpIHtcbi8vICAgICAgIC8vIG5ldyBwcm9wZXJ0eVxuLy8gICAgICAgdGhpcy5fcHJveHkoa2V5KVxuLy8gICAgIH1cbi8vICAgfVxuLy8gICBvbGREYXRhLl9fb2JfXy5yZW1vdmVWbSh0aGlzKVxuLy8gICBPYnNlcnZlci5jcmVhdGUobmV3RGF0YSkuYWRkVm0odGhpcylcbi8vICAgdGhpcy5fZGlnZXN0KClcbi8vIH1cblxuLyoqXG4gKiBQcm94eSBhIHByb3BlcnR5LCBzbyB0aGF0XG4gKiB2bS5wcm9wID09PSB2bS5fZGF0YS5wcm9wXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICovXG5cbmV4cG9ydHMuX3Byb3h5ID0gZnVuY3Rpb24gKGtleSkge1xuICAvLyBuZWVkIHRvIHN0b3JlIHJlZiB0byBzZWxmIGhlcmVcbiAgLy8gYmVjYXVzZSB0aGVzZSBnZXR0ZXIvc2V0dGVycyBtaWdodFxuICAvLyBiZSBjYWxsZWQgYnkgY2hpbGQgaW5zdGFuY2VzIVxuICB2YXIgc2VsZiA9IHRoaXNcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGtleSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgICAgcmV0dXJuIHNlbGYuX2RhdGFba2V5XVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgICBzZWxmLl9kYXRhW2tleV0gPSB2YWxcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogVW5wcm94eSBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqL1xuXG5leHBvcnRzLl91bnByb3h5ID0gZnVuY3Rpb24gKGtleSkge1xuICBkZWxldGUgdGhpc1trZXldXG59XG5cbi8vIC8qKlxuLy8gICogRm9yY2UgdXBkYXRlIG9uIGV2ZXJ5IHdhdGNoZXIgaW4gc2NvcGUuXG4vLyAgKi9cblxuLy8gZXhwb3J0cy5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuLy8gICB2YXIgaSA9IHRoaXMuX3dhdGNoZXJzLmxlbmd0aFxuLy8gICB3aGlsZSAoaS0tKSB7XG4vLyAgICAgdGhpcy5fd2F0Y2hlcnNbaV0udXBkYXRlKClcbi8vICAgfVxuLy8gICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlblxuLy8gICBpID0gY2hpbGRyZW4ubGVuZ3RoXG4vLyAgIHdoaWxlIChpLS0pIHtcbi8vICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuLy8gICAgIGlmIChjaGlsZC4kb3B0aW9ucy5pbmhlcml0KSB7XG4vLyAgICAgICBjaGlsZC5fZGlnZXN0KClcbi8vICAgICB9XG4vLyAgIH1cbi8vIH1cblxuLyoqXG4gKiBTZXR1cCBjb21wdXRlZCBwcm9wZXJ0aWVzLiBUaGV5IGFyZSBlc3NlbnRpYWxseVxuICogc3BlY2lhbCBnZXR0ZXIvc2V0dGVyc1xuICovXG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cbmV4cG9ydHMuX2luaXRDb21wdXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gdmFyIGNvbXB1dGVkID0gdGhpcy4kb3B0aW9ucy5jb21wdXRlZFxuICB2YXIgY29tcHV0ZWQgPSB0aGlzLl9jb21wdXRlZFxuICBpZiAoY29tcHV0ZWQpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XVxuICAgICAgdmFyIGRlZiA9IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGVmLmdldCA9IF8uYmluZCh1c2VyRGVmLCB0aGlzKVxuICAgICAgICBkZWYuc2V0ID0gbm9vcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICAgICAgPyBfLmJpbmQodXNlckRlZi5nZXQsIHRoaXMpXG4gICAgICAgICAgOiBub29wXG4gICAgICAgIGRlZi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgICAgID8gXy5iaW5kKHVzZXJEZWYuc2V0LCB0aGlzKVxuICAgICAgICAgIDogbm9vcFxuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwgZGVmKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNldHVwIGluc3RhbmNlIG1ldGhvZHMuIE1ldGhvZHMgbXVzdCBiZSBib3VuZCB0byB0aGVcbiAqIGluc3RhbmNlIHNpbmNlIHRoZXkgbWlnaHQgYmUgY2FsbGVkIGJ5IGNoaWxkcmVuXG4gKiBpbmhlcml0aW5nIHRoZW0uXG4gKi9cblxuZXhwb3J0cy5faW5pdE1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHZhciBtZXRob2RzID0gdGhpcy4kb3B0aW9ucy5tZXRob2RzXG4gIHZhciBtZXRob2RzID0gdGhpcy5fbWV0aG9kc1xuICBpZiAobWV0aG9kcykge1xuICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgICB0aGlzW2tleV0gPSBfLmJpbmQobWV0aG9kc1trZXldLCB0aGlzKVxuICAgIH1cbiAgfVxufVxuXG4vLyAvKipcbi8vICAqIEluaXRpYWxpemUgbWV0YSBpbmZvcm1hdGlvbiBsaWtlICRpbmRleCwgJGtleSAmICR2YWx1ZS5cbi8vICAqL1xuXG4vLyBleHBvcnRzLl9pbml0TWV0YSA9IGZ1bmN0aW9uICgpIHtcbi8vICAgdmFyIG1ldGFzID0gdGhpcy4kb3B0aW9ucy5fbWV0YVxuLy8gICBpZiAobWV0YXMpIHtcbi8vICAgICBmb3IgKHZhciBrZXkgaW4gbWV0YXMpIHtcbi8vICAgICAgIHRoaXMuX2RlZmluZU1ldGEoa2V5LCBtZXRhc1trZXldKVxuLy8gICAgIH1cbi8vICAgfVxuLy8gfVxuXG4vLyAvKipcbi8vICAqIERlZmluZSBhIG1ldGEgcHJvcGVydHksIGUuZyAkaW5kZXgsICRrZXksICR2YWx1ZVxuLy8gICogd2hpY2ggb25seSBleGlzdHMgb24gdGhlIHZtIGluc3RhbmNlIGJ1dCBub3QgaW4gJGRhdGEuXG4vLyAgKlxuLy8gICogQHBhcmFtIHtTdHJpbmd9IGtleVxuLy8gICogQHBhcmFtIHsqfSB2YWx1ZVxuLy8gICovXG5cbi8vIGV4cG9ydHMuX2RlZmluZU1ldGEgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuLy8gICB2YXIgZGVwID0gbmV3IERlcCgpXG4vLyAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbi8vICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuLy8gICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbi8vICAgICBnZXQ6IGZ1bmN0aW9uIG1ldGFHZXR0ZXIgKCkge1xuLy8gICAgICAgaWYgKE9ic2VydmVyLnRhcmdldCkge1xuLy8gICAgICAgICBPYnNlcnZlci50YXJnZXQuYWRkRGVwKGRlcClcbi8vICAgICAgIH1cbi8vICAgICAgIHJldHVybiB2YWx1ZVxuLy8gICAgIH0sXG4vLyAgICAgc2V0OiBmdW5jdGlvbiBtZXRhU2V0dGVyICh2YWwpIHtcbi8vICAgICAgIGlmICh2YWwgIT09IHZhbHVlKSB7XG4vLyAgICAgICAgIHZhbHVlID0gdmFsXG4vLyAgICAgICAgIGRlcC5ub3RpZnkoKVxuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgfSlcbi8vIH1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL3ZtL2luc3RhbmNlL3Njb3BlLmpzXG4gKiovIiwiLy8gcmVxdWlyZWQgZm9yIGNvZGUgaW4gaW5zdGFuY2Uvb2JzZXJ2ZXJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vdXRpbCcpXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9saWIvdm0vdXRpbC5qc1xuICoqLyIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJylcbnZhciBEZXAgPSByZXF1aXJlKCcuL2RlcCcpXG52YXIgYXJyYXlNZXRob2RzID0gcmVxdWlyZSgnLi9hcnJheScpXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKVxucmVxdWlyZSgnLi9vYmplY3QnKVxuXG52YXIgdWlkID0gMFxuXG4vKipcbiAqIFR5cGUgZW51bXNcbiAqL1xuXG52YXIgQVJSQVkgID0gMFxudmFyIE9CSkVDVCA9IDFcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1xuICovXG5cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyY1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvXG4gKi9cblxuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIHZhciBpID0ga2V5cy5sZW5ndGhcbiAgdmFyIGtleVxuICB3aGlsZSAoaS0tKSB7XG4gICAga2V5ID0ga2V5c1tpXVxuICAgIF8uZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSlcbiAgfVxufVxuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlLCB0eXBlKSB7XG4gIHRoaXMuaWQgPSArK3VpZFxuICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgdGhpcy5hY3RpdmUgPSB0cnVlXG4gIHRoaXMuZGVwcyA9IFtdXG4gIF8uZGVmaW5lKHZhbHVlLCAnX19vYl9fJywgdGhpcylcbiAgaWYgKHR5cGUgPT09IEFSUkFZKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBjb25maWcucHJvdG8gJiYgXy5oYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnRcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cylcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSlcbiAgfSBlbHNlIGlmICh0eXBlID09PSBPQkpFQ1QpIHtcbiAgICB0aGlzLndhbGsodmFsdWUpXG4gIH1cbn1cblxuT2JzZXJ2ZXIudGFyZ2V0ID0gbnVsbFxuXG52YXIgcCA9IE9ic2VydmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge09ic2VydmVyfHVuZGVmaW5lZH1cbiAqIEBzdGF0aWNcbiAqL1xuXG5PYnNlcnZlci5jcmVhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKFxuICAgIHZhbHVlICYmXG4gICAgdmFsdWUuaGFzT3duUHJvcGVydHkoJ19fb2JfXycpICYmXG4gICAgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXJcbiAgKSB7XG4gICAgcmV0dXJuIHZhbHVlLl9fb2JfX1xuICB9IGVsc2UgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmVyKHZhbHVlLCBBUlJBWSlcbiAgfSBlbHNlIGlmIChcbiAgICBfLmlzUGxhaW5PYmplY3QodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZSAvLyBhdm9pZCBWdWUgaW5zdGFuY2VcbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZlcih2YWx1ZSwgT0JKRUNUKVxuICB9XG59XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LiBQcm9wZXJ0aWVzIHByZWZpeGVkIHdpdGggYCRgIG9yIGBfYFxuICogYW5kIGFjY2Vzc29yIHByb3BlcnRpZXMgYXJlIGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICovXG5cbnAud2FsayA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopXG4gIHZhciBpID0ga2V5cy5sZW5ndGhcbiAgdmFyIGtleSwgcHJlZml4XG4gIHdoaWxlIChpLS0pIHtcbiAgICBrZXkgPSBrZXlzW2ldXG4gICAgcHJlZml4ID0ga2V5LmNoYXJDb2RlQXQoMClcbiAgICBpZiAocHJlZml4ICE9PSAweDI0ICYmIHByZWZpeCAhPT0gMHg1RikgeyAvLyBza2lwICQgb3IgX1xuICAgICAgdGhpcy5jb252ZXJ0KGtleSwgb2JqW2tleV0pXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVHJ5IHRvIGNhcmV0ZSBhbiBvYnNlcnZlciBmb3IgYSBjaGlsZCB2YWx1ZSxcbiAqIGFuZCBpZiB2YWx1ZSBpcyBhcnJheSwgbGluayBkZXAgdG8gdGhlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtEZXB8dW5kZWZpbmVkfVxuICovXG5cbnAub2JzZXJ2ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIE9ic2VydmVyLmNyZWF0ZSh2YWwpXG59XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gaXRlbXNcbiAqL1xuXG5wLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIChpdGVtcykge1xuICB2YXIgaSA9IGl0ZW1zLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcy5vYnNlcnZlKGl0ZW1zW2ldKVxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBhIHByb3BlcnR5IGludG8gZ2V0dGVyL3NldHRlciBzbyB3ZSBjYW4gZW1pdFxuICogdGhlIGV2ZW50cyB3aGVuIHRoZSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZC9jaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxucC5jb252ZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gIHZhciBvYiA9IHRoaXNcbiAgdmFyIGNoaWxkT2IgPSBvYi5vYnNlcnZlKHZhbClcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKVxuICBpZiAoY2hpbGRPYikge1xuICAgIGNoaWxkT2IuZGVwcy5wdXNoKGRlcClcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2IudmFsdWUsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gT2JzZXJ2ZXIudGFyZ2V0IGlzIGEgd2F0Y2hlciB3aG9zZSBnZXR0ZXIgaXNcbiAgICAgIC8vIGN1cnJlbnRseSBiZWluZyBldmFsdWF0ZWQuXG4gICAgICBpZiAob2IuYWN0aXZlICYmIE9ic2VydmVyLnRhcmdldCkge1xuICAgICAgICBPYnNlcnZlci50YXJnZXQuYWRkRGVwKGRlcClcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKG5ld1ZhbCkge1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsKSByZXR1cm5cbiAgICAgIC8vIHJlbW92ZSBkZXAgZnJvbSBvbGQgdmFsdWVcbiAgICAgIHZhciBvbGRDaGlsZE9iID0gdmFsICYmIHZhbC5fX29iX19cbiAgICAgIGlmIChvbGRDaGlsZE9iKSB7XG4gICAgICAgIG9sZENoaWxkT2IuZGVwcy4kcmVtb3ZlKGRlcClcbiAgICAgIH1cbiAgICAgIHZhbCA9IG5ld1ZhbFxuICAgICAgLy8gYWRkIGRlcCB0byBuZXcgdmFsdWVcbiAgICAgIHZhciBuZXdDaGlsZE9iID0gb2Iub2JzZXJ2ZShuZXdWYWwpXG4gICAgICBpZiAobmV3Q2hpbGRPYikge1xuICAgICAgICBuZXdDaGlsZE9iLmRlcHMucHVzaChkZXApXG4gICAgICB9XG4gICAgICBkZXAubm90aWZ5KClcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogTm90aWZ5IGNoYW5nZSBvbiBhbGwgc2VsZiBkZXBzIG9uIGFuIG9ic2VydmVyLlxuICogVGhpcyBpcyBjYWxsZWQgd2hlbiBhIG11dGFibGUgdmFsdWUgbXV0YXRlcy4gZS5nLlxuICogd2hlbiBhbiBBcnJheSdzIG11dGF0aW5nIG1ldGhvZHMgYXJlIGNhbGxlZCwgb3IgYW5cbiAqIE9iamVjdCdzICRhZGQvJGRlbGV0ZSBhcmUgY2FsbGVkLlxuICovXG5cbnAubm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGVwcyA9IHRoaXMuZGVwc1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGRlcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGVwc1tpXS5ub3RpZnkoKVxuICB9XG59XG5cbi8qKlxuICogQWRkIGFuIG93bmVyIHZtLCBzbyB0aGF0IHdoZW4gJGFkZC8kZGVsZXRlIG11dGF0aW9uc1xuICogaGFwcGVuIHdlIGNhbiBub3RpZnkgb3duZXIgdm1zIHRvIHByb3h5IHRoZSBrZXlzIGFuZFxuICogZGlnZXN0IHRoZSB3YXRjaGVycy4gVGhpcyBpcyBvbmx5IGNhbGxlZCB3aGVuIHRoZSBvYmplY3RcbiAqIGlzIG9ic2VydmVkIGFzIGFuIGluc3RhbmNlJ3Mgcm9vdCAkZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5wLmFkZFZtID0gZnVuY3Rpb24gKHZtKSB7XG4gICh0aGlzLnZtcyA9IHRoaXMudm1zIHx8IFtdKS5wdXNoKHZtKVxufVxuXG4vKipcbiAqIFJlbW92ZSBhbiBvd25lciB2bS4gVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgb2JqZWN0IGlzXG4gKiBzd2FwcGVkIG91dCBhcyBhbiBpbnN0YW5jZSdzICRkYXRhIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5wLnJlbW92ZVZtID0gZnVuY3Rpb24gKHZtKSB7XG4gIHRoaXMudm1zLiRyZW1vdmUodm0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gT2JzZXJ2ZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL3ZtL29ic2VydmVyL2luZGV4LmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7cHJvdG86IHRydWV9XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2xpYi92bS9jb25maWcuanNcbiAqKi8iLCJ2YXIgXyA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLnN1YnMgPSBbXVxufVxuXG52YXIgcCA9IERlcC5wcm90b3R5cGVcblxuLyoqXG4gKiBBZGQgYSBkaXJlY3RpdmUgc3Vic2NyaWJlci5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gc3ViXG4gKi9cblxucC5hZGRTdWIgPSBmdW5jdGlvbiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yilcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBkaXJlY3RpdmUgc3Vic2NyaWJlci5cbiAqXG4gKiBAcGFyYW0ge0RpcmVjdGl2ZX0gc3ViXG4gKi9cblxucC5yZW1vdmVTdWIgPSBmdW5jdGlvbiAoc3ViKSB7XG4gIHRoaXMuc3Vicy4kcmVtb3ZlKHN1Yilcbn1cblxuLyoqXG4gKiBOb3RpZnkgYWxsIHN1YnNjcmliZXJzIG9mIGEgbmV3IHZhbHVlLlxuICovXG5cbnAubm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAvLyBzdGFibGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gXy50b0FycmF5KHRoaXMuc3VicylcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERlcFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL3ZtL29ic2VydmVyL2RlcC5qc1xuICoqLyIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZVxudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90bylcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xuXG47W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXVxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdXG4gIF8uZGVmaW5lKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICAvLyBhdm9pZCBsZWFraW5nIGFyZ3VtZW50czpcbiAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9jbG9zdXJlLXdpdGgtYXJndW1lbnRzXG4gICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSlcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fXG4gICAgdmFyIGluc2VydGVkXG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3NcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3NcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKVxuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIG9iLm9ic2VydmVBcnJheShpbnNlcnRlZClcbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2Iubm90aWZ5KClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pXG59KVxuXG4vKipcbiAqIFN3YXAgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGggYSBuZXcgdmFsdWVcbiAqIGFuZCBlbWl0cyBjb3JyZXNwb25kaW5nIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4geyp9IC0gcmVwbGFjZWQgZWxlbWVudFxuICovXG5cbl8uZGVmaW5lKFxuICBhcnJheVByb3RvLFxuICAnJHNldCcsXG4gIGZ1bmN0aW9uICRzZXQgKGluZGV4LCB2YWwpIHtcbiAgICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gaW5kZXggKyAxXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMSwgdmFsKVswXVxuICB9XG4pXG5cbi8qKlxuICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJlbW92ZSB0aGUgZWxlbWVudCBhdCBnaXZlbiBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuXy5kZWZpbmUoXG4gIGFycmF5UHJvdG8sXG4gICckcmVtb3ZlJyxcbiAgZnVuY3Rpb24gJHJlbW92ZSAoaW5kZXgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm5cbiAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgaW5kZXggPSBfLmluZGV4T2YodGhpcywgaW5kZXgpXG4gICAgfVxuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbilcblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1ldGhvZHNcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2xpYi92bS9vYnNlcnZlci9hcnJheS5qc1xuICoqLyIsInZhciBfID0gcmVxdWlyZSgnLi4vdXRpbCcpXG52YXIgb2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlXG5cbi8qKlxuICogQWRkIGEgbmV3IHByb3BlcnR5IHRvIGFuIG9ic2VydmVkIG9iamVjdFxuICogYW5kIGVtaXRzIGNvcnJlc3BvbmRpbmcgZXZlbnRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHB1YmxpY1xuICovXG5cbl8uZGVmaW5lKFxuICBvYmpQcm90byxcbiAgJyRhZGQnLFxuICBmdW5jdGlvbiAkYWRkIChrZXksIHZhbCkge1xuICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KGtleSkpIHJldHVyblxuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fXG4gICAgaWYgKCFvYiB8fCBfLmlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgdGhpc1trZXldID0gdmFsXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgb2IuY29udmVydChrZXksIHZhbClcbiAgICBvYi5ub3RpZnkoKVxuICAgIGlmIChvYi52bXMpIHtcbiAgICAgIHZhciBpID0gb2Iudm1zLmxlbmd0aFxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgdm0gPSBvYi52bXNbaV1cbiAgICAgICAgdm0uX3Byb3h5KGtleSlcbiAgICAgICAgLy8gdm0uX2RpZ2VzdCgpIC8vIHRvZG9cbiAgICAgIH1cbiAgICB9XG4gIH1cbilcblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYnNlcnZlZCBvYmplY3QsIGNhbGxpbmcgYWRkIHRvXG4gKiBlbnN1cmUgdGhlIHByb3BlcnR5IGlzIG9ic2VydmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcHVibGljXG4gKi9cblxuXy5kZWZpbmUoXG4gIG9ialByb3RvLFxuICAnJHNldCcsXG4gIGZ1bmN0aW9uICRzZXQgKGtleSwgdmFsKSB7XG4gICAgdGhpcy4kYWRkKGtleSwgdmFsKVxuICAgIHRoaXNba2V5XSA9IHZhbFxuICB9XG4pXG5cbi8qKlxuICogRGVsZXRlcyBhIHByb3BlcnR5IGZyb20gYW4gb2JzZXJ2ZWQgb2JqZWN0XG4gKiBhbmQgZW1pdHMgY29ycmVzcG9uZGluZyBldmVudFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwdWJsaWNcbiAqL1xuXG5fLmRlZmluZShcbiAgb2JqUHJvdG8sXG4gICckZGVsZXRlJyxcbiAgZnVuY3Rpb24gJGRlbGV0ZSAoa2V5KSB7XG4gICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KGtleSkpIHJldHVyblxuICAgIGRlbGV0ZSB0aGlzW2tleV1cbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfX1xuICAgIGlmICghb2IgfHwgXy5pc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBvYi5ub3RpZnkoKVxuICAgIGlmIChvYi52bXMpIHtcbiAgICAgIHZhciBpID0gb2Iudm1zLmxlbmd0aFxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgdm0gPSBvYi52bXNbaV1cbiAgICAgICAgdm0uX3VucHJveHkoa2V5KVxuICAgICAgICAvLyB2bS5fZGlnZXN0KCkgLy8gdG9kb1xuICAgICAgfVxuICAgIH1cbiAgfVxuKVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9saWIvdm0vb2JzZXJ2ZXIvb2JqZWN0LmpzXG4gKiovIiwiLyoqXG4gKiBAZmlsZU92ZXJ2aWV3XG4gKiBWaWV3TW9kZWwgdGVtcGxhdGUgcGFyc2VyICYgZGF0YS1iaW5kaW5nIHByb2Nlc3NcbiAqXG4gKiByZXF1aXJlZDpcbiAqIGluZGV4LmpzOiBWbVxuICogZG9tLWhlbHBlci5qczogX2NyZWF0ZUVsZW1lbnQsIF9jcmVhdGVCbG9ja1xuICogZG9tLWhlbHBlci5qczogX2F0dGFjaFRhcmdldCwgX21vdmVUYXJnZXQsIF9yZW1vdmVUYXJnZXRcbiAqIGRpcmVjdGl2ZS5qczogX2JpbmRFbGVtZW50LCBfYmluZFN1YlZtLCBfd2F0Y2hcbiAqIGV2ZW50cy5qczogJG9uXG4gKi9cblxuLyoqXG4gKiBidWlsZChleHRlcm5hbERpcnMpXG4gKiAgIGNyZWF0ZVZtKClcbiAqICAgbWVyZ2UoZXh0ZXJuYWxEaXJzLCBkaXJzKVxuICogICBjb21waWxlKHRlbXBsYXRlLCBwYXJlbnROb2RlKVxuICogICAgIGlmICh0eXBlIGlzIGNvbnRlbnQpIGNyZWF0ZSBjb250ZW50Tm9kZVxuICogICAgIGVsc2UgaWYgKGRpcnMgaGF2ZSB2LWZvcikgZm9yZWFjaCAtPiBjcmVhdGUgY29udGV4dFxuICogICAgICAgLT4gY29tcGlsZSh0ZW1wbGF0ZVdpdGhvdXRGb3IsIHBhcmVudE5vZGUpOiBkaWZmKGxpc3QpIG9uY2hhbmdlXG4gKiAgICAgZWxzZSBpZiAoZGlycyBoYXZlIHYtaWYpIGFzc2VydFxuICogICAgICAgLT4gY29tcGlsZSh0ZW1wbGF0ZVdpdGhvdXRJZiwgcGFyZW50Tm9kZSk6IHRvZ2dsZShzaG93bikgb25jaGFuZ2VcbiAqICAgICBlbHNlIGlmICh0eXBlIGlzIG5hdGl2ZSlcbiAqICAgICAgIHNldChkaXJzKTogdXBkYXRlKGlkL2F0dHIvc3R5bGUvY2xhc3MpIG9uY2hhbmdlXG4gKiAgICAgICBhcHBlbmQodGVtcGxhdGUsIHBhcmVudE5vZGUpXG4gKiAgICAgICBmb3JlYWNoIGNoaWxkTm9kZXMgLT4gY29tcGlsZShjaGlsZE5vZGUsIHRlbXBsYXRlKVxuICogICAgIGVsc2UgaWYgKHR5cGUgaXMgY3VzdG9tKVxuICogICAgICAgYWRkQ2hpbGRWbSh2bSwgcGFyZW50Vm0pXG4gKiAgICAgICBidWlsZChleHRlcm5hbERpcnMpXG4gKiAgICAgICBmb3JlYWNoIGNoaWxkTm9kZXMgLT4gY29tcGlsZShjaGlsZE5vZGUsIHRlbXBsYXRlKVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2J1aWxkKCkge1xuICBjb25zdCBvcHQgPSB0aGlzLl9vcHRpb25zIHx8IHt9XG4gIGNvbnN0IHRlbXBsYXRlID0gb3B0LnRlbXBsYXRlIHx8IHt9XG5cbiAgaWYgKG9wdC5yZXBsYWNlKSB7XG4gICAgaWYgKHRlbXBsYXRlLmNoaWxkcmVuICYmIHRlbXBsYXRlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5fY29tcGlsZSh0ZW1wbGF0ZS5jaGlsZHJlblswXSwgdGhpcy5fcGFyZW50RWwpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fY29tcGlsZSh0ZW1wbGF0ZS5jaGlsZHJlbiwgdGhpcy5fcGFyZW50RWwpXG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuX2NvbXBpbGUodGVtcGxhdGUsIHRoaXMuX3BhcmVudEVsKVxuICB9XG5cbiAgdGhpcy4kZW1pdCgnaG9vazpyZWFkeScpXG4gIHRoaXMuX3JlYWR5ID0gdHJ1ZVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIGVsZW1lbnRzIGJ5IGNoaWxkIG9yIGNoaWxkcmVuIGFuZCBhcHBlbmQgdG8gcGFyZW50IGVsZW1lbnRzLlxuICogUm9vdCBlbGVtZW50IGluZm8gd291bGQgYmUgbWVyZ2VkIGlmIGhhcy4gVGhlIGZpcnN0IGFyZ3VtZW50IG1heSBiZSBhbiBhcnJheVxuICogaWYgdGhlIHJvb3QgZWxlbWVudCB3aXRoIG9wdGlvbnMucmVwbGFjZSBoYXMgbm90IG9ubHkgb25lIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGFycmF5fSB0YXJnZXRcbiAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICBkZXN0XG4gKiBAcGFyYW0ge29iamVjdH0gICAgICAgbWV0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NvbXBpbGUodGFyZ2V0LCBkZXN0LCBtZXRhKSB7XG4gIGxldCBjb250ZXh0ID0gdGhpc1xuICBpZiAoY29udGV4dC5fdGFyZ2V0SXNGcmFnbWVudCh0YXJnZXQpKSB7XG4gICAgY29udGV4dC5fY29tcGlsZUZyYWdtZW50KHRhcmdldCwgZGVzdCwgbWV0YSlcbiAgICByZXR1cm5cbiAgfVxuICBtZXRhID0gbWV0YSB8fCB7fVxuICBpZiAoY29udGV4dC5fdGFyZ2V0SXNDb250ZW50KHRhcmdldCkpIHtcbiAgICBjb250ZXh0Ll9jb250ZW50ID0gY29udGV4dC5fY3JlYXRlQmxvY2soZGVzdClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChjb250ZXh0Ll90YXJnZXROZWVkQ2hlY2tSZXBlYXQodGFyZ2V0LCBtZXRhKSkge1xuICAgIGNvbnRleHQuX2NvbXBpbGVSZXBlYXQodGFyZ2V0LCBkZXN0KVxuICAgIHJldHVyblxuICB9XG4gIGlmIChjb250ZXh0Ll90YXJnZXROZWVkQ2hlY2tTaG93bih0YXJnZXQsIG1ldGEpKSB7XG4gICAgY29udGV4dC5fY29tcGlsZVNob3duKHRhcmdldCwgZGVzdCwgbWV0YSlcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCB0eXBlR2V0dGVyID0gbWV0YS50eXBlIHx8IHRhcmdldC50eXBlXG4gIGlmIChjb250ZXh0Ll90YXJnZXROZWVkQ2hlY2tUeXBlKHR5cGVHZXR0ZXIsIG1ldGEpKSB7XG4gICAgY29udGV4dC5fY29tcGlsZVR5cGUodGFyZ2V0LCBkZXN0LCB0eXBlR2V0dGVyLCBtZXRhKVxuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHR5cGUgPSB0eXBlR2V0dGVyXG4gIGlmIChjb250ZXh0Ll90YXJnZXRJc0NvbXBvc2VkKHRhcmdldCwgdHlwZSkpIHtcbiAgICBjb250ZXh0Ll9jb21waWxlQ3VzdG9tQ29tcG9uZW50KHRhcmdldCwgZGVzdCwgdHlwZSwgbWV0YSlcbiAgICByZXR1cm5cbiAgfVxuICBjb250ZXh0Ll9jb21waWxlTmF0aXZlQ29tcG9uZW50KHRhcmdldCwgZGVzdCwgdHlwZSlcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0YXJnZXQgaXMgYSBmcmFnbWVudCAoYW4gYXJyYXkpLlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gIHRhcmdldFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF90YXJnZXRJc0ZyYWdtZW50KHRhcmdldCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0YXJnZXQpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGFyZ2V0IHR5cGUgaXMgY29udGVudC9zbG90LlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gIHRhcmdldFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF90YXJnZXRJc0NvbnRlbnQodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQudHlwZSA9PT0gJ2NvbnRlbnQnIHx8IHRhcmdldC50eXBlID09PSAnc2xvdCdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0YXJnZXQgbmVlZCB0byBjb21waWxlIGJ5IGEgbGlzdC5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9ICB0YXJnZXRcbiAqIEBwYXJhbSAge29iamVjdH0gIG1ldGFcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfdGFyZ2V0TmVlZENoZWNrUmVwZWF0KHRhcmdldCwgbWV0YSkge1xuICByZXR1cm4gIW1ldGEuaGFzT3duUHJvcGVydHkoJ3JlcGVhdCcpICYmIHRhcmdldC5yZXBlYXRcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0YXJnZXQgbmVlZCB0byBjb21waWxlIGJ5IGEgYm9vbGVhbiB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9ICB0YXJnZXRcbiAqIEBwYXJhbSAge29iamVjdH0gIG1ldGFcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfdGFyZ2V0TmVlZENoZWNrU2hvd24odGFyZ2V0LCBtZXRhKSB7XG4gIHJldHVybiAhbWV0YS5oYXNPd25Qcm9wZXJ0eSgnc2hvd24nKSAmJiB0YXJnZXQuc2hvd25cbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0YXJnZXQgbmVlZCB0byBjb21waWxlIGJ5IGEgZHluYW1pYyB0eXBlLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ3xmdW5jdGlvbn0gdHlwZUdldHRlclxuICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICBtZXRhXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3RhcmdldE5lZWRDaGVja1R5cGUodHlwZUdldHRlciwgbWV0YSkge1xuICByZXR1cm4gKHR5cGVvZiB0eXBlR2V0dGVyID09PSAnZnVuY3Rpb24nKSAmJiAhbWV0YS5oYXNPd25Qcm9wZXJ0eSgndHlwZScpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBraW5kIG9mIGNvbXBvbmVudCBpcyBjb21wb3NlZC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICB0eXBlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3RhcmdldElzQ29tcG9zZWQodGFyZ2V0LCB0eXBlKSB7XG4gIGlmICh0aGlzLl9hcHAgJiYgdGhpcy5fYXBwLmN1c3RvbUNvbXBvbmVudE1hcCAmJiB0eXBlKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fYXBwLmN1c3RvbUNvbXBvbmVudE1hcFt0eXBlXVxuICB9XG4gIHJldHVybiAhIXRhcmdldC5jb21wb25lbnRcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgbGlzdCBvZiB0YXJnZXRzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge29iamVjdH0gbWV0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NvbXBpbGVGcmFnbWVudCh0YXJnZXQsIGRlc3QsIG1ldGEpIHtcbiAgY29uc3QgZnJhZ0Jsb2NrID0gdGhpcy5fY3JlYXRlQmxvY2soZGVzdClcbiAgdGFyZ2V0LmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgdGhpcy5fY29tcGlsZShjaGlsZCwgZnJhZ0Jsb2NrLCBtZXRhKVxuICB9KVxufVxuXG4vKipcbiAqIENvbXBpbGUgYSB0YXJnZXQgd2l0aCByZXBlYXQgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBkZXN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY29tcGlsZVJlcGVhdCh0YXJnZXQsIGRlc3QpIHtcbiAgY29uc3QgcmVwZWF0ID0gdGFyZ2V0LnJlcGVhdFxuICBjb25zdCBvbGRTdHlsZSA9IHR5cGVvZiByZXBlYXQgPT09ICdmdW5jdGlvbidcbiAgbGV0IGdldHRlciA9IHJlcGVhdC5nZXR0ZXIgfHwgcmVwZWF0LmV4cHJlc3Npb24gfHwgcmVwZWF0XG4gIGlmICh0eXBlb2YgZ2V0dGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgZ2V0dGVyID0gZnVuY3Rpb24gKCkge3JldHVybiBbXX1cbiAgfVxuICBjb25zdCBrZXkgPSByZXBlYXQua2V5IHx8ICckaW5kZXgnXG4gIGNvbnN0IHZhbHVlID0gcmVwZWF0LnZhbHVlIHx8ICckdmFsdWUnXG4gIGNvbnN0IHRyYWNrQnkgPSByZXBlYXQudHJhY2tCeSB8fCB0YXJnZXQudHJhY2tCeSB8fFxuICAgICh0YXJnZXQuYXR0ciAmJiB0YXJnZXQuYXR0ci50cmFja0J5KSB8fCBrZXlcblxuICBjb25zdCBmcmFnQmxvY2sgPSB0aGlzLl9jcmVhdGVCbG9jayhkZXN0KVxuICBmcmFnQmxvY2suY2hpbGRyZW4gPSBbXVxuICBmcmFnQmxvY2suZGF0YSA9IFtdXG4gIGZyYWdCbG9jay52bXMgPSBbXVxuXG4gIHRoaXMuX2JpbmRSZXBlYXQodGFyZ2V0LCBmcmFnQmxvY2ssIHtnZXR0ZXIsIGtleSwgdmFsdWUsIHRyYWNrQnksIG9sZFN0eWxlfSlcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgdGFyZ2V0IHdpdGggaWYgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge29iamVjdH0gbWV0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NvbXBpbGVTaG93bih0YXJnZXQsIGRlc3QsIG1ldGEpIHtcbiAgY29uc3QgbmV3TWV0YSA9IHtzaG93bjogdHJ1ZX1cbiAgY29uc3QgZnJhZ0Jsb2NrID0gdGhpcy5fY3JlYXRlQmxvY2soZGVzdClcblxuICBpZiAoZGVzdC5lbGVtZW50ICYmIGRlc3QuY2hpbGRyZW4pIHtcbiAgICBkZXN0LmNoaWxkcmVuLnB1c2goZnJhZ0Jsb2NrKVxuICB9XG5cbiAgaWYgKG1ldGEucmVwZWF0KSB7XG4gICAgbmV3TWV0YS5yZXBlYXQgPSBtZXRhLnJlcGVhdFxuICB9XG5cbiAgdGhpcy5fYmluZFNob3duKHRhcmdldCwgZnJhZ0Jsb2NrLCBuZXdNZXRhKVxufVxuXG4vKipcbiAqIENvbXBpbGUgYSB0YXJnZXQgd2l0aCBkeW5hbWljIGNvbXBvbmVudCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSAgIHRhcmdldFxuICogQHBhcmFtIHtvYmplY3R9ICAgZGVzdFxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHlwZUdldHRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NvbXBpbGVUeXBlKHRhcmdldCwgZGVzdCwgdHlwZUdldHRlciwgbWV0YSkge1xuICBjb25zdCB0eXBlID0gdHlwZUdldHRlci5jYWxsKHRoaXMpXG4gIGNvbnN0IG5ld01ldGEgPSBPYmplY3QuYXNzaWduKHt0eXBlfSwgbWV0YSlcbiAgY29uc3QgZnJhZ0Jsb2NrID0gdGhpcy5fY3JlYXRlQmxvY2soZGVzdClcblxuICBpZiAoZGVzdC5lbGVtZW50ICYmIGRlc3QuY2hpbGRyZW4pIHtcbiAgICBkZXN0LmNoaWxkcmVuLnB1c2goZnJhZ0Jsb2NrKVxuICB9XG5cbiAgdGhpcy5fd2F0Y2godHlwZUdldHRlciwgKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgbmV3TWV0YSA9IE9iamVjdC5hc3NpZ24oe3R5cGU6IHZhbHVlfSwgbWV0YSlcbiAgICB0aGlzLl9yZW1vdmVCbG9jayhmcmFnQmxvY2ssIHRydWUpXG4gICAgdGhpcy5fY29tcGlsZSh0YXJnZXQsIGZyYWdCbG9jaywgbmV3TWV0YSlcbiAgfSlcblxuICB0aGlzLl9jb21waWxlKHRhcmdldCwgZnJhZ0Jsb2NrLCBuZXdNZXRhKVxufVxuXG4vKipcbiAqIENvbXBpbGUgYSBjb21wb3NlZCBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtvYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY29tcGlsZUN1c3RvbUNvbXBvbmVudCh0YXJnZXQsIGRlc3QsIHR5cGUsIG1ldGEpIHtcbiAgY29uc3QgVm0gPSB0aGlzLmNvbnN0cnVjdG9yXG4gIGNvbnN0IGNvbnRleHQgPSB0aGlzXG4gIGNvbnN0IHN1YlZtID0gbmV3IFZtKHR5cGUsIGNvbnRleHQsIGRlc3QsIHVuZGVmaW5lZCwge1xuICAgICdob29rOmluaXQnOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjb250ZXh0Ll9zZXRJZCh0YXJnZXQuaWQsIG51bGwsIHRoaXMpXG4gICAgfSxcbiAgICAnaG9vazpjcmVhdGVkJzogZnVuY3Rpb24gKCkge1xuICAgICAgY29udGV4dC5fYmluZFN1YlZtKHRoaXMsIHRhcmdldCwgbWV0YS5yZXBlYXQpXG4gICAgfSxcbiAgICAnaG9vazpyZWFkeSc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICAgIGNvbnRleHQuX2NvbXBpbGVDaGlsZHJlbih0YXJnZXQsIHRoaXMuX2NvbnRlbnQpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICB0aGlzLl9iaW5kU3ViVm1BZnRlckluaXRpYWxpemVkKHN1YlZtLCB0YXJnZXQpXG59XG5cbi8qKlxuICogR2VuZXJhdGUgZWxlbWVudCBmcm9tIHRlbXBsYXRlIGFuZCBhdHRhY2ggdG8gdGhlIGRlc3QgaWYgbmVlZGVkLlxuICogVGhlIHRpbWUgdG8gYXR0YWNoIGRlcGVuZHMgb24gd2hldGhlciB0aGUgbW9kZSBzdGF0dXMgaXMgbm9kZSBvciB0cmVlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0ZW1wbGF0ZVxuICogQHBhcmFtIHtvYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY29tcGlsZU5hdGl2ZUNvbXBvbmVudCh0ZW1wbGF0ZSwgZGVzdCwgdHlwZSkge1xuXG4gIHRoaXMuX2FwcGx5TmFpdHZlQ29tcG9uZW50T3B0aW9ucyh0ZW1wbGF0ZSlcblxuICBsZXQgZWxlbWVudFxuICBpZiAoZGVzdC5yZWYgPT09ICdfZG9jdW1lbnRFbGVtZW50Jykge1xuICAgIC8vIGlmIGl0cyBwYXJlbnQgaXMgZG9jdW1lbnRFbGVtZW50IHRoZW4gaXQncyBhIGJvZHlcbiAgICBlbGVtZW50ID0gdGhpcy5fY3JlYXRlQm9keSh0eXBlKVxuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQgPSB0aGlzLl9jcmVhdGVFbGVtZW50KHR5cGUpXG4gIH1cbiAgLy8gVE9ETyBpdCB3YXMgYSByb290IGVsZW1lbnQgd2hlbiBub3QgaW4gYSBmcmFnbWVudFxuICBpZiAoIXRoaXMuX3Jvb3RFbCkge1xuICAgIHRoaXMuX3Jvb3RFbCA9IGVsZW1lbnRcbiAgfVxuXG4gIHRoaXMuX2JpbmRFbGVtZW50KGVsZW1lbnQsIHRlbXBsYXRlKVxuXG4gIGlmICh0ZW1wbGF0ZS5hdHRyICYmIHRlbXBsYXRlLmF0dHIuYXBwZW5kKSB7IC8vIGJhY2t3YXJkLCBhcHBlbmQgcHJvcCBpbiBhdHRyXG4gICAgdGVtcGxhdGUuYXBwZW5kID0gdGVtcGxhdGUuYXR0ci5hcHBlbmRcbiAgfVxuXG4gIGlmICh0ZW1wbGF0ZS5hcHBlbmQpIHsgLy8gZ2l2ZSB0aGUgYXBwZW5kIGF0dHJpYnV0ZSBmb3IgaW9zIGFkYXB0YXRpb25cbiAgICBlbGVtZW50LmF0dHIgPSBlbGVtZW50LmF0dHIgfHwge31cbiAgICBlbGVtZW50LmF0dHIuYXBwZW5kID0gdGVtcGxhdGUuYXBwZW5kXG4gIH1cblxuICBjb25zdCB0cmVlTW9kZSA9IHRlbXBsYXRlLmFwcGVuZCA9PT0gJ3RyZWUnXG4gIGlmICghdHJlZU1vZGUpIHtcbiAgICB0aGlzLl9hdHRhY2hUYXJnZXQoZWxlbWVudCwgZGVzdClcbiAgfVxuICB0aGlzLl9jb21waWxlQ2hpbGRyZW4odGVtcGxhdGUsIGVsZW1lbnQpXG4gIGlmICh0cmVlTW9kZSkge1xuICAgIHRoaXMuX2F0dGFjaFRhcmdldChlbGVtZW50LCBkZXN0KVxuICB9XG59XG5cbi8qKlxuICogU2V0IGFsbCBjaGlsZHJlbiB0byBhIGNlcnRhaW4gcGFyZW50IGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHRlbXBsYXRlXG4gKiBAcGFyYW0ge29iamVjdH0gZGVzdFxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NvbXBpbGVDaGlsZHJlbih0ZW1wbGF0ZSwgZGVzdCkge1xuICBjb25zdCBjaGlsZHJlbiA9IHRlbXBsYXRlLmNoaWxkcmVuXG4gIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZShjaGlsZCwgZGVzdClcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogV2F0Y2ggdGhlIGxpc3QgdXBkYXRlIGFuZCByZWZyZXNoIHRoZSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBmcmFnQmxvY2sge3ZtcywgZGF0YSwgY2hpbGRyZW59XG4gKiBAcGFyYW0ge29iamVjdH0gaW5mbyAgICAgIHtnZXR0ZXIsIGtleSwgdmFsdWUsIHRyYWNrQnksIG9sZFN0eWxlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2JpbmRSZXBlYXQodGFyZ2V0LCBmcmFnQmxvY2ssIGluZm8pIHtcbiAgY29uc3Qgdm1zID0gZnJhZ0Jsb2NrLnZtc1xuICBjb25zdCBjaGlsZHJlbiA9IGZyYWdCbG9jay5jaGlsZHJlblxuICBjb25zdCB7Z2V0dGVyLCB0cmFja0J5LCBvbGRTdHlsZX0gPSBpbmZvXG4gIGNvbnN0IGtleU5hbWUgPSBpbmZvLmtleVxuICBjb25zdCB2YWx1ZU5hbWUgPSBpbmZvLnZhbHVlXG5cbiAgZnVuY3Rpb24gY29tcGlsZUl0ZW0oaXRlbSwgaW5kZXgsIGNvbnRleHQpIHtcbiAgICBsZXQgbWVyZ2VkRGF0YVxuICAgIGlmIChvbGRTdHlsZSkge1xuICAgICAgbWVyZ2VkRGF0YSA9IGl0ZW1cbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbWVyZ2VkRGF0YVtrZXlOYW1lXSA9IGluZGV4XG4gICAgICAgIGlmICghbWVyZ2VkRGF0YS5oYXNPd25Qcm9wZXJ0eSgnSU5ERVgnKSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXJnZWREYXRhLCAnSU5ERVgnLCB7XG4gICAgICAgICAgICB2YWx1ZTogKCkgPT4ge1xuICAgICAgICAgICAgICBuYXRpdmVMb2coJ1tXQVJOSU5HXSBcIklOREVYXCIgaW4gcmVwZWF0IGlzIGRlcHJlY2F0ZWQsJyArXG4gICAgICAgICAgICAgICAgJyBwbGVhc2UgdXNlIFwiJGluZGV4XCIgaW5zdGVhZCcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG1lcmdlZERhdGEgPSB7fVxuICAgICAgbWVyZ2VkRGF0YVtrZXlOYW1lXSA9IGluZGV4XG4gICAgICBtZXJnZWREYXRhW3ZhbHVlTmFtZV0gPSBpdGVtXG4gICAgfVxuICAgIGNvbnRleHQgPSBjb250ZXh0Ll9tZXJnZUNvbnRleHQobWVyZ2VkRGF0YSlcbiAgICAvLyBjb25zb2xlLmxvZyhjb250ZXh0KVxuICAgIHZtcy5wdXNoKGNvbnRleHQpXG4gICAgY29udGV4dC5fY29tcGlsZSh0YXJnZXQsIGZyYWdCbG9jaywge3JlcGVhdDogaXRlbX0pXG4gIH1cblxuICBmdW5jdGlvbiBkaWZmSXRlbSh2bSwgaXRlbSkge1xuICAgIGNvbnN0IG9sZEl0ZW0gPSB2bS5fZGF0YVxuICAgIGNvbnN0IG9sZEtleXMgPSBbXVxuICAgIGZvciAoY29uc3Qga2V5IGluIG9sZEl0ZW0pIHtcbiAgICAgIGlmICghaXRlbS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHZtW2tleV0gPSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaXRlbSkge1xuICAgICAgdm1ba2V5XSA9IGl0ZW1ba2V5XVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEl0ZW1WYWx1ZShpdGVtLCBpbmRleCwgdm0pIHtcbiAgICBsZXQgbWVyZ2VkRGF0YVxuICAgIGlmIChvbGRTdHlsZSkge1xuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICBkaWZmSXRlbSh2bSwgaXRlbSlcbiAgICAgICAgdm0uSU5ERVggPSBpbmRleFxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZtW2tleU5hbWVdID0gaW5kZXhcbiAgICAgIHZtW3ZhbHVlTmFtZV0gPSBpdGVtXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbGlzdCA9IHRoaXMuX3dhdGNoQmxvY2soZnJhZ0Jsb2NrLCBnZXR0ZXIsICdyZXBlYXQnLFxuICAgIChkYXRhKSA9PiB7XG4gICAgICBpZiAoIWZyYWdCbG9jaykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2xkQ2hpbGRyZW4gPSBjaGlsZHJlbi5zbGljZSgpXG4gICAgICBjb25zdCBvbGRWbXMgPSB2bXMuc2xpY2UoKVxuICAgICAgY29uc3Qgb2xkRGF0YSA9IGZyYWdCbG9jay5kYXRhLnNsaWNlKClcbiAgICAgIC8vIDEuIGNvbGxlY3QgYWxsIG5ldyByZWZzIHRyYWNrIGJ5XG4gICAgICBjb25zdCB0cmFja01hcCA9IHt9XG4gICAgICBjb25zdCByZXVzZWRNYXAgPSB7fVxuICAgICAgZGF0YS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSB0cmFja0J5ID8gaXRlbVt0cmFja0J5XSA6IGluZGV4XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoa2V5ID09IG51bGwgfHwga2V5ID09PSAnJykge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHRyYWNrTWFwW2tleV0gPSBpdGVtXG4gICAgICB9KVxuXG4gICAgICAvLyAyLiByZW1vdmUgdW51c2VkIGVsZW1lbnQgZm9yZWFjaCBvbGQgaXRlbVxuICAgICAgY29uc3QgcmV1c2VkTGlzdCA9IFtdXG4gICAgICBvbGREYXRhLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRyYWNrQnkgPyBpdGVtW3RyYWNrQnldIDogaW5kZXhcbiAgICAgICAgaWYgKHRyYWNrTWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICByZXVzZWRNYXBba2V5XSA9IHtcbiAgICAgICAgICAgIGl0ZW0sIGluZGV4LCBrZXksXG4gICAgICAgICAgICB0YXJnZXQ6IG9sZENoaWxkcmVuW2luZGV4XSxcbiAgICAgICAgICAgIHZtOiBvbGRWbXNbaW5kZXhdXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldXNlZExpc3QucHVzaChpdGVtKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZVRhcmdldChvbGRDaGlsZHJlbltpbmRleF0pXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIC8vIDMuIGNyZWF0ZSBuZXcgZWxlbWVudCBmb3JlYWNoIG5ldyBpdGVtXG4gICAgICBjaGlsZHJlbi5sZW5ndGggPSAwXG4gICAgICB2bXMubGVuZ3RoID0gMFxuICAgICAgZnJhZ0Jsb2NrLmRhdGEgPSBkYXRhLnNsaWNlKClcbiAgICAgIGZyYWdCbG9jay51cGRhdGVNYXJrID0gZnJhZ0Jsb2NrLnN0YXJ0XG5cbiAgICAgIGRhdGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gdHJhY2tCeSA/IGl0ZW1bdHJhY2tCeV0gOiBpbmRleFxuICAgICAgICBjb25zdCByZXVzZWQgPSByZXVzZWRNYXBba2V5XVxuICAgICAgICBpZiAocmV1c2VkKSB7XG4gICAgICAgICAgaWYgKHJldXNlZC5pdGVtID09PSByZXVzZWRMaXN0WzBdKSB7XG4gICAgICAgICAgICByZXVzZWRMaXN0LnNoaWZ0KClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV1c2VkTGlzdC4kcmVtb3ZlKHJldXNlZC5pdGVtKVxuICAgICAgICAgICAgdGhpcy5fbW92ZVRhcmdldChyZXVzZWQudGFyZ2V0LCBmcmFnQmxvY2sudXBkYXRlTWFyaywgdHJ1ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChyZXVzZWQudGFyZ2V0KVxuICAgICAgICAgIHZtcy5wdXNoKHJldXNlZC52bSlcbiAgICAgICAgICByZXVzZWQudm1ba2V5TmFtZV0gPSBpbmRleFxuICAgICAgICAgIGZyYWdCbG9jay51cGRhdGVNYXJrID0gcmV1c2VkLnRhcmdldFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbXBpbGVJdGVtKGl0ZW0sIGluZGV4LCB0aGlzKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBkZWxldGUgZnJhZ0Jsb2NrLnVwZGF0ZU1hcmtcbiAgICB9XG4gIClcblxuICBmcmFnQmxvY2suZGF0YSA9IGxpc3Quc2xpY2UoMClcbiAgbGlzdC5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgIGNvbXBpbGVJdGVtKGl0ZW0sIGluZGV4LCB0aGlzKVxuICB9KVxufVxuXG4vKipcbiAqIFdhdGNoIHRoZSBkaXNwbGF5IHVwZGF0ZSBhbmQgYWRkL3JlbW92ZSB0aGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IHRhcmdldFxuICogQHBhcmFtICB7b2JqZWN0fSBmcmFnQmxvY2tcbiAqIEBwYXJhbSAge29iamVjdH0gY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gX2JpbmRTaG93bih0YXJnZXQsIGZyYWdCbG9jaywgbWV0YSkge1xuICBjb25zdCBkaXNwbGF5ID0gdGhpcy5fd2F0Y2hCbG9jayhmcmFnQmxvY2ssIHRhcmdldC5zaG93biwgJ3Nob3duJyxcbiAgICAoZGlzcGxheSkgPT4ge1xuICAgICAgaWYgKCFmcmFnQmxvY2sgfHwgISFmcmFnQmxvY2suZGlzcGxheSA9PT0gISFkaXNwbGF5KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZnJhZ0Jsb2NrLmRpc3BsYXkgPSAhIWRpc3BsYXlcbiAgICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGUodGFyZ2V0LCBmcmFnQmxvY2ssIG1ldGEpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlQmxvY2soZnJhZ0Jsb2NrLCB0cnVlKVxuICAgICAgfVxuICAgIH1cbiAgKVxuXG4gIGZyYWdCbG9jay5kaXNwbGF5ID0gISFkaXNwbGF5XG4gIGlmIChkaXNwbGF5KSB7XG4gICAgdGhpcy5fY29tcGlsZSh0YXJnZXQsIGZyYWdCbG9jaywgbWV0YSlcbiAgfVxufVxuXG4vKipcbiAqIFdhdGNoIGNhbGMgdmFsdWUgY2hhbmdlcyBhbmQgYXBwZW5kIGNlcnRhaW4gdHlwZSBhY3Rpb24gdG8gZGlmZmVyLlxuICogSXQgaXMgdXNlZCBmb3IgaWYgb3IgcmVwZWF0IGRhdGEtYmluZGluZyBnZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSAgIGZyYWdCbG9ja1xuICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGNcbiAqIEBwYXJhbSAge3N0cmluZ30gICB0eXBlXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gaGFuZGxlclxuICogQHJldHVybiB7YW55fSAgICAgIGluaXQgdmFsdWUgb2YgY2FsY1xuICovXG5leHBvcnQgZnVuY3Rpb24gX3dhdGNoQmxvY2soZnJhZ0Jsb2NrLCBjYWxjLCB0eXBlLCBoYW5kbGVyKSB7XG4gIGNvbnN0IGRpZmZlciA9IHRoaXMgJiYgdGhpcy5fYXBwICYmIHRoaXMuX2FwcC5kaWZmZXJcbiAgY29uc3QgY29uZmlnID0ge31cbiAgY29uc3QgZGVwdGggPSAoZnJhZ0Jsb2NrLmVsZW1lbnQuZGVwdGggfHwgMCkgKyAxXG5cbiAgcmV0dXJuIHRoaXMuX3dhdGNoKGNhbGMsICh2YWx1ZSkgPT4ge1xuICAgIGNvbmZpZy5sYXRlc3RWYWx1ZSA9IHZhbHVlXG4gICAgaWYgKGRpZmZlciAmJiAhY29uZmlnLnJlY29yZGVkKSB7XG4gICAgICBkaWZmZXIuYXBwZW5kKHR5cGUsIGRlcHRoLCBmcmFnQmxvY2suYmxvY2tJZCwgKCkgPT4ge1xuICAgICAgICBjb25zdCBsYXRlc3RWYWx1ZSA9IGNvbmZpZy5sYXRlc3RWYWx1ZVxuICAgICAgICBoYW5kbGVyKGxhdGVzdFZhbHVlKVxuICAgICAgICBjb25maWcucmVjb3JkZWQgPSBmYWxzZVxuICAgICAgICBjb25maWcubGF0ZXN0VmFsdWUgPSB1bmRlZmluZWRcbiAgICAgIH0pXG4gICAgfVxuICAgIGNvbmZpZy5yZWNvcmRlZCA9IHRydWVcbiAgfSlcbn1cblxuLyoqXG4gKiBDbG9uZSBhIGNvbnRleHQgYW5kIG1lcmdlIGNlcnRhaW4gZGF0YS5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IG1lcmdlZERhdGFcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9tZXJnZUNvbnRleHQobWVyZ2VkRGF0YSkge1xuICBjb25zdCBjb250ZXh0ID0gT2JqZWN0LmNyZWF0ZSh0aGlzKVxuICBjb250ZXh0Ll9kYXRhID0gbWVyZ2VkRGF0YVxuICBjb250ZXh0Ll9pbml0RGF0YSgpXG4gIGNvbnRleHQuX3JlYWxQYXJlbnQgPSB0aGlzXG4gIHJldHVybiBjb250ZXh0XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2xpYi92bS9jb21waWxlci5qc1xuICoqLyIsIi8qKlxuICogQGZpbGVPdmVydmlld1xuICogRGlyZWN0aXZlIFBhcnNlclxuICovXG5cbmltcG9ydCB7YmluZCwgZXh0ZW5kfSBmcm9tICcuLi91dGlsJ1xuXG5pbXBvcnQgV2F0Y2hlciBmcm9tICcuL3dhdGNoZXInXG5pbXBvcnQge25hdGl2ZUNvbXBvbmVudE1hcH0gZnJvbSAnLi4vY29uZmlnJ1xuXG5jb25zdCBTRVRURVJTID0ge1xuICBhdHRyOiAnc2V0QXR0cicsXG4gIHN0eWxlOiAnc2V0U3R5bGUnLFxuICBldmVudDogJ2FkZEV2ZW50J1xufVxuXG4vKipcbiAqIGFwcGx5IHRoZSBuYXRpdmUgY29tcG9uZW50J3Mgb3B0aW9ucyhzcGVjaWZpZWQgYnkgdGVtcGxhdGUudHlwZSlcbiAqIHRvIHRoZSB0ZW1wbGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FwcGx5TmFpdHZlQ29tcG9uZW50T3B0aW9ucyh0ZW1wbGF0ZSkge1xuICBjb25zdCB7dHlwZX0gPSB0ZW1wbGF0ZVxuICBjb25zdCBvcHRpb25zID0gbmF0aXZlQ29tcG9uZW50TWFwW3R5cGVdXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgIGV4dGVuZCh0ZW1wbGF0ZSwgb3B0aW9ucylcbiAgfVxufVxuXG4vKipcbiAqIGJpbmQgYWxsIGlkLCBhdHRyLCBjbGFzc25hbWVzLCBzdHlsZSwgZXZlbnRzIHRvIGFuIGVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9iaW5kRWxlbWVudChlbCwgdGVtcGxhdGUpIHtcbiAgdGhpcy5fc2V0SWQodGVtcGxhdGUuaWQsIGVsLCB0aGlzKVxuICB0aGlzLl9zZXRBdHRyKGVsLCB0ZW1wbGF0ZS5hdHRyKVxuICB0aGlzLl9zZXRDbGFzcyhlbCwgdGVtcGxhdGUuY2xhc3NMaXN0KVxuICB0aGlzLl9zZXRTdHlsZShlbCwgdGVtcGxhdGUuc3R5bGUpXG4gIHRoaXMuX2JpbmRFdmVudHMoZWwsIHRlbXBsYXRlLmV2ZW50cylcbn1cblxuLyoqXG4gKiBiaW5kIGFsbCBwcm9wcyB0byBzdWIgdm0gYW5kIGJpbmQgYWxsIHN0eWxlLCBldmVudHMgdG8gdGhlIHJvb3QgZWxlbWVudFxuICogb2YgdGhlIHN1YiB2bSBpZiBpdCBkb2Vzbid0IGhhdmUgYSByZXBsYWNlZCBtdWx0aS1ub2RlIGZyYWdtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYmluZFN1YlZtKHN1YlZtLCB0ZW1wbGF0ZSwgcmVwZWF0SXRlbSkge1xuICBzdWJWbSA9IHN1YlZtIHx8IHt9XG4gIHRlbXBsYXRlID0gdGVtcGxhdGUgfHwge31cblxuICBjb25zdCBvcHRpb25zID0gc3ViVm0uX29wdGlvbnMgfHwge31cblxuICAvLyBiaW5kIHByb3BzXG4gIGxldCBwcm9wcyA9IG9wdGlvbnMucHJvcHNcblxuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBwcm9wcyA9IHByb3BzLnJlZHVjZSgocmVzdWx0LCB2YWx1ZSkgPT4ge1xuICAgICAgcmVzdWx0W3ZhbHVlXSA9IHRydWVcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9LCB7fSlcbiAgfVxuXG4gIG1lcmdlUHJvcHMocmVwZWF0SXRlbSwgcHJvcHMsIHRoaXMsIHN1YlZtKVxuICBtZXJnZVByb3BzKHRlbXBsYXRlLmF0dHIsIHByb3BzLCB0aGlzLCBzdWJWbSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9iaW5kU3ViVm1BZnRlckluaXRpYWxpemVkKHN1YlZtLCB0ZW1wbGF0ZSkge1xuICBtZXJnZUNsYXNzU3R5bGUodGVtcGxhdGUuY2xhc3NMaXN0LCB0aGlzLCBzdWJWbSlcbiAgbWVyZ2VTdHlsZSh0ZW1wbGF0ZS5zdHlsZSwgdGhpcywgc3ViVm0pXG4gIG1lcmdlRXZlbnQodGVtcGxhdGUuZXZlbnRzLCB0aGlzLCBzdWJWbSlcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyh0YXJnZXQsIHByb3BzLCB2bSwgc3ViVm0pIHtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICByZXR1cm5cbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXQpIHtcbiAgICBpZiAoIXByb3BzIHx8IHByb3BzW2tleV0pIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0W2tleV1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSB2bS5fd2F0Y2godmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgc3ViVm1ba2V5XSA9IHZcbiAgICAgICAgfSlcbiAgICAgICAgc3ViVm1ba2V5XSA9IHJldHVyblZhbHVlXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3ViVm1ba2V5XSA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlU3R5bGUodGFyZ2V0LCB2bSwgc3ViVm0pIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgY29uc3QgdmFsdWUgPSB0YXJnZXRba2V5XVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gdm0uX3dhdGNoKHZhbHVlLCBmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAoc3ViVm0uX3Jvb3RFbCkge1xuICAgICAgICAgIHN1YlZtLl9yb290RWwuc2V0U3R5bGUoa2V5LCB2KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgc3ViVm0uX3Jvb3RFbC5zZXRTdHlsZShrZXksIHJldHVyblZhbHVlKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChzdWJWbS5fcm9vdEVsKSB7XG4gICAgICAgIHN1YlZtLl9yb290RWwuc2V0U3R5bGUoa2V5LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc1N0eWxlKHRhcmdldCwgdm0sIHN1YlZtKSB7XG4gIHZhciBjc3MgPSB2bS5fb3B0aW9ucyAmJiB2bS5fb3B0aW9ucy5zdHlsZSB8fCB7fVxuXG4gIGlmICghc3ViVm0uX3Jvb3RFbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHZtLl93YXRjaCh0YXJnZXQsICB2ID0+IHtcbiAgICAgIHNldENsYXNzU3R5bGUoc3ViVm0uX3Jvb3RFbCwgY3NzLCB2KVxuICAgIH0pXG4gICAgc2V0Q2xhc3NTdHlsZShzdWJWbS5fcm9vdEVsLCBjc3MsIHZhbHVlKVxuICB9IGVsc2UgaWYgKHRhcmdldCkge1xuICAgIHNldENsYXNzU3R5bGUoc3ViVm0uX3Jvb3RFbCwgY3NzLCB0YXJnZXQpXG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VFdmVudCh0YXJnZXQsIHZtLCBzdWJWbSkge1xuICBpZiAodGFyZ2V0ICYmIHN1YlZtLl9yb290RWwpIHtcbiAgICBmb3IgKGNvbnN0IHR5cGUgaW4gdGFyZ2V0KSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gdm1bdGFyZ2V0W3R5cGVdXVxuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgc3ViVm0uX3Jvb3RFbC5hZGRFdmVudCh0eXBlLCBiaW5kKGhhbmRsZXIsIHZtKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBiaW5kIGlkIHRvIGFuIGVsZW1lbnRcbiAqIGVhY2ggaWQgaXMgdW5pcXVlIGluIGEgd2hvbGUgdm1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zZXRJZChpZCwgZWwsIHZtKSB7XG4gIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhtYXAsIHtcbiAgICB2bToge1xuICAgICAgdmFsdWU6IHZtLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgIH0sXG4gICAgZWw6IHtcbiAgICAgIGdldDogKCkgPT4gZWwgfHwgdm0uX3Jvb3RFbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9XG4gIH0pXG5cbiAgaWYgKHR5cGVvZiBpZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBpZFxuICAgIGlkID0gaGFuZGxlci5jYWxsKHRoaXMpXG4gICAgaWYgKGlkKSB7XG4gICAgICB0aGlzLl9pZHNbaWRdID0gbWFwXG4gICAgfVxuICAgIHRoaXMuX3dhdGNoKGhhbmRsZXIsIChuZXdJZCkgPT4ge1xuICAgICAgaWYgKG5ld0lkKSB7XG4gICAgICAgIHRoaXMuX2lkc1tuZXdJZF0gPSBtYXBcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGVsc2UgaWYgKGlkICYmIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLl9pZHNbaWRdID0gbWFwXG4gIH1cbn1cblxuLyoqXG4gKiBiaW5kIGF0dHIgdG8gYW4gZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gX3NldEF0dHIoZWwsIGF0dHIpIHtcbiAgdGhpcy5fYmluZERpcihlbCwgJ2F0dHInLCBhdHRyKVxufVxuXG5mdW5jdGlvbiBzZXRDbGFzc1N0eWxlKGVsLCBjc3MsIGNsYXNzTGlzdCkge1xuICBjb25zdCBjbGFzc1N0eWxlID0ge31cbiAgY29uc3QgbGVuZ3RoID0gY2xhc3NMaXN0Lmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzdHlsZSA9IGNzc1tjbGFzc0xpc3RbaV1dXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZSkge1xuICAgICAgICBjbGFzc1N0eWxlW2tleV0gPSBzdHlsZVtrZXldXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsLnNldENsYXNzU3R5bGUoY2xhc3NTdHlsZSlcbn1cblxuLyoqXG4gKiBiaW5kIGNsYXNzbmFtZXMgdG8gYW4gZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gX3NldENsYXNzKGVsLCBjbGFzc0xpc3QpIHtcblxuICBpZiAodHlwZW9mIGNsYXNzTGlzdCAhPT0gJ2Z1bmN0aW9uJyAmJiAhQXJyYXkuaXNBcnJheShjbGFzc0xpc3QpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2xhc3NMaXN0KSAmJiAhY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgIGVsLnNldENsYXNzU3R5bGUoe30pXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBzdHlsZSA9IHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5zdHlsZSB8fCB7fVxuICBpZiAodHlwZW9mIGNsYXNzTGlzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fd2F0Y2goY2xhc3NMaXN0LCAgdiA9PiB7XG4gICAgICBzZXRDbGFzc1N0eWxlKGVsLCBzdHlsZSwgdilcbiAgICB9KVxuICAgIHNldENsYXNzU3R5bGUoZWwsIHN0eWxlLCB2YWx1ZSlcbiAgfVxuICBlbHNlIHtcbiAgICBzZXRDbGFzc1N0eWxlKGVsLCBzdHlsZSwgY2xhc3NMaXN0KVxuICB9XG59XG5cbi8qKlxuICogYmluZCBzdHlsZSB0byBhbiBlbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc2V0U3R5bGUoZWwsIHN0eWxlKSB7XG4gIHRoaXMuX2JpbmREaXIoZWwsICdzdHlsZScsIHN0eWxlKVxufVxuXG4vKipcbiAqIGFkZCBhbiBldmVudCB0eXBlIGFuZCBoYW5kbGVyIHRvIGFuIGVsZW1lbnQgYW5kIGdlbmVyYXRlIGEgZG9tIHVwZGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3NldEV2ZW50KGVsLCB0eXBlLCBoYW5kbGVyKSB7XG4gIGVsLmFkZEV2ZW50KHR5cGUsIGJpbmQoaGFuZGxlciwgdGhpcykpXG59XG5cbi8qKlxuICogYWRkIGFsbCBldmVudHMgb2YgYW4gZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gX2JpbmRFdmVudHMoZWwsIGV2ZW50cykge1xuICBpZiAoIWV2ZW50cykge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpXG4gIGxldCBpID0ga2V5cy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICBsZXQgaGFuZGxlciA9IGV2ZW50c1trZXldXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgICAgaGFuZGxlciA9IHRoaXNbaGFuZGxlcl1cbiAgICB9XG4gICAgdGhpcy5fc2V0RXZlbnQoZWwsIGtleSwgaGFuZGxlcilcbiAgfVxufVxuXG4vKipcbiAqIHNldCBhIHNlcmllcyBvZiBtZW1iZXJzIGFzIGEga2luZCBvZiBhbiBlbGVtZW50XG4gKiBmb3IgZXhhbXBsZTogc3R5bGUsIGF0dHIsIC4uLlxuICogaWYgdGhlIHZhbHVlIGlzIGEgZnVuY3Rpb24gdGhlbiBiaW5kIHRoZSBkYXRhIGNoYW5nZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9iaW5kRGlyKGVsLCBuYW1lLCBkYXRhKSB7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKVxuICBsZXQgaSA9IGtleXMubGVuZ3RoXG4gIHdoaWxlIChpLS0pIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgY29uc3QgdmFsdWUgPSBkYXRhW2tleV1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCB1cGRhdGUgPSB2YWx1ZVxuICAgICAgdGhpcy5fYmluZEtleShlbCwgbmFtZSwga2V5LCB1cGRhdGUpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZWxbU0VUVEVSU1tuYW1lXV0oa2V5LCB2YWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBiaW5kIGRhdGEgY2hhbmdlcyB0byBhIGNlcnRhaW4ga2V5IHRvIGEgbmFtZSBzZXJpZXMgaW4gYW4gZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gX2JpbmRLZXkoZWwsIG5hbWUsIGtleSwgY2FsYykge1xuICBjb25zdCBtZXRob2ROYW1lID0gU0VUVEVSU1tuYW1lXVxuICBjb25zdCBvYmogPSBlbFtuYW1lXVxuICAvLyB3YXRjaCB0aGUgY2FsYywgYW5kIHJldHVybnMgYSB2YWx1ZSBieSBjYWxjLmNhbGwoKVxuICBjb25zdCB2YWx1ZSA9IHRoaXMuX3dhdGNoKGNhbGMsICh2YWx1ZSkgPT4ge1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICBlbFttZXRob2ROYW1lXShrZXksIHZhbHVlKVxuICAgIH1cbiAgICBjb25zdCBkaWZmZXIgPSB0aGlzICYmIHRoaXMuX2FwcCAmJiB0aGlzLl9hcHAuZGlmZmVyXG4gICAgaWYgKGRpZmZlcikge1xuICAgICAgZGlmZmVyLmFwcGVuZCgnZWxlbWVudCcsIGVsLmRlcHRoLCBlbC5yZWYsIGhhbmRsZXIpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGFuZGxlcigpXG4gICAgfVxuICB9KVxuXG4gIGVsW21ldGhvZE5hbWVdKGtleSwgdmFsdWUpXG59XG5cbi8qKlxuICogd2F0Y2ggYSBjYWxjIGZ1bmN0aW9uIGFuZCBjYWxsYmFjayBpZiB0aGUgY2FsYyB2YWx1ZSBjaGFuZ2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfd2F0Y2goY2FsYywgY2FsbGJhY2spIHtcbiAgY29uc3Qgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHRoaXMsIGNhbGMsIGZ1bmN0aW9uICh2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJiB2YWx1ZSA9PT0gb2xkVmFsdWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsYmFjayh2YWx1ZSlcbiAgfSlcblxuICByZXR1cm4gd2F0Y2hlci52YWx1ZVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9saWIvdm0vZGlyZWN0aXZlLmpzXG4gKiovIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSBZdXhpIEV2YW4gWW91XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG52YXIgXyA9IHJlcXVpcmUoJy4vdXRpbCcpXG4vLyB2YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKVxudmFyIE9ic2VydmVyID0gcmVxdWlyZSgnLi9vYnNlcnZlcicpXG4vLyB2YXIgZXhwUGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXJzL2V4cHJlc3Npb24nKVxuLy8gdmFyIGJhdGNoZXIgPSByZXF1aXJlKCcuL2JhdGNoZXInKVxudmFyIHVpZCA9IDBcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7U3RyaW5nfSBleHByZXNzaW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICAgICAgICAgICAtIHtBcnJheX0gZmlsdGVyc1xuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHR3b1dheVxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGRlZXBcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSB1c2VyXG4gKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IFtwcmVQcm9jZXNzXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuLy8gZnVuY3Rpb24gV2F0Y2hlciAodm0sIGV4cHJlc3Npb24sIGNiLCBvcHRpb25zKSB7XG5mdW5jdGlvbiBXYXRjaGVyICh2bSwgdXBkYXRlLCBjYikge1xuICB0aGlzLnZtID0gdm1cbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcylcbiAgLy8gdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvblxuICB0aGlzLmNiID0gY2JcbiAgdGhpcy5pZCA9ICsrdWlkIC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlXG4gIC8vIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIC8vIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwXG4gIC8vIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyXG4gIC8vIHRoaXMudHdvV2F5ID0gISFvcHRpb25zLnR3b1dheVxuICAvLyB0aGlzLmZpbHRlcnMgPSBvcHRpb25zLmZpbHRlcnNcbiAgLy8gdGhpcy5wcmVQcm9jZXNzID0gb3B0aW9ucy5wcmVQcm9jZXNzXG4gIHRoaXMuZGVwcyA9IFtdXG4gIHRoaXMubmV3RGVwcyA9IFtdXG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlci9zZXR0ZXJcbiAgLy8gdmFyIHJlcyA9IGV4cFBhcnNlci5wYXJzZShleHByZXNzaW9uLCBvcHRpb25zLnR3b1dheSlcbiAgLy8gdGhpcy5nZXR0ZXIgPSByZXMuZ2V0XG4gIC8vIHRoaXMuc2V0dGVyID0gcmVzLnNldFxuICB0aGlzLmdldHRlciA9IHVwZGF0ZVxuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKVxufVxuXG52YXIgcCA9IFdhdGNoZXIucHJvdG90eXBlXG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0RlcH0gZGVwXG4gKi9cblxucC5hZGREZXAgPSBmdW5jdGlvbiAoZGVwKSB7XG4gIHZhciBuZXdEZXBzID0gdGhpcy5uZXdEZXBzXG4gIHZhciBvbGQgPSB0aGlzLmRlcHNcbiAgaWYgKF8uaW5kZXhPZihuZXdEZXBzLCBkZXApIDwgMCkge1xuICAgIG5ld0RlcHMucHVzaChkZXApXG4gICAgdmFyIGkgPSBfLmluZGV4T2Yob2xkLCBkZXApXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9sZFtpXSA9IG51bGxcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cblxucC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYmVmb3JlR2V0KClcbiAgdmFyIHZtID0gdGhpcy52bVxuICB2YXIgdmFsdWVcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaWYgKGNvbmZpZy53YXJuRXhwcmVzc2lvbkVycm9ycykge1xuICAgIC8vICAgXy53YXJuKFxuICAgIC8vICAgICAnRXJyb3Igd2hlbiBldmFsdWF0aW5nIGV4cHJlc3Npb24gXCInICtcbiAgICAvLyAgICAgdGhpcy5leHByZXNzaW9uICsgJ1wiOlxcbiAgICcgKyBlXG4gICAgLy8gICApXG4gICAgLy8gfVxuICAgIF8ud2FybignRXJyb3Igd2hlbiB1cGRhdGVcIicpXG4gIH1cbiAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICBpZiAodGhpcy5kZWVwKSB7XG4gICAgdHJhdmVyc2UodmFsdWUpXG4gIH1cbiAgaWYgKHRoaXMucHJlUHJvY2Vzcykge1xuICAgIHZhbHVlID0gdGhpcy5wcmVQcm9jZXNzKHZhbHVlKVxuICB9XG4gIGlmICh0aGlzLmZpbHRlcnMpIHtcbiAgICB2YWx1ZSA9IHZtLl9hcHBseUZpbHRlcnModmFsdWUsIG51bGwsIHRoaXMuZmlsdGVycywgZmFsc2UpXG4gIH1cbiAgdGhpcy5hZnRlckdldCgpXG4gIHJldHVybiB2YWx1ZVxufVxuXG4vLyAvKipcbi8vICAqIFNldCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSB3aXRoIHRoZSBzZXR0ZXIuXG4vLyAgKlxuLy8gICogQHBhcmFtIHsqfSB2YWx1ZVxuLy8gICovXG5cbi8vIHAuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4vLyAgIHZhciB2bSA9IHRoaXMudm1cbi8vICAgaWYgKHRoaXMuZmlsdGVycykge1xuLy8gICAgIHZhbHVlID0gdm0uX2FwcGx5RmlsdGVycyhcbi8vICAgICAgIHZhbHVlLCB0aGlzLnZhbHVlLCB0aGlzLmZpbHRlcnMsIHRydWUpXG4vLyAgIH1cbi8vICAgdHJ5IHtcbi8vICAgICB0aGlzLnNldHRlci5jYWxsKHZtLCB2bSwgdmFsdWUpXG4vLyAgIH0gY2F0Y2ggKGUpIHtcbi8vICAgICAvLyBpZiAoY29uZmlnLndhcm5FeHByZXNzaW9uRXJyb3JzKSB7XG4vLyAgICAgICBfLndhcm4oXG4vLyAgICAgICAgICdFcnJvciB3aGVuIGV2YWx1YXRpbmcgc2V0dGVyIFwiJyArXG4vLyAgICAgICAgIHRoaXMuZXhwcmVzc2lvbiArICdcIjpcXG4gICAnICsgZVxuLy8gICAgICAgKVxuLy8gICAgIC8vIH1cbi8vICAgfVxuLy8gfVxuXG4vKipcbiAqIFByZXBhcmUgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuXG5wLmJlZm9yZUdldCA9IGZ1bmN0aW9uICgpIHtcbiAgT2JzZXJ2ZXIudGFyZ2V0ID0gdGhpc1xufVxuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cblxucC5hZnRlckdldCA9IGZ1bmN0aW9uICgpIHtcbiAgT2JzZXJ2ZXIudGFyZ2V0ID0gbnVsbFxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzLmRlcHNbaV1cbiAgICBpZiAoZGVwKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpXG4gICAgfVxuICB9XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwc1xuICB0aGlzLm5ld0RlcHMgPSBbXVxufVxuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuXG4vLyBwLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbi8vICAgaWYgKCFjb25maWcuYXN5bmMgfHwgY29uZmlnLmRlYnVnKSB7XG4vLyAgICAgdGhpcy5ydW4oKVxuLy8gICB9IGVsc2Uge1xuLy8gICAgIGJhdGNoZXIucHVzaCh0aGlzKVxuLy8gICB9XG4vLyB9XG5cbi8vIC8qKlxuLy8gICogQmF0Y2hlciBqb2IgaW50ZXJmYWNlLlxuLy8gICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIGJhdGNoZXIuXG4vLyAgKi9cblxuLy8gcC5ydW4gPSBmdW5jdGlvbiAoKSB7XG5wLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKVxuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlXG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICAgIHRoaXMuY2IodmFsdWUsIG9sZFZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3ViY3JpYmVyIGxpc3QuXG4gKi9cblxucC50ZWFyZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHdlIGNhbiBza2lwIHRoaXMgaWYgdGhlIHZtIGlmIGJlaW5nIGRlc3Ryb3llZFxuICAgIC8vIHdoaWNoIGNhbiBpbXByb3ZlIHRlYXJkb3duIHBlcmZvcm1hbmNlLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgdGhpcy52bS5fd2F0Y2hlcnMuJHJlbW92ZSh0aGlzKVxuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMpXG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2VcbiAgICB0aGlzLnZtID0gdGhpcy5jYiA9IHRoaXMudmFsdWUgPSBudWxsXG4gIH1cbn1cblxuXG4vKipcbiAqIFJlY3J1c2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cblxuZnVuY3Rpb24gdHJhdmVyc2UgKG9iaikge1xuICB2YXIga2V5LCB2YWwsIGlcbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgdmFsID0gb2JqW2tleV1cbiAgICBpZiAoXy5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGkgPSB2YWwubGVuZ3RoXG4gICAgICB3aGlsZSAoaS0tKSB7dHJhdmVyc2UodmFsW2ldKX1cbiAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QodmFsKSkge1xuICAgICAgdHJhdmVyc2UodmFsKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdhdGNoZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL3ZtL3dhdGNoZXIuanNcbiAqKi8iLCIvKipcbiAqIEBmaWxlT3ZlcnZpZXcgRG9jdW1lbnQgJiBFbGVtZW50IEhlbHBlcnMuXG4gKlxuICogcmVxdWlyZWQ6XG4gKiBEb2N1bWVudCM6IGNyZWF0ZUVsZW1lbnQsIGNyZWF0ZUNvbW1lbnQsIGdldFJlZlxuICogRWxlbWVudCM6IGFwcGVuZENoaWxkLCBpbnNlcnRCZWZvcmUsIHJlbW92ZUNoaWxkLCBuZXh0U2libGluZ1xuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgYm9keSBieSB0eXBlXG4gKiBVc2luZyB0aGlzLl9hcHAuZG9jXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY3JlYXRlQm9keSh0eXBlKSB7XG4gIGNvbnN0IGRvYyA9IHRoaXMuX2FwcC5kb2NcbiAgcmV0dXJuIGRvYy5jcmVhdGVCb2R5KHR5cGUpXG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGVsZW1lbnQgYnkgdHlwZVxuICogVXNpbmcgdGhpcy5fYXBwLmRvY1xuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQodHlwZSkge1xuICBjb25zdCBkb2MgPSB0aGlzLl9hcHAuZG9jXG4gIHJldHVybiBkb2MuY3JlYXRlRWxlbWVudCh0eXBlKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgZnJhZyBibG9jayBmb3IgYW4gZWxlbWVudC5cbiAqIFRoZSBmcmFnIGJsb2NrIGhhcyBhIHN0YXJ0ZXIsIGVuZGVyIGFuZCB0aGUgZWxlbWVudCBpdHNlbGYuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSBlbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY3JlYXRlQmxvY2soZWxlbWVudCkge1xuICBjb25zdCBzdGFydCA9IHRoaXMuX2NyZWF0ZUJsb2NrU3RhcnQoKVxuICBjb25zdCBlbmQgPSB0aGlzLl9jcmVhdGVCbG9ja0VuZCgpXG4gIGNvbnN0IGJsb2NrSWQgPSBsYXN0ZXN0QmxvY2tJZCsrXG4gIGlmIChlbGVtZW50LmVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmVsZW1lbnQuaW5zZXJ0QmVmb3JlKHN0YXJ0LCBlbGVtZW50LmVuZClcbiAgICBlbGVtZW50LmVsZW1lbnQuaW5zZXJ0QmVmb3JlKGVuZCwgZWxlbWVudC5lbmQpXG4gICAgZWxlbWVudCA9IGVsZW1lbnQuZWxlbWVudFxuICB9XG4gIGVsc2Uge1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoc3RhcnQpXG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbmQpXG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgZW5kLCBlbGVtZW50LCBibG9ja0lkfVxufVxuXG5sZXQgbGFzdGVzdEJsb2NrSWQgPSAxXG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBibG9jayBzdGFydGVyLlxuICogVXNpbmcgdGhpcy5fYXBwLmRvY1xuICovXG5leHBvcnQgZnVuY3Rpb24gX2NyZWF0ZUJsb2NrU3RhcnQoKSB7XG4gIGNvbnN0IGRvYyA9IHRoaXMuX2FwcC5kb2NcbiAgY29uc3QgYW5jaG9yID0gZG9jLmNyZWF0ZUNvbW1lbnQoJ3N0YXJ0JylcbiAgcmV0dXJuIGFuY2hvclxufVxuXG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgYmxvY2sgZW5kZXIuXG4gKiBVc2luZyB0aGlzLl9hcHAuZG9jXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY3JlYXRlQmxvY2tFbmQoKSB7XG4gIGNvbnN0IGRvYyA9IHRoaXMuX2FwcC5kb2NcbiAgY29uc3QgYW5jaG9yID0gZG9jLmNyZWF0ZUNvbW1lbnQoJ2VuZCcpXG4gIHJldHVybiBhbmNob3Jcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGFyZ2V0IHRvIGEgY2VydGFpbiBkZXN0IHVzaW5nIGFwcGVuZENoaWxkIGJ5IGRlZmF1bHQuXG4gKiBJZiB0aGUgZGVzdCBpcyBhIGZyYWcgYmxvY2sgdGhlbiBpbnNlcnQgYmVmb3JlIHRoZSBlbmRlci5cbiAqIElmIHRoZSB0YXJnZXQgaXMgYSBmcmFnIGJsb2NrIHRoZW4gYXR0YWNoIHRoZSBzdGFydGVyIGFuZCBlbmRlciBpbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IHRhcmdldFxuICogQHBhcmFtICB7b2JqZWN0fSBkZXN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYXR0YWNoVGFyZ2V0KHRhcmdldCwgZGVzdCkge1xuXG4gIGlmIChkZXN0LmVsZW1lbnQpIHtcbiAgICBjb25zdCBiZWZvcmUgPSBkZXN0LmVuZFxuICAgIGNvbnN0IGFmdGVyID0gZGVzdC51cGRhdGVNYXJrXG4gICAgLy8gcHVzaCBuZXcgdGFyZ2V0IGZvciB3YXRjaCBsaXN0IHVwZGF0ZSBsYXRlclxuICAgIGlmIChkZXN0LmNoaWxkcmVuKSB7XG4gICAgICBkZXN0LmNoaWxkcmVuLnB1c2godGFyZ2V0KVxuICAgIH1cbiAgICAvLyBmb3IgY2hlY2sgcmVwZWF0IGNhc2VcbiAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgIHRoaXMuX21vdmVUYXJnZXQodGFyZ2V0LCBhZnRlcilcbiAgICAgIGRlc3QudXBkYXRlTWFyayA9IHRhcmdldC5lbGVtZW50ID8gdGFyZ2V0LmVuZCA6IHRhcmdldFxuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXQuZWxlbWVudCkge1xuICAgICAgZGVzdC5lbGVtZW50Lmluc2VydEJlZm9yZSh0YXJnZXQuc3RhcnQsIGJlZm9yZSlcbiAgICAgIGRlc3QuZWxlbWVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LmVuZCwgYmVmb3JlKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGRlc3QuZWxlbWVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LCBiZWZvcmUpXG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmICh0YXJnZXQuZWxlbWVudCkge1xuICAgICAgZGVzdC5hcHBlbmRDaGlsZCh0YXJnZXQuc3RhcnQpXG4gICAgICBkZXN0LmFwcGVuZENoaWxkKHRhcmdldC5lbmQpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZGVzdC5hcHBlbmRDaGlsZCh0YXJnZXQpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTW92ZSB0YXJnZXQgYmVmb3JlIGEgY2VydGFpbiBlbGVtZW50LiBUaGUgdGFyZ2V0IG1heWJlIGJsb2NrIG9yIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSAge29iamVjdH0gYmVmb3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbW92ZVRhcmdldCh0YXJnZXQsIGFmdGVyKSB7XG4gIGlmICh0YXJnZXQuZWxlbWVudCkge1xuICAgIHRoaXMuX21vdmVCbG9jayh0YXJnZXQsIGFmdGVyKVxuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuX21vdmVFbGVtZW50KHRhcmdldCwgYWZ0ZXIpXG4gIH1cbn1cblxuLyoqXG4gKiBNb3ZlIGVsZW1lbnQgYmVmb3JlIGEgY2VydGFpbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gZWxlbWVudFxuICogQHBhcmFtICB7b2JqZWN0fSBiZWZvcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9tb3ZlRWxlbWVudChlbGVtZW50LCBhZnRlcikge1xuICBjb25zdCBkb2MgPSB0aGlzLl9hcHAuZG9jXG4gIGNvbnN0IHBhcmVudCA9IGRvYy5nZXRSZWYoYWZ0ZXIucGFyZW50UmVmKVxuXG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQuaW5zZXJ0QWZ0ZXIoZWxlbWVudCwgYWZ0ZXIpXG4gIH1cbn1cblxuLyoqXG4gKiBNb3ZlIGFsbCBlbGVtZW50cyBvZiB0aGUgYmxvY2sgYmVmb3JlIGEgY2VydGFpbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gZnJhZ0Jsb2NrXG4gKiBAcGFyYW0gIHtvYmplY3R9IGJlZm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX21vdmVCbG9jayhmcmFnQmxvY2ssIGFmdGVyKSB7XG4gIGNvbnN0IGRvYyA9IHRoaXMuX2FwcC5kb2NcbiAgY29uc3QgcGFyZW50ID0gZG9jLmdldFJlZihhZnRlci5wYXJlbnRSZWYpXG5cbiAgaWYgKHBhcmVudCkge1xuICAgIGxldCBlbCA9IGZyYWdCbG9jay5zdGFydFxuICAgIGNvbnN0IGdyb3VwID0gW2VsXVxuXG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSBmcmFnQmxvY2suZW5kKSB7XG4gICAgICBlbCA9IGVsLm5leHQoKVxuICAgICAgZ3JvdXAucHVzaChlbClcbiAgICB9XG5cbiAgICBsZXQgdGVtcCA9IGFmdGVyXG4gICAgZ3JvdXAuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIHBhcmVudC5pbnNlcnRBZnRlcihlbCwgdGVtcClcbiAgICAgIHRlbXAgPSBlbFxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgdGFyZ2V0IGZyb20gRE9NIHRyZWUuXG4gKiBJZiB0aGUgdGFyZ2V0IGlzIGEgZnJhZyBibG9jayB0aGVuIGNhbGwgX3JlbW92ZUJsb2NrXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSB0YXJnZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9yZW1vdmVUYXJnZXQodGFyZ2V0KSB7XG5cbiAgaWYgKHRhcmdldC5lbGVtZW50KSB7XG4gICAgdGhpcy5fcmVtb3ZlQmxvY2sodGFyZ2V0KVxuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuX3JlbW92ZUVsZW1lbnQodGFyZ2V0KVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY2VydGFpbiBlbGVtZW50LlxuICogVXNpbmcgdGhpcy5fYXBwLmRvY1xuICpcbiAqIEBwYXJhbSAge29iamVjdH0gdGFyZ2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfcmVtb3ZlRWxlbWVudCh0YXJnZXQpIHtcbiAgY29uc3QgZG9jID0gdGhpcy5fYXBwLmRvY1xuICBjb25zdCBwYXJlbnQgPSBkb2MuZ2V0UmVmKHRhcmdldC5wYXJlbnRSZWYpXG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0YXJnZXQpXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBmcmFnIGJsb2NrLlxuICogVGhlIHNlY29uZCBwYXJhbSBkZWNpZGVzIHdoZXRoZXIgdGhlIGJsb2NrIHNlbGYgc2hvdWxkIGJlIHJlbW92ZWQgdG9vLlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gIGZyYWdCbG9ja1xuICogQHBhcmFtICB7Qm9vbGVhbn0gcHJlc2VydmVCbG9jaz1mYWxzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3JlbW92ZUJsb2NrKGZyYWdCbG9jaywgcHJlc2VydmVCbG9jayA9IGZhbHNlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdXG4gIGxldCBlbCA9IGZyYWdCbG9jay5zdGFydC5uZXh0KClcblxuICB3aGlsZSAoZWwgJiYgZWwgIT09IGZyYWdCbG9jay5lbmQpIHtcbiAgICByZXN1bHQucHVzaChlbClcbiAgICBlbCA9IGVsLm5leHQoKVxuICB9XG5cbiAgaWYgKCFwcmVzZXJ2ZUJsb2NrKSB7XG4gICAgdGhpcy5fcmVtb3ZlRWxlbWVudChmcmFnQmxvY2suc3RhcnQpXG4gIH1cbiAgcmVzdWx0LmZvckVhY2goKGVsKSA9PiB7XG4gICAgdGhpcy5fcmVtb3ZlRWxlbWVudChlbClcbiAgfSlcbiAgaWYgKCFwcmVzZXJ2ZUJsb2NrKSB7XG4gICAgdGhpcy5fcmVtb3ZlRWxlbWVudChmcmFnQmxvY2suZW5kKVxuICB9XG59XG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL3ZtL2RvbS1oZWxwZXIuanNcbiAqKi8iLCJmdW5jdGlvbiBFdnQodHlwZSwgZGV0YWlsKSB7XG4gIGlmIChkZXRhaWwgaW5zdGFuY2VvZiBFdnQpIHtcbiAgICByZXR1cm4gZGV0YWlsXG4gIH1cblxuICB0aGlzLnRpbWVzdGFtcCA9IERhdGUubm93KClcbiAgdGhpcy5kZXRhaWwgPSBkZXRhaWxcbiAgdGhpcy50eXBlID0gdHlwZVxuXG4gIGxldCBzaG91bGRTdG9wID0gZmFsc2VcbiAgdGhpcy5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHNob3VsZFN0b3AgPSB0cnVlXG4gIH1cbiAgdGhpcy5oYXNTdG9wcGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzaG91bGRTdG9wXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uICRlbWl0KHR5cGUsIGRldGFpbCkge1xuICBjb25zdCBldmVudHMgPSB0aGlzLl92bUV2ZW50c1xuICBjb25zdCBoYW5kbGVyTGlzdCA9IGV2ZW50c1t0eXBlXVxuICBpZiAoaGFuZGxlckxpc3QpIHtcbiAgICBsZXQgZXZ0ID0gbmV3IEV2dCh0eXBlLCBkZXRhaWwpXG4gICAgaGFuZGxlckxpc3QuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGV2dClcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAkZGlzcGF0Y2godHlwZSwgZGV0YWlsKSB7XG4gIGNvbnN0IGV2dCA9IG5ldyBFdnQodHlwZSwgZGV0YWlsKVxuICB0aGlzLiRlbWl0KHR5cGUsIGV2dClcblxuICBpZiAoIWV2dC5oYXNTdG9wcGVkKCkgJiYgdGhpcy5fcGFyZW50ICYmIHRoaXMuX3BhcmVudC4kZGlzcGF0Y2gpIHtcbiAgICB0aGlzLl9wYXJlbnQuJGRpc3BhdGNoKHR5cGUsIGV2dClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gJGJyb2FkY2FzdCh0eXBlLCBkZXRhaWwpIHtcbiAgY29uc3QgZXZ0ID0gbmV3IEV2dCh0eXBlLCBkZXRhaWwpXG4gIHRoaXMuJGVtaXQodHlwZSwgZXZ0KVxuXG4gIGlmICghZXZ0Lmhhc1N0b3BwZWQoKSAmJiB0aGlzLl9jaGlsZHJlblZtcykge1xuICAgIHRoaXMuX2NoaWxkcmVuVm1zLmZvckVhY2goKHN1YlZtKSA9PiB7XG4gICAgICBzdWJWbS4kYnJvYWRjYXN0KHR5cGUsIGV2dClcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAkb24odHlwZSwgaGFuZGxlcikge1xuICBpZiAoIXR5cGUgfHwgdHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBldmVudHMgPSB0aGlzLl92bUV2ZW50c1xuICBjb25zdCBoYW5kbGVyTGlzdCA9IGV2ZW50c1t0eXBlXSB8fCBbXVxuICBoYW5kbGVyTGlzdC5wdXNoKGhhbmRsZXIpXG4gIGV2ZW50c1t0eXBlXSA9IGhhbmRsZXJMaXN0XG5cbiAgLy8gZml4ZWQgb2xkIHZlcnNpb24gbGlmZWN5Y2xlIGRlc2lnblxuICBpZiAodHlwZSA9PT0gJ2hvb2s6cmVhZHknICYmIHRoaXMuX3JlYWR5KSB7XG4gICAgdGhpcy4kZW1pdCgnaG9vazpyZWFkeScpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uICRvZmYodHlwZSwgaGFuZGxlcikge1xuICBpZiAoIXR5cGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBldmVudHMgPSB0aGlzLl92bUV2ZW50c1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICBkZWxldGUgZXZlbnRzW3R5cGVdXG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgaGFuZGxlckxpc3QgPSBldmVudHNbdHlwZV1cbiAgaWYgKCFoYW5kbGVyTGlzdCkge1xuICAgIHJldHVyblxuICB9XG4gIGhhbmRsZXJMaXN0LiRyZW1vdmUoaGFuZGxlcilcbn1cblxuY29uc3QgTElGRV9DWUNMRV9UWVBFUyA9IFsnaW5pdCcsICdjcmVhdGVkJywgJ3JlYWR5J11cblxuZXhwb3J0IGZ1bmN0aW9uIF9pbml0RXZlbnRzKGV4dGVybmFsRXZlbnRzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zIHx8IHt9XG4gIGNvbnN0IGV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzIHx8IHt9XG4gIGZvciAoY29uc3QgdHlwZTEgaW4gZXZlbnRzKSB7XG4gICAgdGhpcy4kb24odHlwZTEsIGV2ZW50c1t0eXBlMV0pXG4gIH1cbiAgZm9yIChjb25zdCB0eXBlMiBpbiBleHRlcm5hbEV2ZW50cykge1xuICAgIHRoaXMuJG9uKHR5cGUyLCBleHRlcm5hbEV2ZW50c1t0eXBlMl0pXG4gIH1cbiAgTElGRV9DWUNMRV9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgdGhpcy4kb24oYGhvb2s6JHt0eXBlfWAsIG9wdGlvbnNbdHlwZV0pXG4gIH0pXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2xpYi92bS9ldmVudHMuanNcbiAqKi8iLCJsZXQgbmF0aXZlTW9kdWxlcyA9IHt9XG5cbmZ1bmN0aW9uIGFzc2lnbk1vZHVsZXMobW9kdWxlcywgaWZSZXBsYWNlKSB7XG5cbiAgZm9yIChjb25zdCBtb2R1bGVOYW1lIGluIG1vZHVsZXMpIHtcblxuICAgIC8vIGluaXQgYG1vZHVsZXNbbW9kdWxlTmFtZV1bXWBcbiAgICBsZXQgbWV0aG9kcyA9IG5hdGl2ZU1vZHVsZXNbbW9kdWxlTmFtZV1cbiAgICBpZiAoIW1ldGhvZHMpIHtcbiAgICAgIG1ldGhvZHMgPSB7fVxuICAgICAgbmF0aXZlTW9kdWxlc1ttb2R1bGVOYW1lXSA9IG1ldGhvZHNcbiAgICB9XG5cbiAgICAvLyBwdXNoIGVhY2ggbm9uLWV4aXN0ZWQgbmV3IG1ldGhvZFxuICAgIG1vZHVsZXNbbW9kdWxlTmFtZV0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWV0aG9kID0ge1xuICAgICAgICAgIG5hbWU6IG1ldGhvZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbWV0aG9kc1ttZXRob2QubmFtZV0gfHwgaWZSZXBsYWNlKSB7XG4gICAgICAgIG1ldGhvZHNbbWV0aG9kLm5hbWVdID0gbWV0aG9kXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25BcGlzKEN0b3IsIGFwaXMpIHtcbiAgY29uc3QgcCA9IEN0b3IucHJvdG90eXBlXG5cbiAgZm9yIChjb25zdCBhcGlOYW1lIGluIGFwaXMpIHtcbiAgICBpZiAoIXAuaGFzT3duUHJvcGVydHkoYXBpTmFtZSkpIHtcbiAgICAgIHBbYXBpTmFtZV0gPSBhcGlzW2FwaU5hbWVdXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhck1vZHVsZXMoKSB7XG4gIG5hdGl2ZU1vZHVsZXMgPSB7fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW9kdWxlKG1vZHVsZU5hbWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU1vZHVsZXNbbW9kdWxlTmFtZV1cbn1cblxuLyoqXG4gKiBAY29udGV4dCBhIGluc3RhbmNlIG9mIEFwcEluc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXF1aXJlTW9kdWxlKG1vZHVsZU5hbWUpIHtcbiAgY29uc3QgbWV0aG9kcyA9IG5hdGl2ZU1vZHVsZXNbbW9kdWxlTmFtZV1cbiAgY29uc3QgdGFyZ2V0ID0ge31cblxuICBmb3IgKGNvbnN0IG1ldGhvZE5hbWUgaW4gbWV0aG9kcykge1xuICAgIHRhcmdldFttZXRob2ROYW1lXSA9ICguLi5hcmdzKSA9PiB0aGlzLmNhbGxUYXNrcyh7XG4gICAgICBtb2R1bGU6IG1vZHVsZU5hbWUsXG4gICAgICBtZXRob2Q6IG1ldGhvZE5hbWUsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRcbn1cblxuLyoqXG4gKiBAY29udGV4dCBWbVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJNb2R1bGVzKG1vZHVsZXMsIGlmUmVwbGFjZSkge1xuICBhc3NpZ25Nb2R1bGVzKG1vZHVsZXMsIGlmUmVwbGFjZSlcbn1cblxuLyoqXG4gKiBAY29udGV4dCBWbVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJNZXRob2RzKGFwaXMpIHtcbiAgYXNzaWduQXBpcyh0aGlzLCBhcGlzKVxufVxuXG4vKipcbiAqIEBjb250ZXh0IGEgaW5zdGFuY2Ugb2YgQXBwSW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcXVpcmVDb21wb25lbnQobmFtZSkge1xuICBjb25zdCB7Y3VzdG9tQ29tcG9uZW50TWFwfSA9IHRoaXNcbiAgcmV0dXJuIGN1c3RvbUNvbXBvbmVudE1hcFtuYW1lXVxufVxuXG4vKipcbiAqIEBjb250ZXh0IGEgaW5zdGFuY2Ugb2YgQXBwSW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9uZW50KG5hbWUsIGV4cG9ydHMpIHtcbiAgY29uc3Qge2N1c3RvbUNvbXBvbmVudE1hcH0gPSB0aGlzXG5cbiAgaWYgKGN1c3RvbUNvbXBvbmVudE1hcFtuYW1lXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgZGVmaW5lIGEgY29tcG9uZW50KCR7bmFtZX0pIHRoYXQgYWxyZWFkeSBleGlzdHNgKVxuICB9XG5cbiAgY3VzdG9tQ29tcG9uZW50TWFwW25hbWVdID0gZXhwb3J0c1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL2FwcC9yZWdpc3Rlci5qc1xuICoqLyIsImltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJ1xuaW1wb3J0IHtleHRlbmQsIGlzUGxhaW5PYmplY3QsIHR5cG9mfSAgZnJvbSAnLi4vdXRpbCdcblxuLyoqXG4gKiBbbm9ybWFsaXplVmVyc2lvbiBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge1N0cmluZ30gVmVyc2lvbi4gaWU6IDEsIDEuMCwgMS4wLjBcbiAqIEByZXR1cm4ge1N0cmluZ30gVmVyc2lvblxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplVmVyc2lvbiAodikge1xuICBjb25zdCBpc1ZhbGlkID0gc2VtdmVyLnZhbGlkKHYpID8gdHJ1ZSA6IGZhbHNlXG4gIGlmIChpc1ZhbGlkKSB7XG4gICAgcmV0dXJuIHZcbiAgfVxuXG4gIHYgPSB0eXBlb2YgKHYpID09PSAnc3RyaW5nJyA/IHYgOiAnJ1xuICBjb25zdCBzcGxpdCA9IHYuc3BsaXQoJy4nKVxuICBsZXQgaSA9IDBcbiAgbGV0IHJlc3VsdCA9IFtdXG5cbiAgd2hpbGUgKGkgPCAzKSB7XG4gICAgY29uc3QgcyA9IHR5cGVvZiAoc3BsaXRbaV0pID09PSAnc3RyaW5nJyAmJiBzcGxpdFtpXSA/IHNwbGl0W2ldIDogJzAnXG4gICAgcmVzdWx0LnB1c2gocylcbiAgICBpKytcbiAgfVxuXG4gIHJldHVybiByZXN1bHQuam9pbignLicpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFcnJvciAoa2V5LCB2YWwsIGNyaXRlcmlhKSB7XG4gIGxldCByZXN1bHQgPSB7XG4gICAgaXNEb3duZ3JhZGU6IHRydWUsXG4gICAgZXJyb3JUeXBlOiAxLFxuICAgIGNvZGU6IDEwMDBcbiAgfVxuICBsZXQgZ2V0TXNnID0gZnVuY3Rpb24gKGtleSwgdmFsLCBjcml0ZXJpYSkge1xuICAgIHJldHVybiAnRG93bmdyYWRlWycgKyBrZXkgKyAnXSA6OiBkZXZpY2VJbmZvICdcbiAgICAgICsgdmFsICsgJyBtYXRjaGVkIGNyaXRlcmlhICcgKyBjcml0ZXJpYVxuICB9XG4gIGNvbnN0IF9rZXkgPSBrZXkudG9Mb3dlckNhc2UoKVxuXG4gIHJlc3VsdC5lcnJvck1lc3NhZ2UgPSBnZXRNc2coa2V5LCB2YWwsIGNyaXRlcmlhKVxuXG4gIGlmIChfa2V5LmluZGV4T2YoJ29zdmVyc2lvbicpID49IDApIHtcbiAgICByZXN1bHQuY29kZSA9IDEwMDFcbiAgfWVsc2UgaWYgKF9rZXkuaW5kZXhPZignYXBwdmVyc2lvbicpID49IDApIHtcbiAgICByZXN1bHQuY29kZSA9IDEwMDJcbiAgfWVsc2UgaWYgKF9rZXkuaW5kZXhPZignd2VleHZlcnNpb24nKSA+PSAwKSB7XG4gICAgcmVzdWx0LmNvZGUgPSAxMDAzXG4gIH1lbHNlIGlmIChfa2V5LmluZGV4T2YoJ2RldmljZW1vZGVsJykgPj0gMCkge1xuICAgIHJlc3VsdC5jb2RlID0gMTAwNFxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIFdFRVggZnJhbWV3b3JrIGlucHV0KGRldmljZUluZm8pXG4gKiB7XG4gKiAgIHBsYXRmb3JtOiAnaU9TJyBvciAnYW5kcm9pZCdcbiAqICAgb3NWZXJzaW9uOiAnMS4wLjAnIG9yICcxLjAnIG9yICcxJ1xuICogICBhcHBWZXJzaW9uOiAnMS4wLjAnIG9yICcxLjAnIG9yICcxJ1xuICogICB3ZWV4VmVyc2lvbjogJzEuMC4wJyBvciAnMS4wJyBvciAnMSdcbiAqICAgZERldmljZU1vZGVsOiAnTU9ERUxfTkFNRSdcbiAqIH1cbiAqXG4gKiBkb3duZ3JhZGUgY29uZmlnKGNvbmZpZylcbiAqIHtcbiAqICAgaW9zOiB7XG4gKiAgICAgb3NWZXJzaW9uOiAnPjEuMC4wJyBvciAnPj0xLjAuMCcgb3IgJzwxLjAuMCcgb3IgJzw9MS4wLjAnIG9yICcxLjAuMCdcbiAqICAgICBhcHBWZXJzaW9uOiAnPjEuMC4wJyBvciAnPj0xLjAuMCcgb3IgJzwxLjAuMCcgb3IgJzw9MS4wLjAnIG9yICcxLjAuMCdcbiAqICAgICB3ZWV4VmVyc2lvbjogJz4xLjAuMCcgb3IgJz49MS4wLjAnIG9yICc8MS4wLjAnIG9yICc8PTEuMC4wJyBvciAnMS4wLjAnXG4gKiAgICAgZGV2aWNlTW9kZWw6IFsnbW9kZWxBJywgJ21vZGVsQicsIC4uLl1cbiAqICAgfSxcbiAqICAgYW5kcm9pZDoge1xuICogICAgIG9zVmVyc2lvbjogJz4xLjAuMCcgb3IgJz49MS4wLjAnIG9yICc8MS4wLjAnIG9yICc8PTEuMC4wJyBvciAnMS4wLjAnXG4gKiAgICAgYXBwVmVyc2lvbjogJz4xLjAuMCcgb3IgJz49MS4wLjAnIG9yICc8MS4wLjAnIG9yICc8PTEuMC4wJyBvciAnMS4wLjAnXG4gKiAgICAgd2VleFZlcnNpb246ICc+MS4wLjAnIG9yICc+PTEuMC4wJyBvciAnPDEuMC4wJyBvciAnPD0xLjAuMCcgb3IgJzEuMC4wJ1xuICogICAgIGRldmljZU1vZGVsOiBbJ21vZGVsQScsICdtb2RlbEInLCAuLi5dXG4gKiAgIH1cbiAqIH1cbiAqXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSBkZXZpY2VJbmZvIFdlZXggU0RLIGZyYW1ld29yayBpbnB1dFxuICogQHBhcmFtICB7b2JqZWN0fSBjb25maWcgICAgIHVzZXIgaW5wdXRcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICB7IGlzRG93bmdyYWRlOiB0cnVlL2ZhbHNlLCBlcnJvck1lc3NhZ2UuLi4gfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2sgKGNvbmZpZywgZGV2aWNlSW5mbykge1xuICBkZXZpY2VJbmZvID0gZGV2aWNlSW5mbyB8fCBnbG9iYWwuV1hFbnZpcm9ubWVudFxuICBkZXZpY2VJbmZvID0gaXNQbGFpbk9iamVjdChkZXZpY2VJbmZvKSA/IGRldmljZUluZm8gOiB7fVxuICBjb25maWcgPSBpc1BsYWluT2JqZWN0KGNvbmZpZykgPyBjb25maWcgOiB7fVxuICBjb25zdCBwbGF0Zm9ybSA9IGRldmljZUluZm8ucGxhdGZvcm0gfHwgJ3Vua25vdydcbiAgY29uc3QgZFBsYXRmb3JtID0gcGxhdGZvcm0udG9Mb3dlckNhc2UoKVxuICBjb25zdCBjT2JqID0gY29uZmlnW2RQbGF0Zm9ybV0gfHwge31cblxuICBsZXQgcmVzdWx0ID0ge1xuICAgIGlzRG93bmdyYWRlOiBmYWxzZSAvLyBkZWZhdXRsIGlzIHBhc3NcbiAgfVxuXG4gIGZvciAobGV0IGkgaW4gZGV2aWNlSW5mbykge1xuICAgIGNvbnN0IGtleSA9IGlcbiAgICBjb25zdCBrZXlMb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpXG4gICAgY29uc3QgdmFsID0gZGV2aWNlSW5mb1tpXVxuICAgIGNvbnN0IGlzVmVyc2lvbiA9IGtleUxvd2VyLmluZGV4T2YoJ3ZlcnNpb24nKSA+PSAwID8gdHJ1ZSA6IGZhbHNlXG4gICAgY29uc3QgaXNEZXZpY2VNb2RlbCA9IGtleUxvd2VyLmluZGV4T2YoJ2RldmljZW1vZGVsJykgPj0gMCA/IHRydWUgOiBmYWxzZVxuICAgIGNvbnN0IGNyaXRlcmlhID0gY09ialtpXVxuXG4gICAgaWYgKGNyaXRlcmlhICYmIGlzVmVyc2lvbikge1xuICAgICAgY29uc3QgYyA9IHRoaXMubm9ybWFsaXplVmVyc2lvbihjcml0ZXJpYSlcbiAgICAgIGNvbnN0IGQgPSB0aGlzLm5vcm1hbGl6ZVZlcnNpb24oZGV2aWNlSW5mb1tpXSlcblxuICAgICAgaWYgKHNlbXZlci5zYXRpc2ZpZXMoZCwgYykpIHtcbiAgICAgICAgcmVzdWx0ID0gZXh0ZW5kKHRoaXMuZ2V0RXJyb3Ioa2V5LCB2YWwsIGNyaXRlcmlhKSlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9ZWxzZSBpZiAoaXNEZXZpY2VNb2RlbCkge1xuICAgICAgY29uc3QgX2NyaXRlcmlhID0gdHlwb2YoY3JpdGVyaWEpID09PSAnYXJyYXknID8gY3JpdGVyaWEgOiBbY3JpdGVyaWFdXG4gICAgICBpZiAoX2NyaXRlcmlhLmluZGV4T2YodmFsKSA+PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IGV4dGVuZCh0aGlzLmdldEVycm9yKGtleSwgdmFsLCBjcml0ZXJpYSkpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL2FwcC9kb3duZ3JhZGUuanNcbiAqKi8iLCIvKipcbiAqIEBmaWxlT3ZlcnZpZXdcbiAqIGluc3RhbmNlIGNvbnRyb2xzIGZyb20gbmF0aXZlXG4gKlxuICogLSBpbml0IGJ1bmRsZVxuICogLSBmaXJlIGV2ZW50XG4gKiAtIGNhbGxiYWNrXG4gKiAtIGRlc3Ryb3lcbiAqXG4gKiBjb3JyZXNwb25kZWQgd2l0aCB0aGUgQVBJIG9mIGluc3RhbmNlIG1hbmFnZXIgKGZyYW1ld29yay5qcylcbiAqL1xuXG5pbXBvcnQge1xuICBiaW5kLCBleHRlbmRcbn1cbmZyb20gJy4uL3V0aWwnXG5pbXBvcnQgKiBhcyBwZXJmIGZyb20gJy4uL3BlcmYnXG5pbXBvcnQgTGlzdGVuZXIsIHtjcmVhdGVBY3Rpb259IGZyb20gJy4vZG9tLWxpc3RlbmVyJ1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdChjb2RlLCBkYXRhKSB7XG4gIHZhciByZXN1bHRcbiAgLy8gQHNlZTogbGliL2FwcC9idW5kbGUuanNcbiAgY29uc3QgZGVmaW5lID0gYmluZCh0aGlzLmRlZmluZSwgdGhpcylcbiAgY29uc3QgYm9vdHN0cmFwID0gKG5hbWUsIGNvbmZpZywgX2RhdGEpID0+IHtcbiAgICByZXN1bHQgPSB0aGlzLmJvb3RzdHJhcChuYW1lLCBjb25maWcsIF9kYXRhIHx8IGRhdGEpXG4gICAgdGhpcy51cGRhdGVBY3Rpb25zKClcbiAgICB0aGlzLmRvYy5saXN0ZW5lci5jcmVhdGVGaW5pc2goKVxuICAgIHRoaXMuZG9jLmNsb3NlKClcbiAgfVxuXG4gIC8vIGJhY2t3YXJkKHJlZ2lzdGVyL3JlbmRlcilcbiAgY29uc3QgcmVnaXN0ZXIgPSBiaW5kKHRoaXMucmVnaXN0ZXIsIHRoaXMpXG4gIGNvbnN0IHJlbmRlciA9IChuYW1lLCBfZGF0YSkgPT4ge1xuICAgIHJlc3VsdCA9IHRoaXMuYm9vdHN0cmFwKG5hbWUsIHt9LCBfZGF0YSlcbiAgfVxuXG4gIGNvbnN0IHJlcXVpcmUgPSBuYW1lID0+IF9kYXRhID0+IHtcbiAgICByZXN1bHQgPSB0aGlzLmJvb3RzdHJhcChuYW1lLCB7fSwgX2RhdGEpXG4gIH1cblxuICBjb25zdCBkb2N1bWVudCA9IHRoaXMuZG9jXG5cbiAgcGVyZi5zdGFydCgncnVuIGJ1bmRsZScsIHRoaXMuaWQpXG5cbiAgbGV0IGZ1bmN0aW9uQm9keVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBjb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gYGZ1bmN0aW9uICgpIHsuLi59YCAtPiBgey4uLn1gXG4gICAgLy8gbm90IHZlcnkgc3RyaWN0XG4gICAgZnVuY3Rpb25Cb2R5ID0gY29kZS50b1N0cmluZygpLnN1YnN0cigxMilcbiAgfSBlbHNlIGlmIChjb2RlKSB7XG4gICAgZnVuY3Rpb25Cb2R5ID0gY29kZS50b1N0cmluZygpXG4gIH1cblxuICBsZXQgZm4gPSBuZXcgRnVuY3Rpb24oXG4gICAgJ2RlZmluZScsXG4gICAgJ3JlcXVpcmUnLFxuICAgICdkb2N1bWVudCcsXG4gICAgJ2Jvb3RzdHJhcCcsXG4gICAgJ3JlZ2lzdGVyJyxcbiAgICAncmVuZGVyJyxcbiAgICAnX193ZWV4X2RlZmluZV9fJywgLy8gYWxpYXMgZm9yIGRlZmluZVxuICAgICdfX3dlZXhfYm9vdHN0cmFwX18nLCAvLyBhbGlhcyBmb3IgYm9vdHN0cmFwXG4gICAgZnVuY3Rpb25Cb2R5XG4gIClcblxuICBmbihcbiAgICBkZWZpbmUsXG4gICAgcmVxdWlyZSxcbiAgICBkb2N1bWVudCxcbiAgICBib290c3RyYXAsXG4gICAgcmVnaXN0ZXIsXG4gICAgcmVuZGVyLFxuICAgIGRlZmluZSxcbiAgICBib290c3RyYXApXG5cbiAgcGVyZi5lbmQoJ3J1biBidW5kbGUnLCB0aGlzLmlkKVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95KCkge1xuICB0aGlzLmlkID0gJydcbiAgdGhpcy5ldmVudE1hbmFnZXIgPSBudWxsXG4gIHRoaXMub3B0aW9ucyA9IG51bGxcbiAgdGhpcy5ibG9ja3MgPSBudWxsXG4gIHRoaXMudm0gPSBudWxsXG4gIHRoaXMuZG9jID0gbnVsbFxuICB0aGlzLmN1c3RvbUNvbXBvbmVudE1hcCA9IG51bGxcbiAgdGhpcy5jYWxsYmFja3MgPSBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb290RWxlbWVudCgpIHtcbiAgY29uc3QgZG9jID0gdGhpcy5kb2MgfHwge31cbiAgY29uc3QgYm9keSA9IGRvYy5ib2R5IHx8IHt9XG4gIHJldHVybiBib2R5LnRvSlNPTiA/IGJvZHkudG9KU09OKCkgOiB7fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQWN0aW9ucyhhZGRvblRhc2tzKSB7XG4gIHRoaXMuZGlmZmVyLmZsdXNoKClcbiAgY29uc3QgdGFza3MgPSBbXVxuICBpZiAodGhpcy5saXN0ZW5lciAmJiB0aGlzLmxpc3RlbmVyLnVwZGF0ZXMubGVuZ3RoKSB7XG4gICAgdGFza3MucHVzaCguLi50aGlzLmxpc3RlbmVyLnVwZGF0ZXMpXG4gICAgdGhpcy5saXN0ZW5lci51cGRhdGVzID0gW11cbiAgfVxuICBpZiAoYWRkb25UYXNrcyAmJiBhZGRvblRhc2tzLmxlbmd0aCkge1xuICAgIHRhc2tzLnB1c2goLi4uYWRkb25UYXNrcylcbiAgfVxuICBpZiAodGFza3MubGVuZ3RoKSB7XG4gICAgdGhpcy5jYWxsVGFza3ModGFza3MpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpcmVFdmVudChyZWYsIHR5cGUsIGUsIGRvbUNoYW5nZXMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocmVmKSkge1xuICAgIHJlZi5zb21lKChyZWYpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmZpcmVFdmVudChyZWYsIHR5cGUsIGUpICE9PSBmYWxzZVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBlbCA9IHRoaXMuZG9jLmdldFJlZihyZWYpXG5cbiAgaWYgKGVsKSB7XG4gICAgcGVyZi5zdGFydCgnbWFuYWdlIGV2ZW50JywgcmVmICsgJy0nICsgdHlwZSlcbiAgICBlID0gZSB8fCB7fVxuICAgIGUudHlwZSA9IHR5cGVcbiAgICBlLnRhcmdldCA9IGVsXG4gICAgZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpXG4gICAgaWYgKGRvbUNoYW5nZXMpIHtcbiAgICAgIHVwZGF0ZUVsZW1lbnQoZWwsIGRvbUNoYW5nZXMpXG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZXZlbnRNYW5hZ2VyLmZpcmUoZWwsIHR5cGUsIGUpXG4gICAgcGVyZi5lbmQoJ21hbmFnZSBldmVudCcsIHJlZiArICctJyArIHR5cGUpXG4gICAgdGhpcy51cGRhdGVBY3Rpb25zKClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICByZXR1cm4gbmV3IEVycm9yKGBpbnZhbGlkIGVsZW1lbnQgcmVmZXJlbmNlIFwiJHtyZWZ9XCJgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsbGJhY2soY2FsbGJhY2tJZCwgZGF0YSwgaWZLZWVwQWxpdmUpIHtcbiAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrc1tjYWxsYmFja0lkXVxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayhkYXRhKSAvLyBkYXRhIGlzIGFscmVhZHkgYSBvYmplY3QsIEBzZWU6IGxpYi9mcmFtZXdvcmsuanNcblxuICAgIGlmICh0eXBlb2YgaWZLZWVwQWxpdmUgPT09ICd1bmRlZmluZWQnIHx8IGlmS2VlcEFsaXZlID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5jYWxsYmFja3NbY2FsbGJhY2tJZF0gPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUFjdGlvbnMoKVxuICAgIHJldHVyblxuICB9XG5cbiAgcmV0dXJuIG5ldyBFcnJvcihgaW52YWxpZCBjYWxsYmFjayBpZCBcIiR7Y2FsbGJhY2tJZH1cImApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWZyZXNoRGF0YShkYXRhKSB7XG4gIGNvbnN0IHZtID0gdGhpcy52bVxuXG4gIGlmICh2bSAmJiBkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiB2bS5yZWZyZXNoRGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdm0ucmVmcmVzaERhdGEoZGF0YSlcbiAgICB9IGVsc2Uge1xuICAgICAgZXh0ZW5kKHZtLCBkYXRhKVxuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUFjdGlvbnMoW2NyZWF0ZUFjdGlvbigncmVmcmVzaEZpbmlzaCcsIFtdKV0pXG4gICAgcmV0dXJuXG4gIH1cblxuICByZXR1cm4gbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgXCIke2RhdGF9XCJgKVxufVxuXG5mdW5jdGlvbiB1cGRhdGVFbGVtZW50KGVsLCBjaGFuZ2VzKSB7XG4gIGNvbnN0IGF0dHJzID0gY2hhbmdlcy5hdHRycyB8fCB7fVxuICBmb3IgKGNvbnN0IG5hbWUgaW4gYXR0cnMpIHtcbiAgICBlbC5zZXRBdHRyKG5hbWUsIGF0dHJzKVxuICB9XG4gIGNvbnN0IHN0eWxlID0gY2hhbmdlcy5zdHlsZSB8fCB7fVxuICBmb3IgKGNvbnN0IG5hbWUgaW4gc3R5bGUpIHtcbiAgICBlbC5zZXRTdHlsZShuYW1lLCBzdHlsZVtuYW1lXSlcbiAgfVxufVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2xpYi9hcHAvY3RybC5qc1xuICoqLyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExpc3RlbmVyKGlkLCBoYW5kbGVyKSB7XG4gIHRoaXMuaWQgPSBpZFxuICB0aGlzLmJhdGNoZWQgPSBmYWxzZVxuICB0aGlzLnVwZGF0ZXMgPSBbXVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyXG4gIH1cbn1cblxuTGlzdGVuZXIucHJvdG90eXBlLmNyZWF0ZUZpbmlzaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBjb25zdCBoYW5kbGVyID0gdGhpcy5oYW5kbGVyXG4gIGhhbmRsZXIoW2NyZWF0ZUFjdGlvbignY3JlYXRlRmluaXNoJywgW10pXSwgY2FsbGJhY2spXG59XG5cbkxpc3RlbmVyLnByb3RvdHlwZS5jcmVhdGVCb2R5ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHJlZikge1xuICBjb25zdCBhY3Rpb25zID0gW2NyZWF0ZUFjdGlvbignY3JlYXRlQm9keScsIFtlbGVtZW50LnRvSlNPTigpXSldXG4gIHRoaXMuYWRkQWN0aW9ucyhhY3Rpb25zKVxufVxuXG5MaXN0ZW5lci5wcm90b3R5cGUuYWRkRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCByZWYsIGluZGV4KSB7XG4gIGlmICghKGluZGV4ID49IDApKSB7XG4gICAgaW5kZXggPSAtMVxuICB9XG4gIHRoaXMuYWRkQWN0aW9ucyhjcmVhdGVBY3Rpb24oJ2FkZEVsZW1lbnQnLCBbcmVmLCBlbGVtZW50LnRvSlNPTigpLCBpbmRleF0pKVxufVxuXG5MaXN0ZW5lci5wcm90b3R5cGUucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocmVmKSkge1xuICAgIGNvbnN0IGFjdGlvbnMgPSByZWYubWFwKChyKSA9PiBjcmVhdGVBY3Rpb24oJ3JlbW92ZUVsZW1lbnQnLCBbcl0pKVxuICAgIHRoaXMuYWRkQWN0aW9ucyhhY3Rpb25zKVxuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuYWRkQWN0aW9ucyhjcmVhdGVBY3Rpb24oJ3JlbW92ZUVsZW1lbnQnLCBbcmVmXSkpXG4gIH1cbn1cblxuTGlzdGVuZXIucHJvdG90eXBlLm1vdmVFbGVtZW50ID0gZnVuY3Rpb24gKHRhcmdldFJlZiwgcGFyZW50UmVmLCBpbmRleCkge1xuICB0aGlzLmFkZEFjdGlvbnMoY3JlYXRlQWN0aW9uKCdtb3ZlRWxlbWVudCcsIFt0YXJnZXRSZWYsIHBhcmVudFJlZiwgaW5kZXhdKSlcbn1cblxuTGlzdGVuZXIucHJvdG90eXBlLnNldEF0dHIgPSBmdW5jdGlvbiAocmVmLCBrZXksIHZhbHVlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9XG4gIHJlc3VsdFtrZXldID0gdmFsdWVcbiAgdGhpcy5hZGRBY3Rpb25zKGNyZWF0ZUFjdGlvbigndXBkYXRlQXR0cnMnLCBbcmVmLCByZXN1bHRdKSlcbn1cblxuTGlzdGVuZXIucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24gKHJlZiwga2V5LCB2YWx1ZSkge1xuICBjb25zdCByZXN1bHQgPSB7fVxuICByZXN1bHRba2V5XSA9IHZhbHVlXG4gIHRoaXMuYWRkQWN0aW9ucyhjcmVhdGVBY3Rpb24oJ3VwZGF0ZVN0eWxlJywgW3JlZiwgcmVzdWx0XSkpXG59XG5cbkxpc3RlbmVyLnByb3RvdHlwZS5zZXRTdHlsZXMgPSBmdW5jdGlvbiAocmVmLCBzdHlsZSkge1xuICB0aGlzLmFkZEFjdGlvbnMoY3JlYXRlQWN0aW9uKCd1cGRhdGVTdHlsZScsIFtyZWYsIHN0eWxlXSkpXG59XG5cbkxpc3RlbmVyLnByb3RvdHlwZS5hZGRFdmVudCA9IGZ1bmN0aW9uIChyZWYsIHR5cGUpIHtcbiAgdGhpcy5hZGRBY3Rpb25zKGNyZWF0ZUFjdGlvbignYWRkRXZlbnQnLCBbcmVmLCB0eXBlXSkpXG59XG5cbkxpc3RlbmVyLnByb3RvdHlwZS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uIChyZWYsIHR5cGUpIHtcbiAgdGhpcy5hZGRBY3Rpb25zKGNyZWF0ZUFjdGlvbigncmVtb3ZlRXZlbnQnLCBbcmVmLCB0eXBlXSkpXG59XG5cbkxpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVyID0gZnVuY3Rpb24gKGFjdGlvbnMsIGNiKSB7XG4gIGNiICYmIGNiKClcbn1cblxuTGlzdGVuZXIucHJvdG90eXBlLmFkZEFjdGlvbnMgPSBmdW5jdGlvbiAoYWN0aW9ucykge1xuICBjb25zdCB1cGRhdGVzID0gdGhpcy51cGRhdGVzXG4gIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoYWN0aW9ucykpIHtcbiAgICBhY3Rpb25zID0gW2FjdGlvbnNdXG4gIH1cblxuICBpZiAodGhpcy5iYXRjaGVkKSB7XG4gICAgdXBkYXRlcy5wdXNoLmFwcGx5KHVwZGF0ZXMsIGFjdGlvbnMpXG4gIH1cbiAgZWxzZSB7XG4gICAgaGFuZGxlcihhY3Rpb25zKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBY3Rpb24obmFtZSwgYXJncykge1xuICByZXR1cm4ge21vZHVsZTogJ2RvbScsIG1ldGhvZDogbmFtZSwgYXJnczogYXJnc31cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL2FwcC9kb20tbGlzdGVuZXIuanNcbiAqKi8iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBEaWZmZXIge1xuICBjb25zdHJ1Y3RvciAoaWQpIHtcbiAgICB0aGlzLmlkID0gaWRcbiAgICB0aGlzLm1hcCA9IFtdXG4gICAgdGhpcy5ob29rcyA9IFtdXG4gIH1cbiAgaXNFbXB0eSAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmxlbmd0aCA9PT0gMFxuICB9XG4gIGFwcGVuZCAodHlwZSwgZGVwdGgsIHJlZiwgaGFuZGxlcikge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwXG4gICAgaWYgKCFtYXBbZGVwdGhdKSB7XG4gICAgICBtYXBbZGVwdGhdID0ge31cbiAgICB9XG4gICAgY29uc3QgZ3JvdXAgPSBtYXBbZGVwdGhdXG4gICAgaWYgKCFncm91cFt0eXBlXSkge1xuICAgICAgZ3JvdXBbdHlwZV0gPSB7fVxuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICBpZiAoIWdyb3VwW3R5cGVdW3JlZl0pIHtcbiAgICAgICAgZ3JvdXBbdHlwZV1bcmVmXSA9IFtdXG4gICAgICB9XG4gICAgICBncm91cFt0eXBlXVtyZWZdLnB1c2goaGFuZGxlcilcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBncm91cFt0eXBlXVtyZWZdID0gaGFuZGxlclxuICAgIH1cbiAgfVxuICBmbHVzaCAoKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXAuc2xpY2UoKVxuICAgIHRoaXMubWFwLmxlbmd0aCA9IDBcbiAgICBtYXAuZm9yRWFjaCgoZ3JvdXApID0+IHtcbiAgICAgIGNhbGxUeXBlTWFwKGdyb3VwLCAncmVwZWF0JylcbiAgICAgIGNhbGxUeXBlTWFwKGdyb3VwLCAnc2hvd24nKVxuICAgICAgY2FsbFR5cGVMaXN0KGdyb3VwLCAnZWxlbWVudCcpXG4gICAgfSlcblxuICAgIGNvbnN0IGhvb2tzID0gdGhpcy5ob29rcy5zbGljZSgpXG4gICAgdGhpcy5ob29rcy5sZW5ndGggPSAwXG4gICAgaG9va3MuZm9yRWFjaCgoZm4pID0+IHtcbiAgICAgIGZuKClcbiAgICB9KVxuXG4gICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5mbHVzaCgpXG4gICAgfVxuICB9XG4gIHRoZW4gKGZuKSB7XG4gICAgdGhpcy5ob29rcy5wdXNoKGZuKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxUeXBlTWFwKGdyb3VwLCB0eXBlKSB7XG4gIGNvbnN0IG1hcCA9IGdyb3VwW3R5cGVdXG4gIGZvciAoY29uc3QgcmVmIGluIG1hcCkge1xuICAgIG1hcFtyZWZdKClcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVHlwZUxpc3QoZ3JvdXAsIHR5cGUpIHtcbiAgY29uc3QgbWFwID0gZ3JvdXBbdHlwZV1cbiAgZm9yIChjb25zdCByZWYgaW4gbWFwKSB7XG4gICAgY29uc3QgbGlzdCA9IG1hcFtyZWZdXG4gICAgbGlzdC5mb3JFYWNoKChoYW5kbGVyKSA9PiB7aGFuZGxlcigpfSlcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9saWIvYXBwL2RpZmZlci5qc1xuICoqLyIsIi8qKlxuICogQGZpbGVPdmVydmlldyBldmVudCBtYW5hZ2VyXG4gKi9cblxuaW1wb3J0ICogYXMgXyBmcm9tICcuLi91dGlsJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFdmVudE1hbmFnZXIoKSB7XG4gIHRoaXMuZWxzID0gW11cbiAgdGhpcy50YXJnZXRzID0gW11cbn1cblxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5fZ2V0ID0gZnVuY3Rpb24gKGVsLCBmb3JjZSkge1xuICB2YXIgaW5kZXggPSBfLmluZGV4T2YodGhpcy5lbHMsIGVsKVxuICB2YXIgdGFyZ2V0XG4gIGlmIChpbmRleCA+PSAwKSB7XG4gICAgdGFyZ2V0ID0gdGhpcy50YXJnZXRzW2luZGV4XVxuICB9XG4gIGVsc2UgaWYgKGZvcmNlKSB7XG4gICAgdGFyZ2V0ID0ge2VsOiBlbCwgZXZlbnRzOiB7fX1cbiAgICB0aGlzLmVscy5wdXNoKGVsKVxuICAgIHRoaXMudGFyZ2V0cy5wdXNoKHRhcmdldClcbiAgfVxuICByZXR1cm4gdGFyZ2V0XG59XG5cbkV2ZW50TWFuYWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGVsLCB0eXBlLCBoYW5kbGVyKSB7XG4gIGlmICh0eXBlb2YgZWwgIT09ICdvYmplY3QnIHx8ICFlbCB8fFxuICAgIHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyB8fCAhdHlwZSB8fFxuICAgIHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRhcmdldCA9IHRoaXMuX2dldChlbCwgdHJ1ZSlcbiAgdGFyZ2V0LmV2ZW50c1t0eXBlXSA9IGhhbmRsZXJcbn1cblxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZWwsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbCAhPT0gJ29iamVjdCcgfHwgIWVsIHx8XG4gICAgdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnIHx8ICF0eXBlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRhcmdldCA9IHRoaXMuX2dldChlbClcbiAgaWYgKHRhcmdldCkge1xuICAgIGRlbGV0ZSB0YXJnZXQuZXZlbnRzW3R5cGVdXG4gIH1cbn1cblxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24gKGVsLCB0eXBlLCBlKSB7XG4gIHZhciB0YXJnZXQgPSB0aGlzLl9nZXQoZWwpXG4gIHZhciBoYW5kbGVyLCBlbFxuICBpZiAodGFyZ2V0KSB7XG4gICAgZWwgPSB0YXJnZXQuZWxcbiAgICBoYW5kbGVyID0gdGFyZ2V0LmV2ZW50c1t0eXBlXVxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbChlbCwgZSlcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL2FwcC9ldmVudC5qc1xuICoqLyIsIi8qKlxuICogQGZpbGVPdmVydmlld1xuICogQSBzaW1wbGUgdmlydHVhbCBkb20gaW1wbGVtZW50YXRpb25cbiAqL1xuXG5jb25zdCBERUZBVUxUX1RBR19OQU1FID0gJ2RpdidcblxuZXhwb3J0IGNvbnN0IGluc3RhbmNlTWFwID0ge31cblxuZXhwb3J0IGZ1bmN0aW9uIERvY3VtZW50KGlkKSB7XG4gIGlkID0gaWQgPyBpZC50b1N0cmluZygpIDogJydcbiAgdGhpcy5pZCA9IGlkXG4gIHRoaXMubmV4dFJlZiA9IDFcbiAgdGhpcy5ub2RlTWFwID0ge31cbiAgdGhpcy5saXN0ZW5lciA9IG51bGxcbiAgdGhpcy5ldmVudE1hbmFnZXIgPSBudWxsXG4gIHRoaXMuY2xvc2VkID0gZmFsc2VcbiAgaW5zdGFuY2VNYXBbaWRdID0gdGhpc1xuXG4gIHRoaXMuY3JlYXRlRG9jdW1lbnRFbGVtZW50KClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lEb2N1bWVudChpZCkge1xuICBkZWxldGUgaW5zdGFuY2VNYXBbaWRdXG59XG5cbkRvY3VtZW50LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNsb3NlZCA9IGZhbHNlXG4gIGlmICh0aGlzLmxpc3RlbmVyKSB7XG4gICAgdGhpcy5saXN0ZW5lci5iYXRjaGVkID0gZmFsc2VcbiAgfVxufVxuRG9jdW1lbnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNsb3NlZCA9IHRydWVcbiAgaWYgKHRoaXMubGlzdGVuZXIpIHtcbiAgICB0aGlzLmxpc3RlbmVyLmJhdGNoZWQgPSB0cnVlXG4gIH1cbn1cblxuRG9jdW1lbnQucHJvdG90eXBlLnNldEV2ZW50TWFuYWdlciA9IGZ1bmN0aW9uIChldmVudE1hbmFnZXIpIHtcbiAgdGhpcy5ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXJcbn1cblxuRG9jdW1lbnQucHJvdG90eXBlLnNldExpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lclxuICBsaXN0ZW5lci5iYXRjaGVkID0gISF0aGlzLmNsb3NlZFxufVxuXG5Eb2N1bWVudC5wcm90b3R5cGUuYWRkUmVmID0gZnVuY3Rpb24gKGVsKSB7XG4gIGVsLnJlZiA9IHRoaXMubmV4dFJlZi50b1N0cmluZygpXG4gIHRoaXMubm9kZU1hcFtlbC5yZWZdID0gZWxcbiAgdGhpcy5uZXh0UmVmKytcbn1cblxuRG9jdW1lbnQucHJvdG90eXBlLmdldFJlZiA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgcmV0dXJuIHRoaXMubm9kZU1hcFtyZWZdXG59XG5cbkRvY3VtZW50LnByb3RvdHlwZS5yZW1vdmVSZWYgPSBmdW5jdGlvbiAocmVmKSB7XG4gIGRlbGV0ZSB0aGlzLm5vZGVNYXBbcmVmXVxufVxuXG5Eb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlRG9jdW1lbnRFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gIGlmICghdGhpcy5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICB0aGlzLmRvY3VtZW50RWxlbWVudCA9IG5ldyBFbGVtZW50KHR5cGUsIHByb3BzLCB0aGlzKVxuICAgIHRoaXMubm9kZU1hcC5fZG9jdW1lbnRFbGVtZW50ID0gdGhpcy5kb2N1bWVudEVsZW1lbnRcbiAgICB0aGlzLmRvY3VtZW50RWxlbWVudC5yZWYgPSAnX2RvY3VtZW50RWxlbWVudCdcbiAgICB0aGlzLmRvY3VtZW50RWxlbWVudC5hdHRhY2hlZCA9IHRydWVcbiAgfVxuXG4gIHJldHVybiB0aGlzLmRvY3VtZW50RWxlbWVudFxufVxuXG5Eb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlQm9keSA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICBpZiAoIXRoaXMuYm9keSkge1xuICAgIHRoaXMuYm9keSA9IG5ldyBFbGVtZW50KHR5cGUsIHByb3BzLCB0aGlzKVxuICAgIHRoaXMubm9kZU1hcC5fcm9vdCA9IHRoaXMuYm9keVxuICAgIHRoaXMuYm9keS5yZWYgPSAnX3Jvb3QnXG4gICAgdGhpcy5ib2R5LmRlcHRoID0gMVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuYm9keVxufVxuXG5Eb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcykge1xuICByZXR1cm4gbmV3IEVsZW1lbnQodGFnTmFtZSwgcHJvcHMsIHRoaXMpXG59XG5cbkRvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVDb21tZW50ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgcmV0dXJuIG5ldyBDb21tZW50KHRleHQsIHRoaXMpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBOb2RlKCkge1xufVxuXG5Ob2RlLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoaW5zdGFuY2VJZCkge1xuICB0aGlzLnBhcmVudFJlZiA9IG51bGxcbiAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlXG4gIGlmIChpbnN0YW5jZUlkKSB7XG4gICAgdGhpcy5pbnN0YW5jZUlkID0gaW5zdGFuY2VJZFxuICAgIGNvbnN0IGRvYyA9IGluc3RhbmNlTWFwW2luc3RhbmNlSWRdXG4gICAgZG9jLmFkZFJlZih0aGlzKVxuICB9XG59XG5cbk5vZGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHJlZiA9IHRoaXMucmVmXG4gIGNvbnN0IGluc3RhbmNlSWQgPSB0aGlzLmluc3RhbmNlSWRcbiAgaWYgKGluc3RhbmNlSWQpIHtcbiAgICBjb25zdCBkb2MgPSBpbnN0YW5jZU1hcFtpbnN0YW5jZUlkXVxuICAgIGRvYy5yZW1vdmVSZWYocmVmKVxuICB9XG5cbiAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuIHx8IFtdXG4gIGNvbnN0IGxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY2hpbGRyZW5baV0uZGVzdHJveSgpXG4gIH1cbn1cblxuTm9kZS5wcm90b3R5cGUuZ2V0UmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGRvYyA9IGluc3RhbmNlTWFwW3RoaXMuaW5zdGFuY2VJZF1cbiAgcmV0dXJuIGRvYy5saXN0ZW5lclxufVxuXG5Ob2RlLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBpbnN0YW5jZUlkID0gdGhpcy5pbnN0YW5jZUlkXG4gIGNvbnN0IGRvYyA9IGluc3RhbmNlTWFwW2luc3RhbmNlSWRdXG4gIGNvbnN0IHBhcmVudCA9IGRvYy5nZXRSZWYodGhpcy5wYXJlbnRSZWYpXG4gIGlmIChwYXJlbnQpIHtcbiAgICByZXR1cm4gcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpICsgMV1cbiAgfVxufVxuXG5Ob2RlLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBpbnN0YW5jZUlkID0gdGhpcy5pbnN0YW5jZUlkXG4gIGNvbnN0IGRvYyA9IGluc3RhbmNlTWFwW2luc3RhbmNlSWRdXG4gIGNvbnN0IHBhcmVudCA9IGRvYy5nZXRSZWYodGhpcy5wYXJlbnRSZWYpXG4gIGlmIChwYXJlbnQpIHtcbiAgICByZXR1cm4gcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpIC0gMV1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRWxlbWVudCh0eXBlPURFRkFVTFRfVEFHX05BTUUsIHByb3BzLCBvd25lckRvY3VtZW50KSB7XG4gIHByb3BzID0gcHJvcHMgfHwge31cbiAgdGhpcy5jcmVhdGUob3duZXJEb2N1bWVudC5pZClcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gb3duZXJEb2N1bWVudFxuICB0aGlzLnR5cGUgPSB0eXBlXG4gIHRoaXMuYXR0ciA9IHByb3BzLmF0dHIgfHwge31cbiAgdGhpcy5jbGFzc1N0eWxlID0gcHJvcHMuY2xhc3NTdHlsZSB8fCB7fVxuICB0aGlzLnN0eWxlID0gcHJvcHMuc3R5bGUgfHwge31cbiAgdGhpcy5ldmVudCA9IFtdXG4gIHRoaXMuY2hpbGRyZW4gPSBbXVxuICB0aGlzLnB1cmVDaGlsZHJlbiA9IFtdXG59XG5cbkVsZW1lbnQucHJvdG90eXBlID0gbmV3IE5vZGUoKVxuXG5FbGVtZW50LnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChub2RlKSB7XG5cbiAgcmVtb3ZlSWZFeGlzdGVkKG5vZGUpXG4gIG5vZGUucGFyZW50UmVmID0gdGhpcy5yZWZcbiAgdGhpcy5jaGlsZHJlbi5wdXNoKG5vZGUpXG5cbiAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICBzZXRBdHRhY2hlZChub2RlLCB0aGlzLmRlcHRoKVxuICB9XG4gIGVsc2Uge1xuICAgIHNldERldGFjaGVkKG5vZGUpXG4gIH1cblxuICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICB0aGlzLnB1cmVDaGlsZHJlbi5wdXNoKG5vZGUpXG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLmdldFJlbmRlcmVyKClcbiAgICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgICBpZiAodGhpcy5yZWYgPT09ICdfZG9jdW1lbnRFbGVtZW50Jykge1xuICAgICAgICAgIC8vIGlmIGl0cyBwYXJlbnQgaXMgZG9jdW1lbnRFbGVtZW50IHRoZW4gaXQncyBhIGJvZHlcbiAgICAgICAgICByZW5kZXJlci5jcmVhdGVCb2R5KG5vZGUsIHRoaXMucmVmKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlbmRlcmVyLmFkZEVsZW1lbnQobm9kZSwgdGhpcy5yZWYpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuRWxlbWVudC5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKG5vZGUsIGJlZm9yZSkge1xuXG4gIGlmIChub2RlLnBhcmVudFJlZiA9PT0gdGhpcy5yZWYpIHtcbiAgICBtb3ZlQmVmb3JlKG5vZGUsIGJlZm9yZSwgdGhpcy5jaGlsZHJlbilcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHB1cmVCZWZvcmVJbmRleCA9IG1vdmVQdXJlQmVmb3JlKG5vZGUsIGJlZm9yZSwgdGhpcy5wdXJlQ2hpbGRyZW4pXG4gICAgICBpZiAocHVyZUJlZm9yZUluZGV4ID49IDAgJiYgdGhpcy5hdHRhY2hlZCkge1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuZ2V0UmVuZGVyZXIoKVxuICAgICAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgICAgICByZW5kZXJlci5tb3ZlRWxlbWVudChub2RlLnJlZiwgdGhpcy5yZWYsIHB1cmVCZWZvcmVJbmRleClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIHJlbW92ZUlmRXhpc3RlZChub2RlKVxuXG4gIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlblxuICBjb25zdCBpbmRleCA9IGNoaWxkcmVuLmluZGV4T2YoYmVmb3JlKVxuXG4gIG5vZGUucGFyZW50UmVmID0gdGhpcy5yZWZcbiAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICBzZXRBdHRhY2hlZChub2RlLCB0aGlzLmRlcHRoKVxuICB9XG4gIGVsc2Uge1xuICAgIHNldERldGFjaGVkKG5vZGUpXG4gIH1cbiAgY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBub2RlKVxuXG4gIGlmIChub2RlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgIGNvbnN0IHB1cmVDaGlsZHJlbiA9IHRoaXMucHVyZUNoaWxkcmVuXG4gICAgY29uc3QgcHVyZUluZGV4ID0gZ2V0UHVyZUFmdGVyKGJlZm9yZSwgcHVyZUNoaWxkcmVuKVxuXG4gICAgcHVyZUNoaWxkcmVuLnNwbGljZShwdXJlSW5kZXgsIDAsIG5vZGUpXG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLmdldFJlbmRlcmVyKClcbiAgICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgICByZW5kZXJlci5hZGRFbGVtZW50KG5vZGUsIHRoaXMucmVmLCBwdXJlSW5kZXgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbkVsZW1lbnQucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24gKG5vZGUsIGFmdGVyKSB7XG5cbiAgaWYgKG5vZGUucGFyZW50UmVmID09PSB0aGlzLnJlZikge1xuICAgIG1vdmVBZnRlcihub2RlLCBhZnRlciwgdGhpcy5jaGlsZHJlbilcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHB1cmVBZnRlckluZGV4ID0gbW92ZVB1cmVBZnRlcihub2RlLCBhZnRlciwgdGhpcy5wdXJlQ2hpbGRyZW4pXG4gICAgICBpZiAocHVyZUFmdGVySW5kZXggPj0gMCAmJiB0aGlzLmF0dGFjaGVkKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5nZXRSZW5kZXJlcigpXG4gICAgICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgICAgIHJlbmRlcmVyLm1vdmVFbGVtZW50KG5vZGUucmVmLCB0aGlzLnJlZiwgcHVyZUFmdGVySW5kZXgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICByZW1vdmVJZkV4aXN0ZWQobm9kZSlcblxuICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW5cbiAgY29uc3QgaW5kZXggPSBjaGlsZHJlbi5pbmRleE9mKGFmdGVyKVxuXG4gIG5vZGUucGFyZW50UmVmID0gdGhpcy5yZWZcbiAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICBzZXRBdHRhY2hlZChub2RlLCB0aGlzLmRlcHRoKVxuICB9XG4gIGVsc2Uge1xuICAgIHNldERldGFjaGVkKG5vZGUpXG4gIH1cbiAgY2hpbGRyZW4uc3BsaWNlKGluZGV4ICsgMSwgMCwgbm9kZSlcblxuICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICBjb25zdCBwdXJlQ2hpbGRyZW4gPSB0aGlzLnB1cmVDaGlsZHJlblxuICAgIGNvbnN0IHB1cmVJbmRleCA9IGdldFB1cmVCZWZvcmUoYWZ0ZXIsIHB1cmVDaGlsZHJlbilcblxuICAgIHB1cmVDaGlsZHJlbi5zcGxpY2UocHVyZUluZGV4ICsgMSwgMCwgbm9kZSlcblxuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuZ2V0UmVuZGVyZXIoKVxuICAgICAgaWYgKHJlbmRlcmVyKSB7XG4gICAgICAgIHJlbmRlcmVyLmFkZEVsZW1lbnQobm9kZSwgdGhpcy5yZWYsIHB1cmVJbmRleCArIDEpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbkVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKG5vZGUsIHByZXNlcnZlZCkge1xuICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW5cbiAgY29uc3QgaW5kZXggPSBjaGlsZHJlbi5pbmRleE9mKG5vZGUpXG5cbiAgc2V0RGV0YWNoZWQobm9kZSlcblxuICBpZiAoaW5kZXggPj0gMCkge1xuICAgIG5vZGUucGFyZW50UmVmID0gbnVsbFxuICAgIGNoaWxkcmVuLnNwbGljZShpbmRleCwgMSlcbiAgICBpZiAoIXByZXNlcnZlZCkge1xuICAgICAgbm9kZS5kZXN0cm95KClcbiAgICB9XG4gIH1cblxuICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICB0aGlzLnB1cmVDaGlsZHJlbi4kcmVtb3ZlKG5vZGUpXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5nZXRSZW5kZXJlcigpXG4gICAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgICAgcmVuZGVyZXIucmVtb3ZlRWxlbWVudChub2RlLnJlZilcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuRWxlbWVudC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlblxuICBjb25zdCBsZW5ndGggPSBjaGlsZHJlbi5sZW5ndGhcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV1cbiAgICBjaGlsZC5wYXJlbnRSZWYgPSBudWxsXG4gICAgc2V0RGV0YWNoZWQoY2hpbGQpXG4gICAgY2hpbGQuZGVzdHJveSgpXG4gIH1cbiAgY2hpbGRyZW4ubGVuZ3RoID0gMFxuXG4gIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgY29uc3QgcmVmcyA9IHRoaXMucHVyZUNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLnJlZilcbiAgICB0aGlzLnB1cmVDaGlsZHJlbi5sZW5ndGggPSAwXG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLmdldFJlbmRlcmVyKClcbiAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgIHJlbmRlcmVyLnJlbW92ZUVsZW1lbnQocmVmcylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbW92ZUJlZm9yZShub2RlLCBiZWZvcmUsIGNoaWxkcmVuKSB7XG4gIGNvbnN0IHRhcmdldEluZGV4ID0gY2hpbGRyZW4uaW5kZXhPZihub2RlKVxuICBjb25zdCBiZWZvcmVJbmRleCA9IGNoaWxkcmVuLmluZGV4T2YoYmVmb3JlKVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICh0YXJnZXRJbmRleCA9PT0gYmVmb3JlSW5kZXggfHwgdGFyZ2V0SW5kZXggKyAxID09PSBiZWZvcmVJbmRleCkge1xuICAgIHJldHVybiAtMVxuICB9XG5cbiAgY29uc3QgbmV3SW5kZXggPSB0YXJnZXRJbmRleCA8IGJlZm9yZUluZGV4ID8gYmVmb3JlSW5kZXggLSAxIDogYmVmb3JlSW5kZXhcbiAgY2hpbGRyZW4uc3BsaWNlKHRhcmdldEluZGV4LCAxKVxuICBjaGlsZHJlbi5zcGxpY2UobmV3SW5kZXgsIDAsIG5vZGUpXG5cbiAgcmV0dXJuIGJlZm9yZUluZGV4XG59XG5cbmZ1bmN0aW9uIG1vdmVQdXJlQmVmb3JlKG5vZGUsIGJlZm9yZSwgcHVyZUNoaWxkcmVuKSB7XG4gIGNvbnN0IHB1cmVUYXJnZXRJbmRleCA9IHB1cmVDaGlsZHJlbi5pbmRleE9mKG5vZGUpXG4gIGNvbnN0IHB1cmVCZWZvcmVJbmRleCA9IGdldFB1cmVBZnRlcihiZWZvcmUsIHB1cmVDaGlsZHJlbilcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAocHVyZVRhcmdldEluZGV4ID09PSBwdXJlQmVmb3JlSW5kZXggfHxcbiAgICBwdXJlVGFyZ2V0SW5kZXggKyAxID09PSBwdXJlQmVmb3JlSW5kZXgpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIGNvbnN0IHB1cmVOZXdJbmRleCA9IHB1cmVUYXJnZXRJbmRleCA8IHB1cmVCZWZvcmVJbmRleFxuICAgID8gcHVyZUJlZm9yZUluZGV4IC0gMVxuICAgIDogcHVyZUJlZm9yZUluZGV4XG5cbiAgcHVyZUNoaWxkcmVuLnNwbGljZShwdXJlVGFyZ2V0SW5kZXgsIDEpXG4gIHB1cmVDaGlsZHJlbi5zcGxpY2UocHVyZU5ld0luZGV4LCAwLCBub2RlKVxuXG4gIHJldHVybiBwdXJlQmVmb3JlSW5kZXhcbn1cblxuZnVuY3Rpb24gZ2V0UHVyZUFmdGVyKG5vZGUsIHB1cmVDaGlsZHJlbikge1xuICBsZXQgcHVyZUluZGV4ID0gcHVyZUNoaWxkcmVuLmluZGV4T2Yobm9kZSlcbiAgd2hpbGUgKG5vZGUgJiYgcHVyZUluZGV4IDwgMCkge1xuICAgIG5vZGUgPSBub2RlLm5leHQoKVxuICAgIHB1cmVJbmRleCA9IHB1cmVDaGlsZHJlbi5pbmRleE9mKG5vZGUpXG4gIH1cbiAgaWYgKHB1cmVJbmRleCA8IDApIHtcbiAgICBwdXJlSW5kZXggPSBwdXJlQ2hpbGRyZW4ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIHB1cmVJbmRleFxufVxuXG5mdW5jdGlvbiBtb3ZlQWZ0ZXIobm9kZSwgYWZ0ZXIsIGNoaWxkcmVuKSB7XG4gIGNvbnN0IHRhcmdldEluZGV4ID0gY2hpbGRyZW4uaW5kZXhPZihub2RlKVxuICBjb25zdCBhZnRlckluZGV4ID0gY2hpbGRyZW4uaW5kZXhPZihhZnRlcilcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAodGFyZ2V0SW5kZXggPT09IGFmdGVySW5kZXggfHwgdGFyZ2V0SW5kZXggPT09IGFmdGVySW5kZXggKyAxKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICBjb25zdCBuZXdJbmRleCA9IHRhcmdldEluZGV4IDwgYWZ0ZXJJbmRleCA/IGFmdGVySW5kZXggOiBhZnRlckluZGV4ICsgMVxuICBjaGlsZHJlbi5zcGxpY2UodGFyZ2V0SW5kZXgsIDEpXG4gIGNoaWxkcmVuLnNwbGljZShuZXdJbmRleCwgMCwgbm9kZSlcblxuICByZXR1cm4gYWZ0ZXJJbmRleFxufVxuXG5mdW5jdGlvbiBtb3ZlUHVyZUFmdGVyKG5vZGUsIGFmdGVyLCBwdXJlQ2hpbGRyZW4pIHtcbiAgY29uc3QgcHVyZVRhcmdldEluZGV4ID0gcHVyZUNoaWxkcmVuLmluZGV4T2Yobm9kZSlcbiAgY29uc3QgcHVyZUFmdGVySW5kZXggPSBnZXRQdXJlQmVmb3JlKGFmdGVyLCBwdXJlQ2hpbGRyZW4pXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKHB1cmVUYXJnZXRJbmRleCA9PT0gcHVyZUFmdGVySW5kZXggfHxcbiAgICBwdXJlVGFyZ2V0SW5kZXggPT09IHB1cmVBZnRlckluZGV4ICsgMSkge1xuICAgIHJldHVybiAtMVxuICB9XG5cbiAgY29uc3QgcHVyZU5ld0luZGV4ID0gcHVyZVRhcmdldEluZGV4IDwgcHVyZUFmdGVySW5kZXhcbiAgICA/IHB1cmVBZnRlckluZGV4XG4gICAgOiBwdXJlQWZ0ZXJJbmRleCArIDFcblxuICBwdXJlQ2hpbGRyZW4uc3BsaWNlKHB1cmVUYXJnZXRJbmRleCwgMSlcbiAgcHVyZUNoaWxkcmVuLnNwbGljZShwdXJlTmV3SW5kZXgsIDAsIG5vZGUpXG5cbiAgcmV0dXJuIHB1cmVBZnRlckluZGV4ICsgMVxufVxuXG5mdW5jdGlvbiBnZXRQdXJlQmVmb3JlKG5vZGUsIHB1cmVDaGlsZHJlbikge1xuICBsZXQgcHVyZUluZGV4ID0gcHVyZUNoaWxkcmVuLmluZGV4T2Yobm9kZSlcbiAgd2hpbGUgKG5vZGUgJiYgcHVyZUluZGV4IDwgMCkge1xuICAgIG5vZGUgPSBub2RlLnByZXYoKVxuICAgIHB1cmVJbmRleCA9IHB1cmVDaGlsZHJlbi5pbmRleE9mKG5vZGUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKHB1cmVJbmRleCA8IDApIHtcbiAgICBwdXJlSW5kZXggPSAtMVxuICB9XG4gIHJldHVybiBwdXJlSW5kZXhcbn1cblxuZnVuY3Rpb24gc2V0QXR0YWNoZWQobm9kZSwgZGVwdGgpIHtcbiAgaWYgKG5vZGUucmVmID09PSAnX3Jvb3QnKSB7XG4gICAgZGVwdGggPSAxXG4gIH1cbiAgZWxzZSB7XG4gICAgZGVwdGggPSBkZXB0aCA+IDAgPyBkZXB0aCArIDEgOiAwXG4gIH1cbiAgbm9kZS5hdHRhY2hlZCA9IHRydWVcbiAgbm9kZS5kZXB0aCA9IGRlcHRoXG4gIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKChzdWIpID0+IHtcbiAgICAgIHNldEF0dGFjaGVkKHN1YiwgZGVwdGgpXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXREZXRhY2hlZChub2RlKSB7XG4gIG5vZGUuYXR0YWNoZWQgPSBmYWxzZVxuICBub2RlLmRlcHRoID0gMFxuICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoc3ViKSA9PiB7XG4gICAgICBzZXREZXRhY2hlZChzdWIpXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVJZkV4aXN0ZWQobm9kZSkge1xuICBjb25zdCBkb2MgPSBpbnN0YW5jZU1hcFtub2RlLmluc3RhbmNlSWRdXG4gIGlmIChkb2MpIHtcbiAgICBjb25zdCBleGlzdGVkTm9kZSA9IGRvYy5nZXRSZWYobm9kZS5yZWYpXG4gICAgaWYgKGV4aXN0ZWROb2RlKSB7XG4gICAgICBjb25zdCBleGlzdGVkUGFyZW50ID0gZG9jLmdldFJlZihleGlzdGVkTm9kZS5wYXJlbnRSZWYpXG4gICAgICBpZiAoZXhpc3RlZFBhcmVudCAmJiBleGlzdGVkUGFyZW50LnJlbW92ZUNoaWxkKSB7XG4gICAgICAgIGV4aXN0ZWRQYXJlbnQucmVtb3ZlQ2hpbGQoZXhpc3RlZE5vZGUsIHRydWUpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbkVsZW1lbnQucHJvdG90eXBlLnNldEF0dHIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICBpZiAodGhpcy5hdHRyW2tleV0gPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdGhpcy5hdHRyW2tleV0gPSB2YWx1ZVxuICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5nZXRSZW5kZXJlcigpXG4gICAgaWYgKHJlbmRlcmVyKSB7XG4gICAgICByZW5kZXJlci5zZXRBdHRyKHRoaXMucmVmLCBrZXksIHZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG5FbGVtZW50LnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIGlmICh0aGlzLnN0eWxlW2tleV0gPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdGhpcy5zdHlsZVtrZXldID0gdmFsdWVcbiAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuZ2V0UmVuZGVyZXIoKVxuICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5yZWYsIGtleSwgdmFsdWUpXG4gICAgfVxuICB9XG59XG5cbkVsZW1lbnQucHJvdG90eXBlLnNldENsYXNzU3R5bGUgPSBmdW5jdGlvbiAoY2xhc3NTdHlsZSkge1xuICB0aGlzLmNsYXNzU3R5bGUgPSBjbGFzc1N0eWxlXG4gIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLmdldFJlbmRlcmVyKClcbiAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgIHJlbmRlcmVyLnNldFN0eWxlcyh0aGlzLnJlZiwgdGhpcy50b1N0eWxlKCkpXG4gICAgfVxuICB9XG59XG5cbkVsZW1lbnQucHJvdG90eXBlLmFkZEV2ZW50ID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgY29uc3QgaW5kZXggPSB0aGlzLmV2ZW50LmluZGV4T2YodHlwZSlcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgdGhpcy5ldmVudC5wdXNoKHR5cGUpXG4gICAgbGV0IGV2ZW50TWFuYWdlciA9IHRoaXMub3duZXJEb2N1bWVudC5ldmVudE1hbmFnZXJcbiAgICBldmVudE1hbmFnZXIuYWRkKHRoaXMsIHR5cGUsIGhhbmRsZXIpXG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLmdldFJlbmRlcmVyKClcbiAgICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgICByZW5kZXJlci5hZGRFdmVudCh0aGlzLnJlZiwgdHlwZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAodHlwZSkge1xuICBjb25zdCBpbmRleCA9IHRoaXMuZXZlbnQuaW5kZXhPZih0eXBlKVxuXG4gIGlmIChpbmRleCA+PSAwKSB7XG4gICAgdGhpcy5ldmVudC5zcGxpY2UoaW5kZXgsIDEpXG4gICAgbGV0IGV2ZW50TWFuYWdlciA9IHRoaXMub3duZXJEb2N1bWVudC5ldmVudE1hbmFnZXJcbiAgICBldmVudE1hbmFnZXIucmVtb3ZlKHRoaXMsIHR5cGUpXG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLmdldFJlbmRlcmVyKClcbiAgICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgICByZW5kZXJlci5yZW1vdmVFdmVudCh0aGlzLnJlZiwgdHlwZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuRWxlbWVudC5wcm90b3R5cGUudG9TdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgcmVzdWx0ID0ge31cbiAgY29uc3QgY2xhc3NTdHlsZSA9IHRoaXMuY2xhc3NTdHlsZVxuICBjb25zdCBzdHlsZSA9IHRoaXMuc3R5bGVcbiAgZm9yIChjb25zdCBuYW1lIGluIGNsYXNzU3R5bGUpIHtcbiAgICByZXN1bHRbbmFtZV0gPSBjbGFzc1N0eWxlW25hbWVdXG4gIH1cbiAgZm9yIChjb25zdCBuYW1lIGluIHN0eWxlKSB7XG4gICAgcmVzdWx0W25hbWVdID0gc3R5bGVbbmFtZV1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbkVsZW1lbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHJlZjogdGhpcy5yZWYudG9TdHJpbmcoKSxcbiAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgYXR0cjogdGhpcy5hdHRyLFxuICAgIHN0eWxlOiB0aGlzLnRvU3R5bGUoKVxuICB9XG5cbiAgaWYgKHRoaXMuZXZlbnQgJiYgdGhpcy5ldmVudC5sZW5ndGgpIHtcbiAgICByZXN1bHQuZXZlbnQgPSB0aGlzLmV2ZW50XG4gIH1cbiAgaWYgKHRoaXMucHVyZUNoaWxkcmVuICYmIHRoaXMucHVyZUNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHJlc3VsdC5jaGlsZHJlbiA9IHRoaXMucHVyZUNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLnRvSlNPTigpKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5FbGVtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICc8JyArIHRoaXMudHlwZSArXG4gICAgJyBhdHRyPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmF0dHIpICtcbiAgICAnIHN0eWxlPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnRvU3R5bGUoKSkgKyAnPicgK1xuICAgIHRoaXMucHVyZUNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLnRvU3RyaW5nKCkpLmpvaW4oJycpICtcbiAgICAnPC8nICsgdGhpcy50eXBlICsgJz4nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDb21tZW50KHZhbHVlLCBvd25lckRvY3VtZW50KSB7XG4gIHRoaXMuY3JlYXRlKG93bmVyRG9jdW1lbnQuaWQpXG4gIHRoaXMudHlwZSA9ICdjb21tZW50J1xuICB0aGlzLnZhbHVlID0gdmFsdWVcbn1cblxuQ29tbWVudC5wcm90b3R5cGUgPSBuZXcgTm9kZSgpXG5cbkNvbW1lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJzwhLS0gJyArIHRoaXMudmFsdWUgKyAnIC0tPidcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL2FwcC9kb20uanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJuYW1lXCI6IFwid2VleC1qc2ZyYW1ld29ya1wiLFxuXHRcInZlcnNpb25cIjogXCIwLjEzLjlcIixcblx0XCJkZXNjcmlwdGlvblwiOiBcIkpTIEZyYW1ld29yayBmb3IgV2VleCBzb2x1dGlvbiB3aGljaCBpcyBhIGV4dGVuZGFibGUgY3Jvc3MtcGxhdGZvcm0gc29sdXRpb24gZm9yIGR5bmFtaWMgcHJvZ3JhbW1pbmcgYW5kIHB1Ymxpc2hpbmcgcHJvamVjdHNcIixcblx0XCJtYWluXCI6IFwiaW5kZXguanNcIixcblx0XCJzY3JpcHRzXCI6IHtcblx0XHRcImRldlwiOiBcIndlYnBhY2sgLS13YXRjaCAtLWNvbmZpZyAuL3dlYnBhY2suY29uZmlnLmpzXCIsXG5cdFx0XCJidWlsZFwiOiBcIndlYnBhY2sgLS1jb25maWcgLi93ZWJwYWNrLmNvbmZpZy5qc1wiLFxuXHRcdFwiY29tcHJlc3NcIjogXCJ1Z2xpZnlqcyBkaXN0L2luZGV4LmpzIC1vIGRpc3QvaW5kZXgubWluLmpzXCIsXG5cdFx0XCJsaW50XCI6IFwianNjcyAtLWNvbmZpZyAuanNjc3JjIHBvbHlmaWxsLyouanMgcG9seWZpbGwvX190ZXN0X18vKi5qcyBsaWIvKi5qcyBsaWIvX190ZXN0X18vKi5qcyBsaWIvYXBwLyouanMgbGliL2FwcC9fX3Rlc3RfXy8qLmpzIGxpYi92bS8qLmpzIGxpYi92bS9fX3Rlc3RfXy8qLmpzXCIsXG5cdFx0XCJ0ZXN0XCI6IFwibW9jaGEgLS1jb21waWxlcnMganM6YmFiZWwtY29yZS9yZWdpc3RlciBwb2x5ZmlsbC9fX3Rlc3RfXy8qLmpzIGxpYi9fX3Rlc3RfXy8qLmpzIGxpYi8qKi9fX3Rlc3RfXy8qLmpzXCIsXG5cdFx0XCJjb3ZlclwiOiBcImJhYmVsLW5vZGUgbm9kZV9tb2R1bGVzL2lzcGFydGEvYmluL2lzcGFydGEgY292ZXIgLS1yZXBvcnQgdGV4dCBub2RlX21vZHVsZXMvbW9jaGEvYmluL19tb2NoYSAtLSAtLXJlcG9ydGVyIGRvdCBsaWIvX190ZXN0X18vKi5qcyBsaWIvKiovX190ZXN0X18vKi5qc1wiLFxuXHRcdFwiY2lcIjogXCJucG0gcnVuIGxpbnQgJiYgbnBtIHJ1biBjb3ZlclwiXG5cdH0sXG5cdFwicmVwb3NpdG9yeVwiOiB7XG5cdFx0XCJ0eXBlXCI6IFwiZ2l0XCIsXG5cdFx0XCJ1cmxcIjogXCJnaXRAZ2l0aHViLmNvbTphbGliYWJhL3dlZXguZ2l0XCJcblx0fSxcblx0XCJhdXRob3JcIjogW1xuXHRcdHtcblx0XHRcdFwibmFtZVwiOiBcImppbmppYW5nXCIsXG5cdFx0XHRcImVtYWlsXCI6IFwiemhhb2ppbmppYW5nQG1lLmNvbVwiXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcIm5hbWVcIjogXCJUZXJyeSBLaW5nXCIsXG5cdFx0XHRcImVtYWlsXCI6IFwidGVycnlraW5nY2hhQGdtYWlsLmNvbVwiXG5cdFx0fVxuXHRdLFxuXHRcImNvbnRyaWJ1dG9yc1wiOiBbXG5cdFx0e1xuXHRcdFx0XCJuYW1lXCI6IFwicHVzaGltaW5nXCIsXG5cdFx0XHRcImVtYWlsXCI6IFwicHVzaGltaW5nQGdtYWlsLmNvbVwiXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcIm5hbWVcIjogXCJpc2tlbmh1YW5nXCIsXG5cdFx0XHRcImVtYWlsXCI6IFwiaXNrZW5odWFuZ0BnbWFpbC5jb21cIlxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJuYW1lXCI6IFwieXVhbnlhblwiLFxuXHRcdFx0XCJlbWFpbFwiOiBcInl1YW55YW4uY2FvQGdtYWlsLmNvbVwiXG5cdFx0fVxuXHRdLFxuXHRcImtleXdvcmRzXCI6IFtcblx0XHRcIndlZXhcIixcblx0XHRcIm12dm1cIixcblx0XHRcImJyb3dzZXJcIixcblx0XHRcImh5YnJpZFwiLFxuXHRcdFwiZnJhbWV3b3JrXCJcblx0XSxcblx0XCJsaWNlbnNlXCI6IFwiQXBhY2hlLTIuMFwiLFxuXHRcImRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJzZW12ZXJcIjogXCJ+NS4xLjBcIixcblx0XHRcImNvcmUtanNcIjogXCJ+Mi4xLjFcIlxuXHR9LFxuXHRcImRldkRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJiYWJlbC1jbGlcIjogXCJ+Ni40LjVcIixcblx0XHRcImJhYmVsLWNvcmVcIjogXCJ+Ni40LjVcIixcblx0XHRcImJhYmVsLWxvYWRlclwiOiBcIn42LjIuMVwiLFxuXHRcdFwiYmFiZWwtcHJlc2V0LWVzMjAxNVwiOiBcIn42LjMuMTNcIixcblx0XHRcImNoYWlcIjogXCJ+My4yLjBcIixcblx0XHRcImlzcGFydGFcIjogXCJ+NC4wLjBcIixcblx0XHRcImlzdGFuYnVsXCI6IFwifjAuNC4yXCIsXG5cdFx0XCJqc2NzXCI6IFwifjIuOS4wXCIsXG5cdFx0XCJqc29uLWxvYWRlclwiOiBcIl4wLjUuNFwiLFxuXHRcdFwibW9jaGFcIjogXCJ+Mi4zLjRcIixcblx0XHRcInNpbm9uXCI6IFwifjEuMTcuMlwiLFxuXHRcdFwic2lub24tY2hhaVwiOiBcIn4yLjguMFwiLFxuXHRcdFwidWdsaWZ5LWpzXCI6IFwiXjIuNi4yXCIsXG5cdFx0XCJ3YXRjaC1jbGlcIjogXCJ+MC4yLjFcIixcblx0XHRcIndlYnBhY2tcIjogXCJ+MS4xMi4xMlwiXG5cdH0sXG5cdFwib3B0aW9uYWxEZXBlbmRlbmNpZXNcIjoge1xuXHRcdFwid2VleC10cmFuc2Zvcm1lclwiOiBcIj49MC4xLjUgPDAuNFwiXG5cdH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3BhY2thZ2UuanNvblxuICoqIG1vZHVsZSBpZCA9IDEwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFRoZSBhcGkgZm9yIGludm9raW5nIHdpdGggXCIkXCIgcHJlZml4XG4gKi9cbmltcG9ydCB7dHlwb2YsIGV4dGVuZH0gZnJvbSAnLi4vdXRpbCdcblxuLyoqXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBjb21tb25cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSAkdm0gaW5zdGVhZFxuICogZmluZCB0aGUgdm0gYnkgaWRcbiAqIE5vdGU6IHRoZXJlIGlzIG9ubHkgb25lIGlkIGluIHdob2xlIGNvbXBvbmVudFxuICogQHBhcmFtICB7c3RyaW5nfSBpZFxuICogQHJldHVybiB7Vm19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiAkKGlkKSB7XG4gIG5hdGl2ZUxvZygnW1dBUk5JTkddIHRoZSBWbSMkIGFwaSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIFZtIyR2bSBpbnN0ZWFkJylcbiAgY29uc3QgaW5mbyA9IHRoaXMuX2lkc1tpZF1cbiAgaWYgKGluZm8pIHtcbiAgICByZXR1cm4gaW5mby52bVxuICB9XG59XG5cbi8qKlxuICogZmluZCB0aGUgZWxlbWVudCBieSBpZFxuICogTm90ZTogdGhlcmUgaXMgb25seSBvbmUgaWQgaW4gd2hvbGUgY29tcG9uZW50XG4gKiBAcGFyYW0gIHtzdHJpbmd9IGlkXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gJGVsKGlkKSB7XG4gIGNvbnN0IGluZm8gPSB0aGlzLl9pZHNbaWRdXG4gIGlmIChpbmZvKSB7XG4gICAgcmV0dXJuIGluZm8uZWxcbiAgfVxufVxuXG4vKipcbiAqIGZpbmQgdGhlIHZtIG9mIHRoZSBjdXN0b20gY29tcG9uZW50IGJ5IGlkXG4gKiBOb3RlOiB0aGVyZSBpcyBvbmx5IG9uZSBpZCBpbiB3aG9sZSBjb21wb25lbnRcbiAqIEBwYXJhbSAge3N0cmluZ30gaWRcbiAqIEByZXR1cm4ge1ZtfVxuICovXG5leHBvcnQgZnVuY3Rpb24gJHZtKGlkKSB7XG4gIGNvbnN0IGluZm8gPSB0aGlzLl9pZHNbaWRdXG4gIGlmIChpbmZvKSB7XG4gICAgcmV0dXJuIGluZm8udm1cbiAgfVxufVxuXG4vKipcbiAqIEZpcmUgd2hlbiBkaWZmZXIgcmVuZGVyaW5nIGZpbmlzaGVkXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiAkcmVuZGVyVGhlbihmbikge1xuICBjb25zdCBhcHAgPSB0aGlzLl9hcHBcbiAgY29uc3QgZGlmZmVyID0gYXBwLmRpZmZlclxuICByZXR1cm4gZGlmZmVyLnRoZW4oKCkgPT4ge1xuICAgIGZuKClcbiAgfSlcbn1cblxuLyoqXG4gKiBzY3JvbGwgYW4gZWxlbWVudCBzcGVjaWZpZWQgYnkgaWQgaW50byB2aWV3LCBcbiAqIG1vcmVvdmVyIHNwZWNpZnkgYSBudW1iZXIgb2Ygb2Zmc2V0IG9wdGlvbmFsbHlcbiAqIEBwYXJhbSAge3N0cmluZ30gaWRcbiAqIEBwYXJhbSAge251bWJlcn0gb2Zmc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiAkc2Nyb2xsVG8oaWQsIG9mZnNldCkge1xuICBjb25zdCBlbCA9IHRoaXMuJGVsKGlkKVxuICBpZiAoZWwpIHtcbiAgICBjb25zdCBkb20gPSB0aGlzLl9hcHAucmVxdWlyZU1vZHVsZSgnZG9tJylcbiAgICBkb20uc2Nyb2xsVG9FbGVtZW50KGVsLnJlZiwge29mZnNldDogb2Zmc2V0fSlcbiAgfVxufVxuXG4vKipcbiAqIHBlcmZvcm0gdHJhbnNpdGlvbiBhbmltYXRpb24gb24gYW4gZWxlbWVudCBzcGVjaWZpZWQgYnkgaWRcbiAqIEBwYXJhbSAge3N0cmluZ30gICBpZFxuICogQHBhcmFtICB7b2JqZWN0fSAgIG9wdGlvbnNcbiAqIEBwYXJhbSAge29iamVjdH0gICBvcHRpb25zLnN0eWxlc1xuICogQHBhcmFtICB7b2JqZWN0fSAgIG9wdGlvbnMuZHVyYXRpb24obXMpXG4gKiBAcGFyYW0gIHtvYmplY3R9ICAgW29wdGlvbnMudGltaW5nRnVuY3Rpb25dXG4gKiBAcGFyYW0gIHtvYmplY3R9ICAgW29wdGlvbnMuZGVsYXk9MChtcyldXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uICR0cmFuc2l0aW9uKGlkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCBlbCA9IHRoaXMuJGVsKGlkKVxuICBpZiAoZWwgJiYgb3B0aW9ucyAmJiBvcHRpb25zLnN0eWxlcykge1xuICAgIGNvbnN0IGFuaW1hdGlvbiA9IHRoaXMuX2FwcC5yZXF1aXJlTW9kdWxlKCdhbmltYXRpb24nKVxuICAgIGFuaW1hdGlvbi50cmFuc2l0aW9uKGVsLnJlZiwgb3B0aW9ucywgKC4uLmFyZ3MpID0+IHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsLCBvcHRpb25zLnN0eWxlcylcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKC4uLmFyZ3MpXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIGdldCBzb21lIGNvbmZpZ1xuICogQHJldHVybiB7b2JqZWN0fSBzb21lIGNvbmZpZyBmb3IgYXBwIGluc3RhbmNlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYnVuZGxlVXJsXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGRlYnVnXG4gKiBAcHJvcGVydHkge29iamVjdH0gZW52XG4gKiBAcHJvcGVydHkge3N0cmluZ30gZW52LndlZXhWZXJzaW9uKGV4LiAxLjAuMClcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBlbnYuYXBwTmFtZShleC4gVEIvVE0pXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZW52LmFwcFZlcnNpb24oZXguIDUuMC4wKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGVudi5wbGF0Zm9ybShleC4gaU9TL0FuZHJvaWQpXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZW52Lm9zVmVyc2lvbihleC4gNy4wLjApXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZW52LmRldmljZU1vZGVsICoqbmF0aXZlIG9ubHkqKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGVudi5bZGV2aWNlV2lkdGg9NzUwXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGVudi5kZXZpY2VIZWlnaHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uICRnZXRDb25maWcoY2FsbGJhY2spIHtcbiAgY29uc3QgY29uZmlnID0gZXh0ZW5kKHtcbiAgICBlbnY6IGdsb2JhbC5XWEVudmlyb25tZW50IHx8IHt9XG4gIH0sIHRoaXMuX2FwcC5vcHRpb25zKVxuICBpZiAodHlwb2YoY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbmF0aXZlTG9nKCdbV0FSTklOR10gdGhlIGNhbGxiYWNrIG9mIFZtIyRnZXRDb25maWcoY2FsbGJhY2spIGlzIGRlcHJlY2F0ZWQsICcgK1xuICAgICAgJ3RoaXMgYXBpIG5vdyBjYW4gZGlyZWN0bHkgUkVUVVJOIGNvbmZpZyBpbmZvLicpXG4gICAgY2FsbGJhY2soY29uZmlnKVxuICB9XG4gIHJldHVybiBjb25maWdcbn1cblxuLyoqXG4gKiByZXF1ZXN0IG5ldHdvcmsgdmlhIGh0dHAgcHJvdG9jb2xcbiAqIEBwYXJhbSAge29iamVjdH0gICBwYXJhbXNcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gJHNlbmRIdHRwKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgY29uc3Qgc3RyZWFtID0gdGhpcy5fYXBwLnJlcXVpcmVNb2R1bGUoJ3N0cmVhbScpXG4gIHN0cmVhbS5zZW5kSHR0cChwYXJhbXMsIGNhbGxiYWNrKVxufVxuXG4vKipcbiAqIG9wZW4gYSB1cmxcbiAqIEBwYXJhbSAge3N0cmluZ30gdXJsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiAkb3BlblVSTCh1cmwpIHtcbiAgY29uc3QgZXZlbnQgPSB0aGlzLl9hcHAucmVxdWlyZU1vZHVsZSgnZXZlbnQnKVxuICBldmVudC5vcGVuVVJMKHVybClcbn1cblxuLyoqXG4gKiBzZXQgYSB0aXRsZSBmb3IgcGFnZVxuICogQHBhcmFtICB7c3RyaW5nfSB0aXRsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gJHNldFRpdGxlKHRpdGxlKSB7XG4gIGNvbnN0IHBhZ2VJbmZvID0gdGhpcy5fYXBwLnJlcXVpcmVNb2R1bGUoJ3BhZ2VJbmZvJylcbiAgcGFnZUluZm8uc2V0VGl0bGUodGl0bGUpXG59XG5cbi8qKlxuICogaW52b2tlIGEgbmF0aXZlIG1ldGhvZCBieSBzcGVjaWZpbmcgdGhlIG5hbWUgb2YgbW9kdWxlIGFuZCBtZXRob2RcbiAqIEBwYXJhbSAge3N0cmluZ30gbW9kdWxlTmFtZVxuICogQHBhcmFtICB7c3RyaW5nfSBtZXRob2ROYW1lXG4gKiBAcGFyYW0gIHsuLi4qfSB0aGUgcmVzdCBhcmd1bWVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uICRjYWxsKG1vZHVsZU5hbWUsIG1ldGhvZE5hbWUsIC4uLmFyZ3MpIHtcbiAgY29uc3QgbW9kdWxlID0gdGhpcy5fYXBwLnJlcXVpcmVNb2R1bGUobW9kdWxlTmFtZSlcbiAgaWYgKG1vZHVsZSAmJiBtb2R1bGVbbWV0aG9kTmFtZV0pIHtcbiAgICBtb2R1bGVbbWV0aG9kTmFtZV0oLi4uYXJncylcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9saWIvYXBpL21ldGhvZHMuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict'
	
	__webpack_require__(3)
	
	// require('./polyfill')
	__webpack_require__(7)
	__webpack_require__(12)
	
	var config = __webpack_require__(13)
	var Loader = __webpack_require__(14)
	var utils = __webpack_require__(15)
	var protocol = __webpack_require__(16)
	var ComponentManager = __webpack_require__(17)
	var Component = __webpack_require__(24)
	var Sender = __webpack_require__(28)
	var receiver = __webpack_require__(29)
	
	// Components and apis.
	var components = __webpack_require__(30)
	var api = __webpack_require__(90)
	__webpack_require__(124)
	__webpack_require__(102)
	
	var WEAPP_STYLE_ID = 'weapp-style'
	
	var DEFAULT_DESIGN_WIDTH = 750
	var DEFAULT_SCALE = window.innerWidth / DEFAULT_DESIGN_WIDTH
	var DEFAULT_ROOT_ID = 'weex'
	var DEFAULT_JSONP_CALLBACK_NAME = 'weexJsonpCallback'
	
	window.WXEnvironment = {
	  weexVersion: config.weexVersion,
	  appName: lib.env.aliapp ? lib.env.aliapp.appname : null,
	  appVersion: lib.env.aliapp ? lib.env.aliapp.version.val : null,
	  platform: 'Web',
	  osName: lib.env.browser ? lib.env.browser.name : null,
	  osVersion: lib.env.browser ? lib.env.browser.version.val : null,
	  deviceWidth: DEFAULT_DESIGN_WIDTH,
	  deviceHeight: window.innerHeight / DEFAULT_SCALE
	}
	
	var _instanceMap = {}
	var _downgrades = {}
	
	var downgradable = ['list', 'scroller']
	
	; (function initializeWithUrlParams() {
	
	  var params = lib.httpurl(location.href).params
	  for (var k in params) {
	    // Get global _downgrades from url's params.
	    var match = k.match(/downgrade_(\w+)/)
	    if (!match || !match[1]) {
	      continue
	    }
	    if (params[k] !== true && params[k] !== 'true') {
	      continue
	    }
	    var downk = match[1]
	    if (downk && (downgradable.indexOf(downk) !== -1)) {
	      _downgrades[downk] = true
	    }
	  }
	
	  // set global 'debug' config to true if there's a debug flag in current url.
	  var debug = params['debug']
	  if (debug === true || debug === 'true') {
	    config.debug = true
	  }
	
	})()
	
	__webpack_require__(32).init()
	
	function Weex(options) {
	
	  if (!(this instanceof Weex)) {
	    return new Weex(options)
	  }
	
	  // Width of the root container. Default is window.innerWidth.
	  this.width = options.width || window.innerWidth
	  this.bundleUrl = options.bundleUrl || location.href
	  this.instanceId = options.appId
	  this.rootId = options.rootId || (DEFAULT_ROOT_ID + utils.getRandom(10))
	  this.designWidth = options.designWidth || DEFAULT_DESIGN_WIDTH
	  this.jsonpCallback = options.jsonpCallback || DEFAULT_JSONP_CALLBACK_NAME
	  this.source = options.source
	  this.loader = options.loader
	  this.embed = options.embed ? true : false
	
	  this.data = options.data
	
	  this.initDowngrades(options.downgrade)
	  this.initScale()
	  this.initComponentManager()
	  this.initBridge()
	  Weex.addInstance(this)
	
	  protocol.injectWeexInstance(this)
	
	  this.loadBundle(function (err, appCode) {
	    if (!err) {
	      this.createApp(config, appCode)
	    } else {
	      console.error('load bundle err:', err)
	    }
	  }.bind(this))
	
	}
	
	Weex.init = function (options) {
	  if (utils.isArray(options)) {
	    options.forEach(function (config) {
	      new Weex(config)
	    })
	  } else if (
	      Object.prototype.toString.call(options).slice(8, -1) === 'Object'
	    ) {
	    new Weex(options)
	  }
	}
	
	Weex.addInstance = function (instance) {
	  _instanceMap[instance.instanceId] = instance
	}
	
	Weex.getInstance = function (instanceId) {
	  return _instanceMap[instanceId]
	}
	
	Weex.prototype = {
	
	  initDowngrades: function (dg) {
	    this.downgrades = utils.extend({}, _downgrades)
	    // Get downgrade component type from user's specification
	    // in weex's init options.
	    if (!utils.isArray(dg)) {
	      return
	    }
	    for (var i = 0, l = dg.length; i < l; i++) {
	      var downk = dg[i]
	      if (downgradable.indexOf(downk) !== -1) {
	        this.downgrades[downk] = true
	      }
	    }
	  },
	
	  initBridge: function () {
	    receiver.init(this)
	    this.sender = new Sender(this)
	  },
	
	  loadBundle: function (cb) {
	    Loader.load({
	      jsonpCallback: this.jsonpCallback,
	      source: this.source,
	      loader: this.loader
	    }, cb)
	  },
	
	  createApp: function (config, appCode) {
	    var root = document.querySelector('#' + this.rootId)
	    if (!root) {
	      root = document.createElement('div')
	      root.id = this.rootId
	      document.body.appendChild(root)
	    }
	
	    var promise = window.createInstance(
	      this.instanceId
	      , appCode
	      , {
	        bundleUrl: this.bundleUrl,
	        debug: config.debug
	      }
	      , this.data
	    )
	
	    if (Promise && promise instanceof Promise) {
	      promise.then(function () {
	        // Weex._instances[this.instanceId] = this.root
	      }.bind(this)).catch(function (err) {
	        if (err && config.debug) {
	          console.error(err)
	        }
	      })
	    }
	
	    // Do not destroy instance here, because in most browser
	    // press back button to back to this page will not refresh
	    // the window and the instance will not be recreated then.
	    // window.addEventListener('beforeunload', function (e) {
	    // })
	
	  },
	
	  initScale: function () {
	    this.scale = this.width / this.designWidth
	  },
	
	  initComponentManager: function () {
	    this._componentManager = new ComponentManager(this)
	  },
	
	  getComponentManager: function () {
	    return this._componentManager
	  },
	
	  getRoot: function () {
	    return document.querySelector('#' + this.rootId)
	  }
	}
	
	Weex.appendStyle = function (css) {
	  utils.appendStyle(css, WEAPP_STYLE_ID)
	},
	
	// Register a new component with the specified name.
	Weex.registerComponent = function (name, comp) {
	  ComponentManager.registerComponent(name, comp)
	},
	
	// Register a new api module.
	// If the module already exists, just add methods from the
	// new module to the old one.
	Weex.registerApiModule = function (name, module, meta) {
	  if (!protocol.apiModule[name]) {
	    protocol.apiModule[name] = module
	  } else {
	    for (var key in module) {
	      if (module.hasOwnProperty(key)) {
	        protocol.apiModule[name][key] = module[key]
	      }
	    }
	  }
	  // register API module's meta info to jsframework
	  if (meta) {
	    protocol.setApiModuleMeta(meta)
	    window.registerModules(protocol.getApiModuleMeta(name), true)
	  }
	},
	
	// Register a new api method for the specified module.
	// opts:
	//  - args: type of arguments the API method takes such
	//    as ['string', 'function']
	Weex.registerApi = function (moduleName, name, method, args) {
	  if (typeof method !== 'function') {
	    return
	  }
	  if (!protocol.apiModule[moduleName]) {
	    protocol.apiModule[moduleName] = {}
	    protocol._meta[moduleName] = []
	  }
	  protocol.apiModule[moduleName][name] = method
	  if (!args) {
	    return
	  }
	  // register API meta info to jsframework
	  protocol.setApiMeta(moduleName, {
	    name: name,
	    args: args
	  })
	  window.registerModules(protocol.getApiModuleMeta(moduleName, meta), true)
	},
	
	// Register a new weex-bundle-loader.
	Weex.registerLoader = function (name, loaderFunc) {
	  Loader.registerLoader(name, loaderFunc)
	}
	
	// To install components and plugins.
	Weex.install = function (mod) {
	  mod.init(Weex)
	}
	
	Weex.stopTheWorld = function () {
	  for (var instanceId in _instanceMap) {
	    if (_instanceMap.hasOwnProperty(instanceId)) {
	      window.destroyInstance(instanceId)
	    }
	  }
	}
	
	(function startRefreshController() {
	  if (location.search.indexOf('hot-reload_controller') === -1)  {
	    return
	  }
	  if (!window.WebSocket) {
	    console.info('auto refresh need WebSocket support')
	    return
	  }
	  var host = location.hostname
	  var port = 8082
	  var client = new WebSocket('ws://' + host + ':' + port + '/',
	    'echo-protocol'
	  )
	  client.onerror = function () {
	    console.log('refresh controller websocket connection error')
	  }
	  client.onmessage = function (e) {
	    console.log('Received: \'' + e.data + '\'')
	    if (e.data  === 'refresh') {
	      location.reload()
	    }
	  }
	}())
	
	// Weex.install(require('weex-components'))
	Weex.install(components)
	Weex.install(api)
	
	Weex.Component = Component
	Weex.ComponentManager = ComponentManager
	Weex.utils = utils
	Weex.config = config
	
	global.weex = Weex
	module.exports = Weex
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(4);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./base.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./base.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, "* {\n  margin: 0;\n  padding: 0;\n  text-size-adjust: none;\n}\n\nul, ol {\n  list-style: none;\n}\n", ""]);
	
	// exports


/***/ },
/* 5 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, module) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
	 * @version   3.2.1
	 */
	
	(function() {
	    "use strict";
	    function lib$es6$promise$utils$$objectOrFunction(x) {
	      return typeof x === 'function' || (typeof x === 'object' && x !== null);
	    }
	
	    function lib$es6$promise$utils$$isFunction(x) {
	      return typeof x === 'function';
	    }
	
	    function lib$es6$promise$utils$$isMaybeThenable(x) {
	      return typeof x === 'object' && x !== null;
	    }
	
	    var lib$es6$promise$utils$$_isArray;
	    if (!Array.isArray) {
	      lib$es6$promise$utils$$_isArray = function (x) {
	        return Object.prototype.toString.call(x) === '[object Array]';
	      };
	    } else {
	      lib$es6$promise$utils$$_isArray = Array.isArray;
	    }
	
	    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
	    var lib$es6$promise$asap$$len = 0;
	    var lib$es6$promise$asap$$vertxNext;
	    var lib$es6$promise$asap$$customSchedulerFn;
	
	    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
	      lib$es6$promise$asap$$len += 2;
	      if (lib$es6$promise$asap$$len === 2) {
	        // If len is 2, that means that we need to schedule an async flush.
	        // If additional callbacks are queued before the queue is flushed, they
	        // will be processed by this flush that we are scheduling.
	        if (lib$es6$promise$asap$$customSchedulerFn) {
	          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
	        } else {
	          lib$es6$promise$asap$$scheduleFlush();
	        }
	      }
	    }
	
	    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
	      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
	    }
	
	    function lib$es6$promise$asap$$setAsap(asapFn) {
	      lib$es6$promise$asap$$asap = asapFn;
	    }
	
	    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
	    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
	    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
	    var lib$es6$promise$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
	
	    // test for web worker but not in IE10
	    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
	      typeof importScripts !== 'undefined' &&
	      typeof MessageChannel !== 'undefined';
	
	    // node
	    function lib$es6$promise$asap$$useNextTick() {
	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	      // see https://github.com/cujojs/when/issues/410 for details
	      return function() {
	        process.nextTick(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    // vertx
	    function lib$es6$promise$asap$$useVertxTimer() {
	      return function() {
	        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    function lib$es6$promise$asap$$useMutationObserver() {
	      var iterations = 0;
	      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
	      var node = document.createTextNode('');
	      observer.observe(node, { characterData: true });
	
	      return function() {
	        node.data = (iterations = ++iterations % 2);
	      };
	    }
	
	    // web worker
	    function lib$es6$promise$asap$$useMessageChannel() {
	      var channel = new MessageChannel();
	      channel.port1.onmessage = lib$es6$promise$asap$$flush;
	      return function () {
	        channel.port2.postMessage(0);
	      };
	    }
	
	    function lib$es6$promise$asap$$useSetTimeout() {
	      return function() {
	        setTimeout(lib$es6$promise$asap$$flush, 1);
	      };
	    }
	
	    var lib$es6$promise$asap$$queue = new Array(1000);
	    function lib$es6$promise$asap$$flush() {
	      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
	        var callback = lib$es6$promise$asap$$queue[i];
	        var arg = lib$es6$promise$asap$$queue[i+1];
	
	        callback(arg);
	
	        lib$es6$promise$asap$$queue[i] = undefined;
	        lib$es6$promise$asap$$queue[i+1] = undefined;
	      }
	
	      lib$es6$promise$asap$$len = 0;
	    }
	
	    function lib$es6$promise$asap$$attemptVertx() {
	      try {
	        var r = require;
	        var vertx = __webpack_require__(10);
	        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
	        return lib$es6$promise$asap$$useVertxTimer();
	      } catch(e) {
	        return lib$es6$promise$asap$$useSetTimeout();
	      }
	    }
	
	    var lib$es6$promise$asap$$scheduleFlush;
	    // Decide what async method to use to triggering processing of queued callbacks:
	    if (lib$es6$promise$asap$$isNode) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
	    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
	    } else if (lib$es6$promise$asap$$isWorker) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
	    } else if (lib$es6$promise$asap$$browserWindow === undefined && "function" === 'function') {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
	    } else {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
	    }
	    function lib$es6$promise$then$$then(onFulfillment, onRejection) {
	      var parent = this;
	
	      var child = new this.constructor(lib$es6$promise$$internal$$noop);
	
	      if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {
	        lib$es6$promise$$internal$$makePromise(child);
	      }
	
	      var state = parent._state;
	
	      if (state) {
	        var callback = arguments[state - 1];
	        lib$es6$promise$asap$$asap(function(){
	          lib$es6$promise$$internal$$invokeCallback(state, child, callback, parent._result);
	        });
	      } else {
	        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
	      }
	
	      return child;
	    }
	    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;
	    function lib$es6$promise$promise$resolve$$resolve(object) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (object && typeof object === 'object' && object.constructor === Constructor) {
	        return object;
	      }
	
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$resolve(promise, object);
	      return promise;
	    }
	    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
	    var lib$es6$promise$$internal$$PROMISE_ID = Math.random().toString(36).substring(16);
	
	    function lib$es6$promise$$internal$$noop() {}
	
	    var lib$es6$promise$$internal$$PENDING   = void 0;
	    var lib$es6$promise$$internal$$FULFILLED = 1;
	    var lib$es6$promise$$internal$$REJECTED  = 2;
	
	    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$selfFulfillment() {
	      return new TypeError("You cannot resolve a promise with itself");
	    }
	
	    function lib$es6$promise$$internal$$cannotReturnOwn() {
	      return new TypeError('A promises callback cannot return that same promise.');
	    }
	
	    function lib$es6$promise$$internal$$getThen(promise) {
	      try {
	        return promise.then;
	      } catch(error) {
	        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
	        return lib$es6$promise$$internal$$GET_THEN_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	      try {
	        then.call(value, fulfillmentHandler, rejectionHandler);
	      } catch(e) {
	        return e;
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
	       lib$es6$promise$asap$$asap(function(promise) {
	        var sealed = false;
	        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
	          if (sealed) { return; }
	          sealed = true;
	          if (thenable !== value) {
	            lib$es6$promise$$internal$$resolve(promise, value);
	          } else {
	            lib$es6$promise$$internal$$fulfill(promise, value);
	          }
	        }, function(reason) {
	          if (sealed) { return; }
	          sealed = true;
	
	          lib$es6$promise$$internal$$reject(promise, reason);
	        }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	        if (!sealed && error) {
	          sealed = true;
	          lib$es6$promise$$internal$$reject(promise, error);
	        }
	      }, promise);
	    }
	
	    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
	      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
	      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, thenable._result);
	      } else {
	        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {
	      if (maybeThenable.constructor === promise.constructor &&
	          then === lib$es6$promise$then$$default &&
	          constructor.resolve === lib$es6$promise$promise$resolve$$default) {
	        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
	      } else {
	        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
	        } else if (then === undefined) {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        } else if (lib$es6$promise$utils$$isFunction(then)) {
	          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
	        } else {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        }
	      }
	    }
	
	    function lib$es6$promise$$internal$$resolve(promise, value) {
	      if (promise === value) {
	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
	      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
	        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));
	      } else {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publishRejection(promise) {
	      if (promise._onerror) {
	        promise._onerror(promise._result);
	      }
	
	      lib$es6$promise$$internal$$publish(promise);
	    }
	
	    function lib$es6$promise$$internal$$fulfill(promise, value) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	
	      promise._result = value;
	      promise._state = lib$es6$promise$$internal$$FULFILLED;
	
	      if (promise._subscribers.length !== 0) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
	      }
	    }
	
	    function lib$es6$promise$$internal$$reject(promise, reason) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	      promise._state = lib$es6$promise$$internal$$REJECTED;
	      promise._result = reason;
	
	      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
	    }
	
	    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
	      var subscribers = parent._subscribers;
	      var length = subscribers.length;
	
	      parent._onerror = null;
	
	      subscribers[length] = child;
	      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
	      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;
	
	      if (length === 0 && parent._state) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publish(promise) {
	      var subscribers = promise._subscribers;
	      var settled = promise._state;
	
	      if (subscribers.length === 0) { return; }
	
	      var child, callback, detail = promise._result;
	
	      for (var i = 0; i < subscribers.length; i += 3) {
	        child = subscribers[i];
	        callback = subscribers[i + settled];
	
	        if (child) {
	          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
	        } else {
	          callback(detail);
	        }
	      }
	
	      promise._subscribers.length = 0;
	    }
	
	    function lib$es6$promise$$internal$$ErrorObject() {
	      this.error = null;
	    }
	
	    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
	      try {
	        return callback(detail);
	      } catch(e) {
	        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
	        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
	      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
	          value, error, succeeded, failed;
	
	      if (hasCallback) {
	        value = lib$es6$promise$$internal$$tryCatch(callback, detail);
	
	        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
	          failed = true;
	          error = value.error;
	          value = null;
	        } else {
	          succeeded = true;
	        }
	
	        if (promise === value) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
	          return;
	        }
	
	      } else {
	        value = detail;
	        succeeded = true;
	      }
	
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
	        // noop
	      } else if (hasCallback && succeeded) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      } else if (failed) {
	        lib$es6$promise$$internal$$reject(promise, error);
	      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
	      try {
	        resolver(function resolvePromise(value){
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function rejectPromise(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      } catch(e) {
	        lib$es6$promise$$internal$$reject(promise, e);
	      }
	    }
	
	    var lib$es6$promise$$internal$$id = 0;
	    function lib$es6$promise$$internal$$nextId() {
	      return lib$es6$promise$$internal$$id++;
	    }
	
	    function lib$es6$promise$$internal$$makePromise(promise) {
	      promise[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$id++;
	      promise._state = undefined;
	      promise._result = undefined;
	      promise._subscribers = [];
	    }
	
	    function lib$es6$promise$promise$all$$all(entries) {
	      return new lib$es6$promise$enumerator$$default(this, entries).promise;
	    }
	    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
	    function lib$es6$promise$promise$race$$race(entries) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (!lib$es6$promise$utils$$isArray(entries)) {
	        return new Constructor(function(resolve, reject) {
	          reject(new TypeError('You must pass an array to race.'));
	        });
	      } else {
	        return new Constructor(function(resolve, reject) {
	          var length = entries.length;
	          for (var i = 0; i < length; i++) {
	            Constructor.resolve(entries[i]).then(resolve, reject);
	          }
	        });
	      }
	    }
	    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
	    function lib$es6$promise$promise$reject$$reject(reason) {
	      /*jshint validthis:true */
	      var Constructor = this;
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$reject(promise, reason);
	      return promise;
	    }
	    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;
	
	
	    function lib$es6$promise$promise$$needsResolver() {
	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	    }
	
	    function lib$es6$promise$promise$$needsNew() {
	      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	    }
	
	    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
	    /**
	      Promise objects represent the eventual result of an asynchronous operation. The
	      primary way of interacting with a promise is through its `then` method, which
	      registers callbacks to receive either a promise's eventual value or the reason
	      why the promise cannot be fulfilled.
	
	      Terminology
	      -----------
	
	      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	      - `thenable` is an object or function that defines a `then` method.
	      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	      - `exception` is a value that is thrown using the throw statement.
	      - `reason` is a value that indicates why a promise was rejected.
	      - `settled` the final resting state of a promise, fulfilled or rejected.
	
	      A promise can be in one of three states: pending, fulfilled, or rejected.
	
	      Promises that are fulfilled have a fulfillment value and are in the fulfilled
	      state.  Promises that are rejected have a rejection reason and are in the
	      rejected state.  A fulfillment value is never a thenable.
	
	      Promises can also be said to *resolve* a value.  If this value is also a
	      promise, then the original promise's settled state will match the value's
	      settled state.  So a promise that *resolves* a promise that rejects will
	      itself reject, and a promise that *resolves* a promise that fulfills will
	      itself fulfill.
	
	
	      Basic Usage:
	      ------------
	
	      ```js
	      var promise = new Promise(function(resolve, reject) {
	        // on success
	        resolve(value);
	
	        // on failure
	        reject(reason);
	      });
	
	      promise.then(function(value) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Advanced Usage:
	      ---------------
	
	      Promises shine when abstracting away asynchronous interactions such as
	      `XMLHttpRequest`s.
	
	      ```js
	      function getJSON(url) {
	        return new Promise(function(resolve, reject){
	          var xhr = new XMLHttpRequest();
	
	          xhr.open('GET', url);
	          xhr.onreadystatechange = handler;
	          xhr.responseType = 'json';
	          xhr.setRequestHeader('Accept', 'application/json');
	          xhr.send();
	
	          function handler() {
	            if (this.readyState === this.DONE) {
	              if (this.status === 200) {
	                resolve(this.response);
	              } else {
	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	              }
	            }
	          };
	        });
	      }
	
	      getJSON('/posts.json').then(function(json) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Unlike callbacks, promises are great composable primitives.
	
	      ```js
	      Promise.all([
	        getJSON('/posts'),
	        getJSON('/comments')
	      ]).then(function(values){
	        values[0] // => postsJSON
	        values[1] // => commentsJSON
	
	        return values;
	      });
	      ```
	
	      @class Promise
	      @param {function} resolver
	      Useful for tooling.
	      @constructor
	    */
	    function lib$es6$promise$promise$$Promise(resolver) {
	      this[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$nextId();
	      this._result = this._state = undefined;
	      this._subscribers = [];
	
	      if (lib$es6$promise$$internal$$noop !== resolver) {
	        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();
	        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();
	      }
	    }
	
	    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
	    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
	    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
	    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
	    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
	    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
	    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;
	
	    lib$es6$promise$promise$$Promise.prototype = {
	      constructor: lib$es6$promise$promise$$Promise,
	
	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	
	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	
	      Chaining
	      --------
	
	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	
	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	
	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	
	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	
	      Assimilation
	      ------------
	
	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	
	      If the assimliated promise rejects, then the downstream promise will also reject.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	
	      Simple Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var result;
	
	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	
	      Advanced Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var author, books;
	
	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	
	      function foundBooks(books) {
	
	      }
	
	      function failure(reason) {
	
	      }
	
	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	      then: lib$es6$promise$then$$default,
	
	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	
	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }
	
	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }
	
	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	      'catch': function(onRejection) {
	        return this.then(null, onRejection);
	      }
	    };
	    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
	    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
	      this._instanceConstructor = Constructor;
	      this.promise = new Constructor(lib$es6$promise$$internal$$noop);
	
	      if (!this.promise[lib$es6$promise$$internal$$PROMISE_ID]) {
	        lib$es6$promise$$internal$$makePromise(this.promise);
	      }
	
	      if (lib$es6$promise$utils$$isArray(input)) {
	        this._input     = input;
	        this.length     = input.length;
	        this._remaining = input.length;
	
	        this._result = new Array(this.length);
	
	        if (this.length === 0) {
	          lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	        } else {
	          this.length = this.length || 0;
	          this._enumerate();
	          if (this._remaining === 0) {
	            lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	          }
	        }
	      } else {
	        lib$es6$promise$$internal$$reject(this.promise, lib$es6$promise$enumerator$$validationError());
	      }
	    }
	
	    function lib$es6$promise$enumerator$$validationError() {
	      return new Error('Array Methods must be provided an Array');
	    }
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
	      var length  = this.length;
	      var input   = this._input;
	
	      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        this._eachEntry(input[i], i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
	      var c = this._instanceConstructor;
	      var resolve = c.resolve;
	
	      if (resolve === lib$es6$promise$promise$resolve$$default) {
	        var then = lib$es6$promise$$internal$$getThen(entry);
	
	        if (then === lib$es6$promise$then$$default &&
	            entry._state !== lib$es6$promise$$internal$$PENDING) {
	          this._settledAt(entry._state, i, entry._result);
	        } else if (typeof then !== 'function') {
	          this._remaining--;
	          this._result[i] = entry;
	        } else if (c === lib$es6$promise$promise$$default) {
	          var promise = new c(lib$es6$promise$$internal$$noop);
	          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);
	          this._willSettleAt(promise, i);
	        } else {
	          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);
	        }
	      } else {
	        this._willSettleAt(resolve(entry), i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
	      var promise = this.promise;
	
	      if (promise._state === lib$es6$promise$$internal$$PENDING) {
	        this._remaining--;
	
	        if (state === lib$es6$promise$$internal$$REJECTED) {
	          lib$es6$promise$$internal$$reject(promise, value);
	        } else {
	          this._result[i] = value;
	        }
	      }
	
	      if (this._remaining === 0) {
	        lib$es6$promise$$internal$$fulfill(promise, this._result);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
	      var enumerator = this;
	
	      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
	        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
	      }, function(reason) {
	        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
	      });
	    };
	    function lib$es6$promise$polyfill$$polyfill() {
	      var local;
	
	      if (typeof global !== 'undefined') {
	          local = global;
	      } else if (typeof self !== 'undefined') {
	          local = self;
	      } else {
	          try {
	              local = Function('return this')();
	          } catch (e) {
	              throw new Error('polyfill failed because global object is unavailable in this environment');
	          }
	      }
	
	      var P = local.Promise;
	
	      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
	        return;
	      }
	
	      local.Promise = lib$es6$promise$promise$$default;
	    }
	    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;
	
	    var lib$es6$promise$umd$$ES6Promise = {
	      'Promise': lib$es6$promise$promise$$default,
	      'polyfill': lib$es6$promise$polyfill$$default
	    };
	
	    /* global define:true module:true window: true */
	    if ("function" === 'function' && __webpack_require__(11)['amd']) {
	      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined' && module['exports']) {
	      module['exports'] = lib$es6$promise$umd$$ES6Promise;
	    } else if (typeof this !== 'undefined') {
	      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
	    }
	
	    lib$es6$promise$polyfill$$default();
	}).call(this);
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8), (function() { return this; }()), __webpack_require__(9)(module)))

/***/ },
/* 8 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 10 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 12 */
/***/ function(module, exports) {

	; (function(win, lib) {
	  var doc = win.document
	  var docEl = doc.documentElement
	  var metaEl = doc.querySelector('meta[name="viewport"]')
	  var flexibleEl = doc.querySelector('meta[name="flexible"]')
	  var dpr = 0
	  var scale = 0
	  var tid
	  var flexible = lib.flexible || (lib.flexible = {})
	  
	  if (metaEl) {
	    console.warn('meta')
	    var match = metaEl.getAttribute('content')
	      .match(/initial\-scale=([\d\.]+)/)
	    if (match) {
	      scale = parseFloat(match[1])
	      dpr = parseInt(1 / scale)
	    }
	  } else if (flexibleEl) {
	    var content = flexibleEl.getAttribute('content')
	    if (content) {
	      var initialDpr = content.match(/initial\-dpr=([\d\.]+)/)
	      var maximumDpr = content.match(/maximum\-dpr=([\d\.]+)/)
	      if (initialDpr) {
	        dpr = parseFloat(initialDpr[1])
	        scale = parseFloat((1 / dpr).toFixed(2))    
	      }
	      if (maximumDpr) {
	        dpr = parseFloat(maximumDpr[1])
	        scale = parseFloat((1 / dpr).toFixed(2))    
	      }
	    }
	  }
	
	  if (!dpr && !scale) {
	    var isAndroid = win.navigator.appVersion.match(/android/gi)
	    var isIPhone = win.navigator.appVersion.match(/iphone/gi)
	    var devicePixelRatio = win.devicePixelRatio
	    if (isIPhone) {
	      // iOS2321
	      if (devicePixelRatio >= 3 && (!dpr || dpr >= 3)) {                
	        dpr = 3
	      } else if (devicePixelRatio >= 2 && (!dpr || dpr >= 2)){
	        dpr = 2
	      } else {
	        dpr = 1
	      }
	    } else {
	      // 1
	      dpr = 1
	    }
	    scale = 1 / dpr
	  }
	
	  docEl.setAttribute('data-dpr', dpr)
	  if (!metaEl) {
	    metaEl = doc.createElement('meta')
	    metaEl.setAttribute('name', 'viewport')
	    metaEl.setAttribute(
	      'content',
	      'initial-scale='
	        + scale + ', maximum-scale='
	        + scale + ', minimum-scale='
	        + scale + ', user-scalable=no'
	      )
	    if (docEl.firstElementChild) {
	      docEl.firstElementChild.appendChild(metaEl)
	    } else {
	      var wrap = doc.createElement('div')
	      wrap.appendChild(metaEl)
	      doc.write(wrap.innerHTML)
	    }
	  }
	
	  function refreshRem(){
	    var width = docEl.getBoundingClientRect().width
	    if (width / dpr > 540) {
	      width = 540 * dpr
	    }
	    var rem = width / 10
	    docEl.style.fontSize = rem + 'px'
	    flexible.rem = win.rem = rem
	  }
	
	  win.addEventListener('resize', function() {
	    clearTimeout(tid)
	    tid = setTimeout(refreshRem, 300)
	  }, false)
	  win.addEventListener('pageshow', function(e) {
	    if (e.persisted) {
	      clearTimeout(tid)
	      tid = setTimeout(refreshRem, 300)
	    }
	  }, false)
	
	  if (doc.readyState === 'complete') {
	    doc.body.style.fontSize = 12 * dpr + 'px'
	  } else {
	    doc.addEventListener('DOMContentLoaded', function(e) {
	      doc.body.style.fontSize = 12 * dpr + 'px'
	    }, false)
	  }
	  
	  refreshRem()
	
	  flexible.dpr = win.dpr = dpr
	  flexible.refreshRem = refreshRem
	  flexible.rem2px = function(d) {
	    var val = parseFloat(d) * this.rem
	    if (typeof d === 'string' && d.match(/rem$/)) {
	      val += 'px'
	    }
	    return val
	  }
	  flexible.px2rem = function(d) {
	    var val = parseFloat(d) / this.rem
	    if (typeof d === 'string' && d.match(/px$/)) {
	      val += 'rem'
	    }
	    return val
	  }
	
	})(window, window['lib'] || (window['lib'] = {}))

/***/ },
/* 13 */
/***/ function(module, exports) {

	'use strict'
	
	var config = {
	
	  weexVersion: '0.5.0',
	
	  debug: false
	
	}
	
	module.exports = config

/***/ },
/* 14 */
/***/ function(module, exports) {

	'use strict'
	
	function loadByXHR(config, callback) {
	  if (!config.source) {
	    callback(new Error('xhr loader: missing config.source.'))
	  }
	  var xhr = new XMLHttpRequest()
	  xhr.open('GET', config.source)
	  xhr.onload = function () {
	    callback(null, this.responseText)
	  }
	  xhr.onerror = function (error) {
	    callback(error)
	  }
	  xhr.send()
	}
	
	function loadByJsonp(config, callback) {
	  if (!config.source) {
	    callback(new Error('jsonp loader: missing config.source.'))
	  }
	  var callbackName = config.jsonpCallback || 'weexJsonpCallback'
	  window[callbackName] = function (code) {
	    if (code) {
	      callback(null, code)
	    } else {
	      callback(new Error('load by jsonp error'))
	    }
	  }
	  var script = document.createElement('script')
	  script.src = decodeURIComponent(config.source)
	  script.type = 'text/javascript'
	  document.body.appendChild(script)
	}
	
	function loadBySourceCode(config, callback) {
	  // src is the jsbundle.
	  // no need to fetch from anywhere.
	  if (config.source) {
	    callback(null, config.source)
	  } else {
	    callback(new Error('source code laoder: missing config.source.'))
	  }
	}
	
	var callbackMap = {
	  xhr: loadByXHR,
	  jsonp: loadByJsonp,
	  source: loadBySourceCode
	}
	
	function load(options, callback) {
	  var loadFn = callbackMap[options.loader]
	  loadFn(options, callback)
	}
	
	function registerLoader(name, loaderFunc) {
	  if (typeof loaderFunc === 'function') {
	    callbackMap[name] = loaderFunc
	  }
	}
	
	module.exports = {
	  load: load,
	  registerLoader: registerLoader
	}


/***/ },
/* 15 */
/***/ function(module, exports) {

	'use strict'
	
	var WEAPP_STYLE_ID = 'weapp-style'
	
	var _isWebpSupported = false
	
	; (function isSupportWebp() {
	  try {
	    var webP = new Image()
	    webP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdA'
	              + 'SoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA'
	    webP.onload = function () {
	      if (webP.height === 2) {
	        _isWebpSupported = true
	      }
	    }
	  } catch (e) {
	    // do nothing.
	  }
	})()
	
	function extend(to, from) {
	  for (var key in from) {
	    to[key] = from[key]
	  }
	  return to
	}
	
	function isArray(arr) {
	  return Array.isArray
	    ? Array.isArray(arr)
	    : (Object.prototype.toString.call(arr) === '[object Array]')
	}
	
	function appendStyle(css, styleId, replace) {
	  var style = document.getElementById(styleId)
	  if (style && replace) {
	    style.parentNode.removeChild(style)
	    style = null
	  }
	  if (!style) {
	    style = document.createElement('style')
	    style.type = 'text/css'
	    styleId && (style.id = styleId)
	    document.getElementsByTagName('head')[0].appendChild(style)
	  }
	  style.appendChild(document.createTextNode(css))
	}
	
	function getUniqueFromArray(arr) {
	  if (!isArray(arr)) {
	    return []
	  }
	  var res = []
	  var unique = {}
	  var val
	  for (var i = 0, l = arr.length; i < l; i++) {
	    val = arr[i]
	    if (unique[val]) {
	      continue
	    }
	    unique[val] = true
	    res.push(val)
	  }
	  return res
	}
	
	function transitionize(element, props) {
	  var transitions = []
	  for (var key in props) {
	    transitions.push(key + ' ' + props[key])
	  }
	  element.style.transition = transitions.join(', ')
	  element.style.webkitTransition = transitions.join(', ')
	}
	
	function detectWebp() {
	  return _isWebpSupported
	}
	
	function getRandom(num) {
	  var _defaultNum = 10
	  if (typeof num !== 'number' || num <= 0) {
	    num = _defaultNum
	  }
	  var _max = Math.pow(10, num)
	  return Math.floor(Date.now() + Math.random() * _max) % _max
	}
	
	function getRgb(color) {
	  var match
	  color = color + ''
	  if (match = color.match(/#(\d{2})(\d{2})(\d{2})/)) {
	    return {
	      r: parseInt(match[1], 16),
	      g: parseInt(match[2], 16),
	      b: parseInt(match[3], 16)
	    }
	  }
	  if (match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/)) {
	    return {
	      r: parseInt(match[1]),
	      g: parseInt(match[2]),
	      b: parseInt(match[3])
	    }
	  }
	}
	
	// direction: 'l' | 'r', default is 'r'
	// num: how many times to loop, should be a positive integer
	function loopArray(arr, num, direction) {
	  if (!isArray(arr)) {
	    return
	  }
	  var isLeft = (direction + '').toLowerCase() === 'l'
	  var len = arr.length
	  num = num % len
	  if (num < 0) {
	    num = -num
	    isLeft = !isLeft
	  }
	  if (num === 0) {
	    return arr
	  }
	  var res, lp, rp
	  if (isLeft) {
	    lp = arr.slice(0, num)
	    rp = arr.slice(num)
	  } else {
	    lp = arr.slice(0, len - num)
	    rp = arr.slice(len - num)
	  }
	  return rp.concat(lp)
	}
	
	// pad a integer number with zeros on the left.
	// example: fillInt(12, 3) -> '012'
	// - num: the number to pad
	// - len: the specified length
	function leftPad(num, len) {
	  if (len <= 0) {
	    return num
	  }
	  var numLen = (num + '').length
	  if (numLen >= len) {
	    return num
	  }
	  return new Array(len - numLen + 1).join('0') + num
	}
	
	// get DateStr with specified separator like '2016-06-03'
	function getDateStr(separator) {
	  var dt = new Date()
	  var y = dt.getFullYear()
	  var m = leftPad(dt.getMonth() + 1, 2)
	  var d = leftPad(dt.getDate(), 2)
	  return [y, m, d].join(separator || '')
	}
	
	module.exports = {
	  extend: extend,
	  isArray: isArray,
	  appendStyle: appendStyle,
	  getUniqueFromArray: getUniqueFromArray,
	  transitionize: transitionize,
	  detectWebp: detectWebp,
	  getRandom: getRandom,
	  getRgb: getRgb,
	  loopArray: loopArray,
	  leftPad: leftPad,
	  getDateStr: getDateStr
	}

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var extend = __webpack_require__(15).extend
	var isArray = __webpack_require__(15).isArray
	var ComponentManager = __webpack_require__(17)
	
	// for jsframework to register modules.
	var _registerModules = function (config) {
	  if (isArray(config)) {
	    for (var i = 0, l = config.length; i < l; i++) {
	      window.registerModules(config[i])
	    }
	  } else {
	    window.registerModules(config)
	  }
	}
	
	var protocol = {
	
	  // weex instances
	  _instances: {},
	
	  // api meta info
	  _meta: {},
	
	  // Weex.registerApiModule used this to register and access apiModules.
	  apiModule: {},
	
	  injectWeexInstance: function (instance) {
	    this._instances[instance.instanceId] = instance
	  },
	
	  getWeexInstance: function (instanceId) {
	    return this._instances[instanceId]
	  },
	
	  // get the api method meta info array for the module.
	  getApiModuleMeta: function (moduleName) {
	    var metaObj = {}
	    metaObj[moduleName] = this._meta[moduleName]
	    return metaObj
	  },
	
	  // Set meta info for a api module.
	  // If there is a same named api, just replace it.
	  // opts:
	  // - metaObj: meta object like
	  // {
	  //    dom: [{
	  //      name: 'addElement',
	  //      args: ['string', 'object']
	  //    }]
	  // }
	  setApiModuleMeta: function (metaObj) {
	    var moduleName
	    for (var k in metaObj) {
	      if (metaObj.hasOwnProperty(k)) {
	        moduleName = k
	      }
	    }
	    var metaArray = this._meta[moduleName]
	    if (!metaArray) {
	      this._meta[moduleName] = metaObj[moduleName]
	    } else {
	      var nameObj = {}
	      metaObj[moduleName].forEach(function (api) {
	        nameObj[api.name] = api
	      })
	      metaArray.forEach(function (api, i) {
	        if (nameObj[api.name]) {
	          metaArray[i] = nameObj[api.name]
	          delete nameObj[api.name]
	        }
	      })
	      for (var k in metaObj) {
	        if (metaObj.hasOwnProperty(k)) {
	          metaArray.push(metaObj[k])
	        }
	      }
	    }
	    this._meta[moduleName] = metaObj[moduleName]
	  },
	
	  // Set meta info for a single api.
	  // opts:
	  //  - moduleName: api module name.
	  //  - meta: a meta object like:
	  //  {
	  //    name: 'addElement',
	  //    args: ['string', 'object']
	  //  }
	  setApiMeta: function (moduleName, meta) {
	    var metaArray = this._meta[moduleName]
	    if (!metaArray) {
	      this._meta[moduleName] = [meta]
	    } else {
	      var metaIdx = -1
	      metaArray.forEach(function (api, i) {
	        if (meta.name === name) {
	          metaIdx = i
	        }
	      })
	      if (metaIdx !== -1) {
	        metaArray[metaIdx] = meta
	      } else {
	        metaArray.push(meta)
	      }
	    }
	  }
	}
	
	_registerModules([{
	  modal: [{
	    name: 'toast',
	    args: ['object', 'function']
	  }, {
	    name: 'alert',
	    args: ['object', 'function']
	  }, {
	    name: 'confirm',
	    args: ['object', 'function']
	  }, {
	    name: 'prompt',
	    args: ['object', 'function']
	  }]
	}, {
	  animation: [{
	    name: 'transition',
	    args: ['string', 'object', 'function']
	  }]
	}])
	
	module.exports = protocol


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var config = __webpack_require__(13)
	var FrameUpdater = __webpack_require__(18)
	var AppearWatcher = __webpack_require__(19)
	var utils = __webpack_require__(15)
	var LazyLoad = __webpack_require__(20)
	var animation = __webpack_require__(23)
	
	var RENDERING_INDENT = 800
	
	var _instanceMap = {}
	var typeMap = {}
	var scrollableTypes = [
	  'scroller',
	  'hscroller',
	  'vscroller',
	  'list',
	  'hlist',
	  'vlist'
	]
	
	function ComponentManager(instance) {
	  this.instanceId = instance.instanceId
	  this.weexInstance = instance
	  this.componentMap = {}
	  _instanceMap[this.instanceId] = this
	}
	
	ComponentManager.getInstance = function (instanceId) {
	  return _instanceMap[instanceId]
	}
	
	ComponentManager.getWeexInstance = function (instanceId) {
	  return _instanceMap[instanceId].weexInstance
	}
	
	ComponentManager.registerComponent = function (type, definition) {
	  typeMap[type] = definition
	}
	
	ComponentManager.getScrollableTypes = function () {
	  return scrollableTypes
	}
	
	ComponentManager.prototype = {
	
	  // Fire a event 'renderbegin'/'renderend' on body element.
	  rendering: function () {
	    function _renderingEnd() {
	      // get weex instance root
	      window.dispatchEvent(new Event('renderend'))
	      this._renderingTimer = null
	    }
	    if (this._renderingTimer) {
	      clearTimeout(this._renderingTimer)
	      this._renderingTimer = setTimeout(
	        _renderingEnd.bind(this),
	        RENDERING_INDENT
	      )
	    } else {
	      window.dispatchEvent(new Event('renderbegin'))
	      this._renderingTimer = setTimeout(
	        _renderingEnd.bind(this),
	        RENDERING_INDENT
	      )
	    }
	  },
	
	  getElementByRef: function (ref) {
	    return this.componentMap[ref]
	  },
	
	  removeElementByRef: function (ref) {
	    var cmp
	    var self = this
	    if (!ref || !(cmp = this.componentMap[ref])) {
	      return
	    }
	    // remove from this.componentMap cursively
	    (function _removeCursively(_ref) {
	      var child = self.componentMap[_ref]
	      var listeners = child._listeners
	      var children = child.data.children
	      if (children && children.length) {
	        for (var i = 0, l = children.length; i < l; i++) {
	          _removeCursively(children[i].ref)
	        }
	      }
	      // remove events from _ref component
	      if (listeners) {
	        for (var type in listeners) {
	          child.node.removeEventListener(type, listeners[type])
	        }
	      }
	      delete child._listeners
	      delete child.node._listeners
	      // remove _ref component
	      delete self.componentMap[_ref]
	    })(ref)
	
	  },
	
	  createElement: function (data, nodeType) {
	    var ComponentType = typeMap[data.type]
	    if (!ComponentType) {
	      ComponentType = typeMap['container']
	    }
	
	    var ref = data.ref
	    var component = new ComponentType(data, nodeType)
	
	    this.componentMap[ref] = component
	    component.node.setAttribute('data-ref', ref)
	
	    return component
	  },
	
	  /**
	   * createBody: generate root component
	   * @param  {object} element
	   */
	  createBody: function (element) {
	
	    // TODO: creatbody on document.body
	    // no need to create a extra div
	    var root, body, nodeType
	    if (this.componentMap['_root']) {
	      return
	    }
	
	    nodeType = element.type
	    element.type = 'root'
	    element.rootId = this.weexInstance.rootId
	    element.ref = '_root'
	
	    var root = this.createElement(element, nodeType)
	    body = document.querySelector('#' + this.weexInstance.rootId)
	          || document.body
	    body.appendChild(root.node)
	    root._appended = true
	  },
	
	  appendChild: function (parentRef, data) {
	    var parent = this.componentMap[parentRef]
	
	    if (this.componentMap[data.ref] || !parent) {
	      return
	    }
	
	    if (parentRef === '_root' && !parent) {
	      parent = this.createElement({
	        type: 'root',
	        rootId: this.weexInstance.rootId,
	        ref: '_root'
	      })
	      parent._appended = true
	    }
	
	    var child = parent.appendChild(data)
	
	    // In some parent component the implementation of method
	    // appendChild didn't return the component at all, therefor
	    // child maybe a undefined object.
	    if (child) {
	      child.parentRef = parentRef
	    }
	
	    if (child && parent._appended) {
	      this.handleAppend(child)
	    }
	  },
	
	  appendChildren: function (ref, elements) {
	    for (var i = 0; i < elements.length; i++) {
	      this.appendChild(ref, elements[i])
	    }
	  },
	
	  removeElement: function (ref) {
	    var component = this.componentMap[ref]
	
	    // fire event for rendering dom on body elment.
	    this.rendering()
	
	    if (component && component.parentRef) {
	      var parent = this.componentMap[component.parentRef]
	      component.onRemove && component.onRemove()
	      parent.removeChild(component)
	    } else {
	      console.warn('ref: ', ref)
	    }
	  },
	
	  moveElement: function (ref, parentRef, index) {
	    var component = this.componentMap[ref]
	    var newParent = this.componentMap[parentRef]
	    var oldParentRef = component.parentRef
	    var children, before, i, l
	    if (!component || !newParent) {
	      console.warn('ref: ', ref)
	      return
	    }
	
	    // fire event for rendering.
	    this.rendering()
	
	    if (index < -1) {
	      index = -1
	      console.warn('index cannot be less than -1.')
	    }
	
	    children = newParent.data.children
	    if (children
	        && children.length
	        && index !== -1
	        && index < children.length) {
	      before = this.componentMap[newParent.data.children[index].ref]
	    }
	
	    // remove from oldParent.data.children
	    if (oldParentRef && this.componentMap[oldParentRef]) {
	      children = this.componentMap[oldParentRef].data.children
	      if (children && children.length) {
	        for (i = 0, l = children.length; i < l; i++) {
	          if (children[i].ref === ref) {
	            break
	          }
	        }
	        if (l > i) {
	          children.splice(i, 1)
	        }
	      }
	    }
	
	    newParent.insertBefore(component, before)
	
	    component.onMove && component.onMove(parentRef, index)
	
	  },
	
	  insertBefore: function (ref, data) {
	    var child, before, parent
	    before = this.componentMap[ref]
	    child = this.componentMap[data.ref]
	    before && (parent = this.componentMap[before.parentRef])
	    if (child || !parent || !before) {
	      return
	    }
	
	    child = this.createElement(data)
	    if (child) {
	      child.parentRef = before.parentRef
	      parent.insertBefore(child, before)
	    } else {
	      return
	    }
	
	    if (this.componentMap[before.parentRef]._appended) {
	      this.handleAppend(child)
	    }
	  },
	
	  /**
	   * addElement
	   * If index is larget than any child's index, the
	   * element will be appended behind.
	   * @param {string} parentRef
	   * @param {obj} element (data of the component)
	   * @param {number} index
	   */
	  addElement: function (parentRef, element, index) {
	    var parent, children, before
	
	    // fire event for rendering dom on body elment.
	    this.rendering()
	
	    parent = this.componentMap[parentRef]
	    if (!parent) {
	      return
	    }
	    children = parent.data.children
	    // -1 means append as the last.
	    if (index < -1) {
	      index = -1
	      console.warn('index cannot be less than -1.')
	    }
	    if (children && children.length
	        && children.length > index
	        && index !== -1) {
	      this.insertBefore(children[index].ref, element)
	    } else {
	      this.appendChild(parentRef, element)
	    }
	  },
	
	  clearChildren: function (ref) {
	    var component = this.componentMap[ref]
	    if (component) {
	      component.node.innerHTML = ''
	      if (component.data) {
	        component.data.children = null
	      }
	    }
	  },
	
	  addEvent: function (ref, type) {
	    var component
	    if (typeof ref === 'string' || typeof ref === 'number') {
	      component = this.componentMap[ref]
	    } else if (Object.prototype.toString.call(ref).slice(8, -1) === 'Object') {
	      component = ref
	      ref = component.data.ref
	    }
	    if (component && component.node) {
	      var sender = this.weexInstance.sender
	      var listener = sender.fireEvent.bind(sender, ref, type)
	      var listeners = component._listeners
	      component.node.addEventListener(type, listener, false, false)
	      if (!listeners) {
	        listeners = component._listeners = {}
	        component.node._listeners = {}
	      }
	      listeners[type] = listener
	      component.node._listeners[type] = listener
	    }
	  },
	
	  removeEvent: function (ref, type) {
	    var component = this.componentMap[ref]
	    var listener = component._listeners[type]
	    if (component && listener) {
	      component.node.removeEventListener(type, listener)
	      component._listeners[type] = null
	      component.node._listeners[type] = null
	    }
	  },
	
	  updateAttrs: function (ref, attr) {
	    var component = this.componentMap[ref]
	    if (component) {
	      component.updateAttrs(attr)
	      if (component.data.type === 'image' && attr.src) {
	        LazyLoad.startIfNeeded(component)
	      }
	    }
	  },
	
	  updateStyle: function (ref, style) {
	    var component = this.componentMap[ref]
	    if (component) {
	      component.updateStyle(style)
	    }
	  },
	
	  updateFullAttrs: function (ref, attr) {
	    var component = this.componentMap[ref]
	    if (component) {
	      component.clearAttr()
	      component.updateAttrs(attr)
	      if (component.data.type === 'image' && attr.src) {
	        LazyLoad.startIfNeeded(component)
	      }
	    }
	  },
	
	  updateFullStyle: function (ref, style) {
	    var component = this.componentMap[ref]
	    if (component) {
	      component.clearStyle()
	      component.updateStyle(style)
	    }
	  },
	
	  handleAppend: function (component) {
	    component._appended = true
	    component.onAppend && component.onAppend()
	
	    // invoke onAppend on children recursively
	    var children = component.data.children
	    if (children) {
	      for (var i = 0; i < children.length; i++) {
	        var child = this.componentMap[children[i].ref]
	        if (child) {
	          this.handleAppend(child)
	        }
	      }
	    }
	
	    // watch appear/disappear of the component if needed
	    AppearWatcher.watchIfNeeded(component)
	
	    // do lazyload if needed
	    LazyLoad.startIfNeeded(component)
	  },
	
	  transition: function (ref, config, callback) {
	    var component = this.componentMap[ref]
	    animation.transitionOnce(component, config, callback)
	  },
	
	  renderFinish: function () {
	    FrameUpdater.pause()
	  }
	}
	
	module.exports = ComponentManager


/***/ },
/* 18 */
/***/ function(module, exports) {

	'use strict'
	
	var raf = window.requestAnimationFrame ||
	          window.webkitRequestAnimationFrame ||
	          function (calllback) {
	            setTimeout(calllback, 16)
	          }
	
	var rafId
	var observers = []
	var paused = false
	
	var FrameUpdater = {
	  start: function () {
	    if (rafId) {
	      return
	    }
	
	    rafId = raf(function runLoop() {
	      if (!paused) {
	        for (var i = 0; i < observers.length; i++) {
	          observers[i]()
	        }
	        raf(runLoop)
	      }
	    })
	  },
	
	  isActive: function () {
	    return !paused
	  },
	
	  pause: function () {
	    paused = true
	    rafId = undefined
	  },
	
	  resume: function () {
	    paused = false
	    this.start()
	  },
	
	  addUpdateObserver: function (observeMethod) {
	    observers.push(observeMethod)
	  }
	}
	
	module.exports = FrameUpdater


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var utils = __webpack_require__(15)
	
	var componentsInScroller = []
	var componentsOutOfScroller = []
	var listened = false
	var direction = 'up'
	var scrollY = 0
	
	var AppearWatcher = {
	  watchIfNeeded: function (component) {
	    if (needWatch(component)) {
	      if (component.isInScrollable()) {
	        componentsInScroller.push(component)
	      } else {
	        componentsOutOfScroller.push(component)
	      }
	      if (!listened) {
	        listened = true
	        // var handler = throttle(onScroll, 25)
	        var handler = throttle(onScroll, 100)
	        window.addEventListener('scroll', handler, false)
	      }
	    }
	  }
	}
	
	function needWatch(component) {
	  var events = component.data.event
	  if (events
	      && (events.indexOf('appear') != -1
	        || events.indexOf('disappear') != -1)) {
	    return true
	  }
	  return false
	}
	
	function onScroll(e) {
	  // If the scroll event is dispatched from a scrollable component
	  // implemented through scrollerjs, then the appear/disappear events
	  // should be treated specially by handleScrollerScroll.
	  if (e.originalType === 'scrolling') {
	    handleScrollerScroll(e)
	  } else {
	    handleWindowScroll()
	  }
	}
	
	function handleScrollerScroll(e) {
	  var cmps = componentsInScroller
	  var len = cmps.length
	  direction = e.direction
	  for (var i = 0; i < len; i++) {
	    var component = cmps[i]
	    var appear = isComponentInScrollerAppear(component)
	    if (appear && !component._appear) {
	      component._appear = true
	      fireEvent(component, 'appear')
	    } else if (!appear && component._appear) {
	      component._appear = false
	      fireEvent(component, 'disappear')
	    }
	  }
	}
	
	function handleWindowScroll() {
	  var y = window.scrollY
	  direction = y >= scrollY ? 'up' : 'down'
	  scrollY = y
	
	  var len = componentsOutOfScroller.length
	  if (len === 0) {
	    return
	  }
	  for (var i = 0; i < len; i++) {
	    var component = componentsOutOfScroller[i]
	    var appear = isComponentInWindow(component)
	    if (appear && !component._appear) {
	      component._appear = true
	      fireEvent(component, 'appear')
	    } else if (!appear && component._appear) {
	      component._appear = false
	      fireEvent(component, 'disappear')
	    }
	  }
	}
	
	function isComponentInScrollerAppear(component) {
	  var parentScroller = component._parentScroller
	  var cmpRect = component.node.getBoundingClientRect()
	  if (!isComponentInWindow(component)) {
	    return false
	  }
	  while (parentScroller) {
	    var parentRect = parentScroller.node.getBoundingClientRect()
	    if (!(cmpRect.right > parentRect.left
	        && cmpRect.left < parentRect.right
	        && cmpRect.bottom > parentRect.top
	        && cmpRect.top < parentRect.bottom)) {
	      return false
	    }
	    parentScroller = parentScroller._parentScroller
	  }
	  return true
	}
	
	function isComponentInWindow(component) {
	  var rect = component.node.getBoundingClientRect()
	  return rect.right > 0 && rect.left < window.innerWidth &&
	         rect.bottom > 0 && rect.top < window.innerHeight
	}
	
	function fireEvent(component, type) {
	  var evt = document.createEvent('HTMLEvents')
	  var data = { direction: direction }
	  evt.initEvent(type, false, false)
	  evt.data = data
	  utils.extend(evt, data)
	  component.node.dispatchEvent(evt)
	}
	
	function throttle(func, wait) {
	  var context, args, result
	  var timeout = null
	  var previous = 0
	  var later = function () {
	    previous = Date.now()
	    timeout = null
	    result = func.apply(context, args)
	  }
	  return function () {
	    var now = Date.now()
	    var remaining = wait - (now - previous)
	    context = this
	    args = arguments
	    if (remaining <= 0) {
	      clearTimeout(timeout)
	      timeout = null
	      previous = now
	      result = func.apply(context, args)
	    } else if (!timeout) {
	      timeout = setTimeout(later, remaining)
	    }
	    return result
	  }
	}
	
	module.exports = AppearWatcher

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	__webpack_require__(21)
	
	var lazyloadTimer
	
	var LazyLoad = {
	  makeImageLazy: function (image, src) {
	    image.removeAttribute('img-src')
	    image.removeAttribute('i-lazy-src')
	    image.removeAttribute('src')
	    image.setAttribute('img-src', src)
	    // should replace 'src' with 'img-src'. but for now lib.img.fire is
	    // not working for the situation that the appear event has been
	    // already triggered.
	    // image.setAttribute('src', src)
	    // image.setAttribute('img-src', src)
	    this.fire()
	  },
	
	  // we don't know when all image are appended
	  // just use setTimeout to do delay lazyload
	  //
	  // -- actually everytime we add a element or update styles,
	  // the component manager will call startIfNeed to fire
	  // lazyload once again in the handleAppend function. so there
	  // is no way that any image element can miss it. See source
	  // code in componentMangager.js.
	  startIfNeeded: function (component) {
	    var that = this
	    if (component.data.type === 'image') {
	      if (!lazyloadTimer) {
	        lazyloadTimer = setTimeout(function () {
	          that.fire()
	          clearTimeout(lazyloadTimer)
	          lazyloadTimer = null
	        }, 16)
	      }
	    }
	  },
	
	  loadIfNeeded: function (elementScope) {
	    var notPreProcessed = elementScope.querySelectorAll('[img-src]')
	    var that = this
	    // image elements which have attribute 'i-lazy-src' were elements
	    // that had been preprocessed by lib-img-core, but not loaded yet, and
	    // must be loaded when 'appear' events were fired. It turns out the
	    // 'appear' event was not fired correctly in the css-translate-transition
	    // situation, so 'i-lazy-src' must be checked and lazyload must be
	    // fired manually.
	    var preProcessed = elementScope.querySelectorAll('[i-lazy-src]')
	    if (notPreProcessed.length > 0 || preProcessed.length > 0) {
	      that.fire()
	    }
	  },
	
	  // fire lazyload.
	  fire: function () {
	    lib.img.fire()
	  }
	
	}
	
	module.exports = LazyLoad


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	"undefined"==typeof window&&(window={ctrl:{},lib:{}}),!window.ctrl&&(window.ctrl={}),!window.lib&&(window.lib={}),function(t,i){function e(t,i){i&&("IMG"==t.nodeName.toUpperCase()?t.setAttribute("src",i):t.style.backgroundImage='url("'+i+'")')}function a(){r=i.appear.init({cls:"imgtmp",once:!0,x:o.lazyWidth,y:o.lazyHeight,onAppear:function(t){var i=this;e(i,i.getAttribute("i-lazy-src")),i.removeAttribute("i-lazy-src")}})}__webpack_require__(22);var r,A={},o={dataSrc:"img-src",lazyHeight:0,lazyWidth:0};A.logConfig=function(){console.log("lib-img Config\n",o)},A.fire=function(){r||a();var t="i_"+Date.now()%1e5,i=document.querySelectorAll("["+o.dataSrc+"]");[].forEach.call(i,function(i){"false"==i.dataset.lazy&&"true"!=i.dataset.lazy?e(i,processSrc(i,i.getAttribute(o.dataSrc))):(i.classList.add(t),i.setAttribute("i-lazy-src",i.getAttribute(o.dataSrc))),i.removeAttribute(o.dataSrc)}),r.bind("."+t),r.fire()},A.defaultSrc="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",i.img=A,module.exports=A}(window,window.lib||(window.lib={}));

/***/ },
/* 22 */
/***/ function(module, exports) {

	"undefined"==typeof window&&(window={ctrl:{},lib:{}}),!window.ctrl&&(window.ctrl={}),!window.lib&&(window.lib={}),function(n,e){function i(){d=w.createEvent("HTMLEvents"),v=w.createEvent("HTMLEvents"),d.initEvent("_appear",!1,!0),v.initEvent("_disappear",!1,!0)}function a(t,n){var e,i,a,s=(Date.now(),0),o=null,r=function(){s=Date.now(),o=null,t.apply(e,i)};return function(){var l=Date.now();e=this,i=arguments;var c=n-(l-s);return 0>=c||c>=n?(clearTimeout(o),o=null,a=t.apply(e,i)):null==o&&(o=setTimeout(r,c)),a}}function s(n,e){var n,i,a,s;if(n)return e||(e={x:0,y:0}),n!=window?(n=n.getBoundingClientRect(),i=n.left,t=n.top,a=n.right,s=n.bottom):(i=0,t=0,a=i+n.innerWidth,s=t+n.innerHeight),{left:i,top:t,right:a+e.x,bottom:s+e.y}}function o(t,n){var e=n.right>t.left&&n.left<t.right,i=n.bottom>t.top&&n.top<t.bottom;return e&&i}function r(t,n){var e="none",i=t.left-n.left,a=t.top-n.top;return 0==a&&(e=0!=i?i>0?"left":"right":"none"),0==i&&(e=0!=a?a>0?"up":"down":"none"),e}function l(t,n){for(var e in n)n.hasOwnProperty(e)&&(t[e]=n[e]);return t}function c(){var t=this,n=a(function(){f.apply(t,arguments)},this.options.wait);this.__handle&&(this.container.removeEventListener("scroll",this.__handle),this.__handle=null),this.__handle=n,this.container.addEventListener("scroll",n,!1),this.container.addEventListener("resize",function(n){f.apply(t,arguments)},!1),this.container.addEventListener("animationEnd",function(){f.apply(t,arguments)},!1),this.container.addEventListener("webkitAnimationEnd",function(){f.apply(t,arguments)},!1),this.container.addEventListener("transitionend",function(){f.apply(t,arguments)},!1)}function p(t){var n=this,e=this.options.container;if("string"==typeof e?this.container=w.querySelector(e):this.container=e,this.container==window)var i=w.querySelectorAll(t);else var i=this.container.querySelectorAll(t);var i=[].slice.call(i,null);return i=i.filter(function(t){return"1"==t.dataset.bind?(delete t._hasAppear,delete t._hasDisAppear,delete t._appear,t.classList.remove(n.options.cls),!1):!0})}function h(t){var n=this;t&&t.length>0&&[].forEach.call(t,function(t){t._eleOffset=s(t),t.classList.remove(n.options.cls),t.dataset.bind=1})}function f(){var t=this.container,n=this.appearWatchElements,e=this.options.onAppear,i=this.options.onDisappear,a=s(t,{x:this.options.x,y:this.options.y}),l=this.options.once,c=arguments[0]||{};n&&n.length>0&&[].forEach.call(n,function(t,n){var p=s(t),h=r(t._eleOffset,p);t._eleOffset=p;var f=o(a,p),u=t._appear,w=t._hasAppear,E=t._hasDisAppear;d.data={direction:h},v.data={direction:h},f&&!u?(l&&!w||!l)&&(e&&e.call(t,c),t.dispatchEvent(d),t._hasAppear=!0,t._appear=!0):!f&&u&&(l&&!E||!l)&&(i&&i.call(t,c),t.dispatchEvent(v),t._hasDisAppear=!0,t._appear=!1)})}function u(t){l(this.options,t||(t={})),this.appearWatchElements=this.appearWatchElements||p.call(this,"."+this.options.cls),h.call(this,this.appearWatchElements),c.call(this)}var d,v,w=document,E=function(){u.apply(this,arguments)},_={instances:[],init:function(t){var n={options:{container:window,wait:100,x:0,y:0,cls:"lib-appear",once:!1,onReset:function(){},onAppear:function(){},onDisappear:function(){}},container:null,appearWatchElements:null,bind:function(t){var n=this.options.cls;if("string"==typeof t){var e=p.call(this,t);[].forEach.call(e,function(t,e){t.classList.contains(n)||t.classList.add(n)})}else{if(1!=t.nodeType||!this.container.contains(t))return this;t.classList.contains(n)||t.classList.add(n)}var i=p.call(this,"."+this.options.cls);return this.appearWatchElements=this.appearWatchElements.concat(i),h.call(this,i),this},reset:function(t){return u.call(this,t),this.appearWatchElements.forEach(function(t){delete t._hasAppear,delete t._hasDisAppear,delete t._appear}),this},fire:function(){this.appearWatchElements||(this.appearWatchElements=[]);var t=p.call(this,"."+this.options.cls);return this.appearWatchElements=this.appearWatchElements.concat(t),h.call(this,t),f.call(this),this}};E.prototype=n;var e=new E(t);return this.instances.push(e),e},fireAll:function(){var t=this.instances;t.forEach(function(t){t.fire()})}};i(),e.appear=_}(window,window.lib||(window.lib={}));

/***/ },
/* 23 */
/***/ function(module, exports) {

	'use strict'
	
	module.exports = {
	
	  /**
	   * config:
	   *   - styles
	   *   - duration [Number] milliseconds(ms)
	   *   - timingFunction [string]
	   *   - dealy [Number] milliseconds(ms)
	   */
	  transitionOnce: function (comp, config, callback) {
	    var styles = config.styles || {}
	    var duration = config.duration || 1000 // ms
	    var timingFunction = config.timingFunction || 'ease'
	    var delay = config.delay || 0  // ms
	    var transitionValue = 'all ' + duration + 'ms '
	        + timingFunction + ' ' + delay + 'ms'
	    var dom = comp.node
	    var transitionEndHandler = function (e) {
	      e.stopPropagation()
	      dom.removeEventListener('webkitTransitionEnd', transitionEndHandler)
	      dom.removeEventListener('transitionend', transitionEndHandler)
	      dom.style.transition = ''
	      dom.style.webkitTransition = ''
	      callback()
	    }
	    dom.style.transition = transitionValue
	    dom.style.webkitTransition = transitionValue
	    dom.addEventListener('webkitTransitionEnd', transitionEndHandler)
	    dom.addEventListener('transitionend', transitionEndHandler)
	    comp.updateStyle(styles)
	  }
	
	}

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var config = __webpack_require__(13)
	var utils = __webpack_require__(15)
	var ComponentManager = __webpack_require__(17)
	var flexbox = __webpack_require__(25)
	var valueFilter = __webpack_require__(26)
	__webpack_require__(27)
	
	function Component(data, nodeType) {
	  this.data = data
	  this.node = this.create(nodeType)
	
	  this.createChildren()
	  this.updateAttrs(this.data.attr)
	  // issue: when add element to a list in lifetime hook 'ready', the
	  // styles is set to the classStyle, not style. This is a issue
	  // that jsframework should do something about.
	  var classStyle = this.data.classStyle
	  classStyle && this.updateStyle(this.data.classStyle)
	  this.updateStyle(this.data.style)
	  this.bindEvents(this.data.event)
	}
	
	Component.prototype = {
	
	  create: function (nodeType) {
	    var node = document.createElement(nodeType || 'div')
	    return node
	  },
	
	  getComponentManager: function () {
	    return ComponentManager.getInstance(this.data.instanceId)
	  },
	
	  getParent: function () {
	    return this.getComponentManager().componentMap[this.parentRef]
	  },
	
	  getParentScroller: function () {
	    if (this.isInScrollable()) {
	      return this._parentScroller
	    }
	    return null
	  },
	
	  getRootScroller: function () {
	    if (this.isInScrollable()) {
	      var scroller = this._parentScroller
	      var parent = scroller._parentScroller
	      while (parent) {
	        scroller = parent
	        parent = scroller._parentScroller
	      }
	      return scroller
	    }
	    return null
	  },
	
	  getRootContainer: function () {
	    var root = this.getComponentManager().weexInstance.getRoot()
	      || document.body
	    return root
	  },
	
	  isScrollable: function () {
	    var t = this.data.type
	    return ComponentManager.getScrollableTypes().indexOf(t) !== -1
	  },
	
	  isInScrollable: function () {
	    if (typeof this._isInScrollable === 'boolean') {
	      return this._isInScrollable
	    }
	    var parent = this.getParent()
	    if (parent
	        && (typeof parent._isInScrollable !== 'boolean')
	        && !parent.isScrollable()) {
	      if (parent.data.ref === '_root') {
	        this._isInScrollable = false
	        return false
	      }
	      this._isInScrollable = parent.isInScrollable()
	      this._parentScroller = parent._parentScroller
	      return this._isInScrollable
	    }
	    if (parent && typeof parent._isInScrollable === 'boolean') {
	      this._isInScrollable = parent._isInScrollable
	      this._parentScroller = parent._parentScroller
	      return this._isInScrollable
	    }
	    if (parent && parent.isScrollable()) {
	      this._isInScrollable = true
	      this._parentScroller = parent
	      return true
	    }
	    if (!parent) {
	      console && console.error('isInScrollable - parent not exist.')
	      return
	    }
	  },
	
	  createChildren: function () {
	    var children = this.data.children
	    var parentRef = this.data.ref
	    var componentManager = this.getComponentManager()
	    if (children && children.length) {
	      var fragment = document.createDocumentFragment()
	      var isFlex = false
	      for (var i = 0; i < children.length; i++) {
	        children[i].instanceId = this.data.instanceId
	        children[i].scale = this.data.scale
	        var child = componentManager.createElement(children[i])
	        fragment.appendChild(child.node)
	        child.parentRef = parentRef
	        if (!isFlex
	            && child.data.style
	            && child.data.style.hasOwnProperty('flex')
	          ) {
	          isFlex = true
	        }
	      }
	      this.node.appendChild(fragment)
	    }
	  },
	
	  // @todo: changed param data to child
	  appendChild: function (data) {
	    var children = this.data.children
	    var componentManager = this.getComponentManager()
	    var child = componentManager.createElement(data)
	    this.node.appendChild(child.node)
	    // update this.data.children
	    if (!children || !children.length) {
	      this.data.children = [data]
	    } else {
	      children.push(data)
	    }
	
	    return child
	  },
	
	  insertBefore: function (child, before) {
	    var children = this.data.children
	    var i = 0
	    var l
	    var isAppend = false
	
	    // update this.data.children
	    if (!children || !children.length || !before) {
	      isAppend = true
	    } else {
	      for (l = children.length; i < l; i++) {
	        if (children[i].ref === before.data.ref) {
	          break
	        }
	      }
	      if (i === l) {
	        isAppend = true
	      }
	    }
	
	    if (isAppend) {
	      this.node.appendChild(child.node)
	      children.push(child.data)
	    } else {
	      if (before.fixedPlaceholder) {
	        this.node.insertBefore(child.node, before.fixedPlaceholder)
	      } else {
	        this.node.insertBefore(child.node, before.node)
	      }
	      children.splice(i, 0, child.data)
	    }
	
	  },
	
	  removeChild: function (child) {
	    var children = this.data.children
	    // remove from this.data.children
	    var i = 0
	    var componentManager = this.getComponentManager()
	    if (children && children.length) {
	      for (var l = children.length; i < l; i++) {
	        if (children[i].ref === child.data.ref) {
	          break
	        }
	      }
	      if (i < l) {
	        children.splice(i, 1)
	      }
	    }
	    // remove from componentMap recursively
	    componentManager.removeElementByRef(child.data.ref)
	    if (child.fixedPlaceholder) {
	      this.node.removeChild(child.fixedPlaceholder)
	    }
	    child.node.parentNode.removeChild(child.node)
	  },
	
	  updateAttrs: function (attrs) {
	    // Noteattr must be injected into the dom element because
	    // it will be accessed from the outside developer by event.target.attr.
	    if (!this.node.attr) {
	      this.node.attr = {}
	    }
	    for (var key in attrs) {
	      var value = attrs[key]
	      var attrSetter = this.attr[key]
	      if (typeof attrSetter === 'function') {
	        attrSetter.call(this, value)
	      } else {
	        if (typeof value === 'boolean') {
	          this.node[key] = value
	        } else {
	          this.node.setAttribute(key, value)
	        }
	        this.node.attr[key] = value
	      }
	    }
	  },
	
	  updateStyle: function (style) {
	
	    for (var key in style) {
	      var value = style[key]
	      var styleSetter = this.style[key]
	      if (typeof styleSetter === 'function') {
	        styleSetter.call(this, value)
	        continue
	      }
	      var parser = valueFilter.getFilters(key,
	          { scale: this.data.scale })[typeof value]
	      if (typeof parser === 'function') {
	        value = parser(value)
	      }
	      this.node.style[key] = value
	    }
	  },
	
	  bindEvents: function (evts) {
	    var componentManager = this.getComponentManager()
	    if (evts
	        && Object.prototype.toString.call(evts).slice(8, -1) === 'Array'
	      ) {
	      for (var i = 0, l = evts.length; i < l; i++) {
	        componentManager.addEvent(this, evts[i])
	      }
	    }
	  },
	
	  // dispatch a specified event on this.node
	  //  - type: event type
	  //  - data: event data
	  //  - config: event config object
	  //     - bubbles
	  //     - cancelable
	  dispatchEvent: function (type, data, config) {
	    var event = document.createEvent('HTMLEvents')
	    config = config || {}
	    event.initEvent(type, config.bubbles || false, config.cancelable || false)
	    !data && (data = {})
	    event.data = utils.extend({}, data)
	    utils.extend(event, data)
	    this.node.dispatchEvent(event)
	  },
	
	  updateRecursiveAttr: function (data) {
	    this.updateAttrs(data.attr)
	    var componentManager = this.getComponentManager()
	    var children = this.data.children
	    if (children) {
	      for (var i = 0; i < children.length; i++) {
	        var child = componentManager.getElementByRef(children[i].ref)
	        if (child) {
	          child.updateRecursiveAttr(data.children[i])
	        }
	      }
	    }
	  },
	
	  updateRecursiveStyle: function (data) {
	    this.updateStyle(data.style)
	    var componentManager = this.getComponentManager()
	    var children = this.data.children
	    if (children) {
	      for (var i = 0; i < children.length; i++) {
	        var child = componentManager.getElementByRef(children[i].ref)
	        if (child) {
	          child.updateRecursiveStyle(data.children[i])
	        }
	      }
	    }
	  },
	
	  updateRecursiveAll: function (data) {
	    this.updateAttrs(data.attr)
	    this.updateStyle(data.style)
	    var componentManager = this.getComponentManager()
	
	    // var oldRef = this.data.ref
	    // if (componentMap[oldRef]) {
	    //   delete componentMap[oldRef]
	    // }
	    // this.data.ref = data.ref
	    // componentMap[data.ref] = this
	
	    var children = this.data.children
	    if (children) {
	      for (var i = 0; i < children.length; i++) {
	        var child = componentManager.getElementByRef(children[i].ref)
	        if (child) {
	          child.updateRecursiveAll(data.children[i])
	        }
	      }
	    }
	  },
	
	  attr: {}, // attr setters
	
	  style: Object.create(flexbox), // style setters
	
	  clearAttr: function () {
	  },
	
	  clearStyle: function () {
	    this.node.cssText = ''
	  }
	}
	
	Component.prototype.style.position = function (value) {
	
	  // For the elements who are fixed elements before, now
	  // are not fixed: the fixedPlaceholder has to be replaced
	  // by this element.
	  // This is a peace of hacking to fix the problem about
	  // mixing fixed and transform. See 'http://stackoverflo
	  // w.com/questions/15194313/webkit-css-transform3d-posi
	  // tion-fixed-issue' for more info.
	  if (value !== 'fixed') {
	    if (this.fixedPlaceholder) {
	      var parent = this.fixedPlaceholder.parentNode
	      parent.insertBefore(this.node, this.fixedPlaceholder)
	      parent.removeChild(this.fixedPlaceholder)
	      this.fixedPlaceholder = null
	    }
	  } else { // value === 'fixed'
	    // For the elements who are fixed: this fixedPlaceholder
	    // shoud be inserted, and the fixed element itself should
	    // be placed out in root container.
	    this.node.style.position = 'fixed'
	    var parent = this.node.parentNode
	    var replaceWithFixedPlaceholder = function () {
	      this.fixedPlaceholder = document.createElement('div')
	      this.fixedPlaceholder.classList.add('weex-fixed-placeholder')
	      this.fixedPlaceholder.style.display = 'none'
	      this.fixedPlaceholder.style.width = '0px'
	      this.fixedPlaceholder.style.height = '0px'
	      parent.insertBefore(this.fixedPlaceholder, this.node)
	      this.getRootContainer().appendChild(this.node)
	    }.bind(this)
	    if (!parent) {
	      if (this.onAppend) {
	        var pre = this.onAppend.bind(this)
	      }
	      this.onAppend = function () {
	        parent = this.node.parentNode
	        replaceWithFixedPlaceholder()
	        pre && pre()
	      }.bind(this)
	    } else {
	      replaceWithFixedPlaceholder()
	    }
	    return
	  }
	
	  if (value === 'sticky') {
	    this.node.style.zIndex = 100
	    setTimeout(function () {
	      this.sticky = new lib.sticky(this.node, {
	        top: 0
	      })
	    }.bind(this), 0)
	  } else {
	    this.node.style.position = value
	  }
	}
	
	module.exports = Component
	
	
	


/***/ },
/* 25 */
/***/ function(module, exports) {

	'use strict'
	
	// Flexbox polyfill
	var flexboxSetters = (function () {
	  var BOX_ALIGN = {
	    stretch: 'stretch',
	    'flex-start': 'start',
	    'flex-end': 'end',
	    center: 'center'
	  }
	  var BOX_ORIENT = {
	    row: 'horizontal',
	    column: 'vertical'
	  }
	  var BOX_PACK = {
	    'flex-start': 'start',
	    'flex-end': 'end',
	    center: 'center',
	    'space-between': 'justify',
	    'space-around': 'justify' // Just same as `space-between`
	  }
	  return {
	    flex: function (value) {
	      this.node.style.webkitBoxFlex = value
	      this.node.style.webkitFlex = value
	      this.node.style.flex = value
	    },
	    alignItems: function (value) {
	      this.node.style.webkitBoxAlign = BOX_ALIGN[value]
	      this.node.style.webkitAlignItems = value
	      this.node.style.alignItems = value
	    },
	    alignSelf: function (value) {
	      this.node.style.webkitAlignSelf = value
	      this.node.style.alignSelf = value
	    },
	    flexDirection: function (value) {
	      this.node.style.webkitBoxOrient = BOX_ORIENT[value]
	      this.node.style.webkitFlexDirection = value
	      this.node.style.flexDirection = value
	    },
	    justifyContent: function (value) {
	      this.node.style.webkitBoxPack = BOX_PACK[value]
	      this.node.style.webkitJustifyContent = value
	      this.node.style.justifyContent = value
	    }
	  }
	})()
	
	module.exports = flexboxSetters


/***/ },
/* 26 */
/***/ function(module, exports) {

	'use strict'
	
	var NOT_PX_NUMBER_PROPERTIES = ['flex', 'opacity', 'zIndex', 'fontWeight']
	
	var valueFilter = {
	
	  filterStyles: function (styles, config) {
	    for (var key in styles) {
	      var value = styles[key]
	      var parser = this.getFilters(key, config)[typeof value]
	      if (typeof parser === 'function') {
	        styles[key] = parser(value)
	      }
	    }
	  },
	
	  getFilters: function (key, config) {
	
	    if (NOT_PX_NUMBER_PROPERTIES.indexOf(key) !== -1) {
	      return {}
	    }
	    return {
	      number: function (val) {
	        return val * config.scale + 'px'
	      },
	      string: function (val) {
	        // string of a pure number or a number suffixed with a 'px' unit
	        if (val.match(/^\-?\d*\.?\d+(?:px)?$/)) {
	          return parseFloat(val) * config.scale + 'px'
	        }
	        if (key.match(/transform/) && val.match(/translate/)) {
	          return val.replace(/\d*\.?\d+px/g, function (match) {
	            return parseInt(parseFloat(match) * config.scale) + 'px'
	          })
	        }
	        return val
	      }
	    }
	  }
	}
	
	module.exports = valueFilter


/***/ },
/* 27 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b,c){function d(a){return null!=a&&"object"==typeof a&&Object.getPrototypeOf(a)==Object.prototype}function e(a,b){var c,d,e,f=null,g=0,h=function(){g=Date.now(),f=null,e=a.apply(c,d)};return function(){var i=Date.now(),j=b-(i-g);return c=this,d=arguments,0>=j?(clearTimeout(f),f=null,g=i,e=a.apply(c,d)):f||(f=setTimeout(h,j)),e}}function f(a){var b="";return Object.keys(a).forEach(function(c){b+=c+":"+a[c]+";"}),b}function g(a,c){!c&&d(a)&&(c=a,a=c.element),c=c||{},a.nodeType!=b.ELEMENT_NODE&&"string"==typeof a&&(a=b.querySelector(a));var e=this;e.element=a,e.top=c.top||0,e.withinParent=void 0==c.withinParent?!1:c.withinParent,e.init()}var h=a.parseInt,i=navigator.userAgent,j=!!i.match(/Firefox/i),k=!!i.match(/IEMobile/i),l=j?"-moz-":k?"-ms-":"-webkit-",m=j?"Moz":k?"ms":"webkit",n=function(){var a=b.createElement("div"),c=a.style;return c.cssText="position:"+l+"sticky;position:sticky;",-1!=c.position.indexOf("sticky")}();g.prototype={constructor:g,init:function(){var a=this,b=a.element,c=b.style;c[m+"Transform"]="translateZ(0)",c.transform="translateZ(0)",a._originCssText=c.cssText,n?(c.position=l+"sticky",c.position="sticky",c.top=a.top+"px"):(a._simulateSticky(),a._bindResize())},_bindResize:function(){var b=this,c=/android/gi.test(navigator.appVersion),d=b._resizeEvent="onorientationchange"in a?"orientationchange":"resize",e=b._resizeHandler=function(){setTimeout(function(){b.refresh()},c?200:0)};a.addEventListener(d,e,!1)},refresh:function(){var a=this;n||(a._detach(),a._simulateSticky())},_addPlaceholder:function(a){var c,d=this,e=d.element,g=a.position;if(-1!=["static","relative"].indexOf(g)){c=d._placeholderElement=b.createElement("div");var i=h(a.width)+h(a.marginLeft)+h(a.marginRight),j=h(a.height);"border-box"!=a.boxSizing&&(i+=h(a.borderLeftWidth)+h(a.borderRightWidth)+h(a.paddingLeft)+h(a.paddingRight),j+=h(a.borderTopWidth)+h(a.borderBottomWidth)+h(a.paddingTop)+h(a.paddingBottom)),c.style.cssText=f({display:"none",visibility:"hidden",width:i+"px",height:j+"px",margin:0,"margin-top":a.marginTop,"margin-bottom":a.marginBottom,border:0,padding:0,"float":a["float"]||a.cssFloat}),e.parentNode.insertBefore(c,e)}return c},_simulateSticky:function(){var c=this,d=c.element,g=c.top,i=d.style,j=d.getBoundingClientRect(),k=getComputedStyle(d,""),l=d.parentNode,m=getComputedStyle(l,""),n=c._addPlaceholder(k),o=c.withinParent,p=c._originCssText,q=j.top-g+a.pageYOffset,r=l.getBoundingClientRect().bottom-h(m.paddingBottom)-h(m.borderBottomWidth)-h(k.marginBottom)-j.height-g+a.pageYOffset,s=p+f({position:"fixed",top:g+"px",width:k.width,"margin-top":0}),t=p+f({position:"absolute",top:r+"px",width:k.width}),u=1,v=c._scrollHandler=e(function(){var b=a.pageYOffset;q>b?1!=u&&(i.cssText=p,n&&(n.style.display="none"),u=1):!o&&b>=q||o&&b>=q&&r>b?2!=u&&(i.cssText=s,n&&3!=u&&(n.style.display="block"),u=2):o&&3!=u&&(i.cssText=t,n&&2!=u&&(n.style.display="block"),u=3)},100);if(a.addEventListener("scroll",v,!1),a.pageYOffset>=q){var w=b.createEvent("HTMLEvents");w.initEvent("scroll",!0,!0),a.dispatchEvent(w)}},_detach:function(){var b=this,c=b.element;if(c.style.cssText=b._originCssText,!n){var d=b._placeholderElement;d&&c.parentNode.removeChild(d),a.removeEventListener("scroll",b._scrollHandler,!1)}},destroy:function(){var b=this;b._detach();var c=b.element.style;c.removeProperty(l+"transform"),c.removeProperty("transform"),n||a.removeEventListener(b._resizeEvent,b._resizeHandler,!1)}},c.sticky=g}(window,document,window.lib||(window.lib={}));;module.exports = window.lib['sticky'];

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var utils = __webpack_require__(15)
	
	var _senderMap = {}
	
	function Sender(instance) {
	  if (!(this instanceof Sender)) {
	    return new Sender(instance)
	  }
	  this.instanceId = instance.instanceId
	  this.weexInstance = instance
	  _senderMap[this.instanceId] = this
	}
	
	function _send(instanceId, msg) {
	  callJS(instanceId, [msg])
	}
	
	Sender.getSender = function (instanceId) {
	  return _senderMap[instanceId]
	}
	
	Sender.prototype = {
	
	  // perform a callback to jsframework.
	  performCallback: function (callbackId, data, keepAlive) {
	    var args = [callbackId]
	    data && args.push(data)
	    keepAlive && args.push(keepAlive)
	    _send(this.instanceId, {
	      method: 'callback',
	      args: args
	    })
	  },
	
	  fireEvent: function (ref, type, event) {
	    if (event._alreadyFired) {
	      // stop bubbling up in virtual dom tree.
	      return
	    }
	    // do not prevent default, otherwise the touchstart
	    // event will no longer trigger a click event
	    event._alreadyFired = true
	    var evt = utils.extend({}, event)
	    // The event.target must be the standard event's currentTarget.
	    evt.target = evt.currentTarget
	    evt.value = event.target.value
	    evt.timestamp = Date.now()
	    _send(this.instanceId, {
	      method: 'fireEvent',
	      args: [ref, type, evt]
	    })
	  }
	
	}
	
	module.exports = Sender

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict'
	
	var config = __webpack_require__(13)
	var protocol = __webpack_require__(16)
	var utils = __webpack_require__(15)
	var FrameUpdater = __webpack_require__(18)
	var Sender = __webpack_require__(28)
	
	var callQueue = []
	// Need a task counter?
	// When FrameUpdater is not activated, tasks will not be push
	// into callQueue and there will be no trace for situation of
	// execution of tasks.
	
	// give 10ms for call handling, and rest 6ms for others
	var MAX_TIME_FOR_EACH_FRAME = 10
	
	// callNative: jsFramework will call this method to talk to
	// this renderer.
	// params:
	//  - instanceId: string.
	//  - tasks: array of object.
	//  - callbackId: number.
	function callNative(instanceId, tasks, callbackId) {
	  var calls = []
	  if (typeof tasks === 'string') {
	    try {
	      calls = JSON.parse(tasks)
	    } catch (e) {
	      console.error('invalid tasks:', tasks)
	    }
	  } else if (Object.prototype.toString.call(tasks).slice(8, -1) === 'Array') {
	    calls = tasks
	  }
	  var len = calls.length
	  calls[len - 1].callbackId = (!callbackId && callbackId !== 0)
	                              ? -1
	                              : callbackId
	  // To solve the problem of callapp, the two-way time loop rule must
	  // be replaced by calling directly except the situation of page loading.
	  // 2015-11-03
	  for (var i = 0; i < len; i++) {
	    if (FrameUpdater.isActive()) {
	      callQueue.push({
	        instanceId: instanceId,
	        call: calls[i]
	      })
	    }
	    else {
	      processCall(instanceId, calls[i])
	    }
	  }
	
	}
	
	function processCallQueue() {
	  var len = callQueue.length
	  if (len === 0) {
	    return
	  }
	  var start = Date.now()
	  var elapsed = 0
	
	  while (--len >= 0 && elapsed < MAX_TIME_FOR_EACH_FRAME) {
	    var callObj = callQueue.shift()
	    processCall(callObj.instanceId, callObj.call)
	    elapsed = Date.now() - start
	  }
	}
	
	function processCall(instanceId, call) {
	  var moduleName = call.module
	  var methodName = call.method
	  var module, method
	  var args = call.args || call.arguments || []
	
	  if (!(module = protocol.apiModule[moduleName])) {
	    return
	  }
	  if (!(method = module[methodName])) {
	    return
	  }
	
	  method.apply(protocol.getWeexInstance(instanceId), args)
	
	  var callbackId = call.callbackId
	  if ((callbackId
	    || callbackId === 0
	    || callbackId === '0')
	    && callbackId !== '-1'
	    && callbackId !== -1) {
	    performNextTick(instanceId, callbackId)
	  }
	}
	
	function performNextTick(instanceId, callbackId) {
	  Sender.getSender(instanceId).performCallback(callbackId)
	}
	
	function nativeLog() {
	  if (config.debug) {
	    if (arguments[0].match(/^perf/)) {
	      console.info.apply(console, arguments)
	      return
	    }
	    console.debug.apply(console, arguments)
	  }
	}
	
	function exportsBridgeMethodsToGlobal() {
	  global.callNative = callNative
	  global.nativeLog = nativeLog
	}
	
	module.exports = {
	
	  init: function () {
	
	    // process callQueue every 16 milliseconds.
	    FrameUpdater.addUpdateObserver(processCallQueue)
	    FrameUpdater.start()
	
	    // exports methods to global(window).
	    exportsBridgeMethodsToGlobal()
	  }
	
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var RootComponent = __webpack_require__(31)
	var Container = __webpack_require__(33)
	var Image = __webpack_require__(36)
	var Text = __webpack_require__(40)
	var Vlist = __webpack_require__(41)
	var Hlist = __webpack_require__(47)
	var Countdown = __webpack_require__(48)
	var Marquee = __webpack_require__(50)
	var Slider = __webpack_require__(51)
	var Indicator = __webpack_require__(58)
	var Tabheader = __webpack_require__(61)
	var Scroller = __webpack_require__(65)
	var Input = __webpack_require__(68)
	var Select = __webpack_require__(69)
	var Datepicker = __webpack_require__(70)
	var Timepicker = __webpack_require__(71)
	var Video = __webpack_require__(72)
	var Switch = __webpack_require__(75)
	var A = __webpack_require__(78)
	var Embed = __webpack_require__(79)
	var Refresh = __webpack_require__(80)
	var Loading = __webpack_require__(83)
	var Spinner = __webpack_require__(86)
	var Web = __webpack_require__(89)
	
	var components = {
	  init: function (Weex) {
	    Weex.registerComponent('root', RootComponent)
	    Weex.registerComponent('container', Container)
	    Weex.registerComponent('div', Container)
	    Weex.registerComponent('image', Image)
	    Weex.registerComponent('text', Text)
	    Weex.registerComponent('list', Vlist)
	    Weex.registerComponent('vlist', Vlist)
	    Weex.registerComponent('hlist', Hlist)
	    Weex.registerComponent('countdown', Countdown)
	    Weex.registerComponent('marquee', Marquee)
	    Weex.registerComponent('slider', Slider)
	    Weex.registerComponent('indicator', Indicator)
	    Weex.registerComponent('tabheader', Tabheader)
	    Weex.registerComponent('scroller', Scroller)
	    Weex.registerComponent('input', Input)
	    Weex.registerComponent('select', Select)
	    Weex.registerComponent('datepicker', Datepicker)
	    Weex.registerComponent('timepicker', Timepicker)
	    Weex.registerComponent('video', Video)
	    Weex.registerComponent('switch', Switch)
	    Weex.registerComponent('a', A)
	    Weex.registerComponent('embed', Embed)
	    Weex.registerComponent('refresh', Refresh)
	    Weex.registerComponent('loading', Loading)
	    Weex.registerComponent('spinner', Spinner)
	    Weex.registerComponent('loading-indicator', Spinner)
	    Weex.registerComponent('web', Web)
	  }
	}
	
	module.exports = components


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var ComponentManager = __webpack_require__(17)
	var Component = __webpack_require__(24)
	var utils = __webpack_require__(15)
	var logger = __webpack_require__(32)
	
	var rootCandidates = ['div', 'list', 'vlist', 'scroller']
	
	function RootComponent(data, nodeType) {
	  var id = data.rootId + '-root'
	  var componentManager = ComponentManager.getInstance(data.instanceId)
	
	  // If nodeType is in the downgrades map, just ignore it and
	  // replace it with a div component.
	  var downgrades = componentManager.weexInstance.downgrades
	  this.data = data
	
	  // In some situation the root component should be implemented as
	  // its own type, otherwise it has to be a div component as a root.
	  if (!nodeType) {
	    nodeType = 'div'
	  } else if (rootCandidates.indexOf(nodeType) === -1) {
	    logger.warn('the root component type \'' + nodeType + '\' is not one of '
	      + 'the types in [' + rootCandidates + '] list. It is auto downgraded '
	      + 'to \'div\'.')
	    nodeType = 'div'
	  } else if (downgrades[nodeType]) {
	    logger.warn('Thanks to the downgrade flags for ['
	      + Object.keys(downgrades)
	      + '], the root component type \'' + nodeType
	      + '\' is auto downgraded to \'div\'.')
	    nodeType = 'div'
	  } else {
	    // If the root component is not a embed element in a webpage, then
	    // the html and body height should be fixed to the max height
	    // of viewport.
	    if (!componentManager.weexInstance.embed) {
	      window.addEventListener('renderend', function () {
	        this.detectRootHeight()
	      }.bind(this))
	    }
	    if (nodeType !== 'div') {
	      logger.warn('the root component type \'' + nodeType + '\' may have '
	        + 'some performance issue on some of the android devices when there '
	        + 'is a huge amount of dom elements. Try to add downgrade '
	        + 'flags by adding param \'downgrade_' + nodeType + '=true\' in the '
	        + 'url or setting downgrade config to a array contains \'' + nodeType
	        + '\' in the \'weex.init\' function. This will downgrade the root \''
	        + nodeType + '\' to a \'div\', and may elevate the level of '
	        + 'performance, although it has some other issues.')
	    }
	    !this.data.style.height && (this.data.style.height = '100%')
	  }
	
	  data.type = nodeType
	  var cmp = componentManager.createElement(data)
	  cmp.node.id = id
	  return cmp
	}
	
	RootComponent.prototype = Object.create(Component.prototype)
	
	RootComponent.prototype.detectRootHeight = function () {
	  var rootQuery = '#' + this.getComponentManager().weexInstance.rootId
	  var rootContainer = document.querySelector(rootQuery) || document.body
	  var height = rootContainer.getBoundingClientRect().height
	  if (height > window.innerHeight) {
	    logger.warn([
	      'for scrollable root like \'list\' and \'scroller\', the height of ',
	      'the root container must be a user-specified value. Otherwise ',
	      'the scrollable element may not be able to work correctly. ',
	      'Current height of the root element \'' + rootQuery + '\' is ',
	      height + 'px, and mostly its height should be less than the ',
	      'viewport\'s height ' + window.innerHeight + 'px. Please ',
	      'make sure the height is correct.'
	      ].join(''))
	  }
	}
	
	module.exports = RootComponent


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var config = __webpack_require__(13)
	var utils = __webpack_require__(15)
	
	var _initialized = false
	
	var logger = {
	  log: function () {},
	  warn: function () {},
	  error: function () {}
	}
	
	function hijack(k) {
	  if (utils.isArray(k)) {
	    k.forEach(function (key) {
	      hijack(key)
	    })
	  } else {
	    if (console[k]) {
	      logger[k] = function () {
	        console[k].apply(
	          console,
	          ['[h5-render]'].concat(Array.prototype.slice.call(arguments, 0))
	        )
	      }
	    }
	  }
	}
	
	logger.init = function () {
	  if (_initialized) {
	    return
	  }
	  _initialized = true
	  if (config.debug && console) {
	    hijack(['log', 'warn', 'error'])
	  }
	}
	
	module.exports = logger

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	__webpack_require__(34)
	
	var Component = __webpack_require__(24)
	
	function Container (data, nodeType) {
	  Component.call(this, data, nodeType)
	  this.node.classList.add('weex-container')
	}
	
	Container.prototype = Object.create(Component.prototype)
	
	module.exports = Container


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(35);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./container.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./container.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-container {\n  box-sizing: border-box;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-box-orient: vertical;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n  position: relative;\n  border: 0 solid black;\n  margin: 0;\n  padding: 0;\n}\n\n.weex-element {\n  box-sizing: border-box;\n  position: relative;\n}\n", ""]);
	
	// exports


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(37)
	var LazyLoad = __webpack_require__(20)
	var config = __webpack_require__(13)
	var utils = __webpack_require__(15)
	
	__webpack_require__(38)
	
	var DEFAULT_SIZE = 200
	var RESIZE_MODES = ['stretch', 'cover', 'contain']
	var DEFAULT_RESIZE_MODE = 'stretch'
	
	/**
	 * resize: 'cover' | 'contain' | 'stretch', default is 'stretch'
	 * src: url
	 */
	
	function Image (data) {
	  this.resize = DEFAULT_RESIZE_MODE
	  Atomic.call(this, data)
	}
	
	Image.prototype = Object.create(Atomic.prototype)
	
	Image.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('weex-img')
	  return node
	}
	
	Image.prototype.attr = {
	  src: function (val) {
	    if (!this.src) {
	      this.src = lib.img.defaultSrc
	      this.node.style.backgroundImage = 'url(' + this.src + ')'
	    }
	    LazyLoad.makeImageLazy(this.node, val)
	  },
	
	  resize: function (val) {
	    if (RESIZE_MODES.indexOf(val) === -1) {
	      val = 'stretch'
	    }
	    this.node.style.backgroundSize = val === 'stretch'
	                                    ? '100% 100%'
	                                    : val
	  }
	}
	
	Image.prototype.style = utils.extend(Object.create(Atomic.prototype.style), {
	  width: function (val) {
	    val = parseFloat(val) * this.data.scale
	    if (val < 0 || val !== val) {
	      val = DEFAULT_SIZE
	    }
	    this.node.style.width = val + 'px'
	  },
	
	  height: function (val) {
	    val = parseFloat(val) * this.data.scale
	    if (val < 0 || val !== val) {
	      val = DEFAULT_SIZE
	    }
	    this.node.style.height = val + 'px'
	  }
	})
	
	Image.prototype.clearAttr = function () {
	  this.src = ''
	  this.node.style.backgroundImage = ''
	}
	
	module.exports = Image


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Component = __webpack_require__(24)
	
	// Component which can have no subcomponents.
	// This component should not be instantiated directly, since
	// it is designed to be used as a base class to extend from.
	function Atomic (data) {
	  Component.call(this, data)
	}
	
	Atomic.prototype = Object.create(Component.prototype)
	
	Atomic.prototype.appendChild = function (data) {
	  // do nothing
	  return
	}
	
	Atomic.prototype.insertBefore = function (child, before) {
	  // do nothing
	  return
	}
	
	Atomic.prototype.removeChild = function (child) {
	  // do nothing
	  return
	}
	
	module.exports = Atomic


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(39);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./image.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./image.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-img {\n\tbox-sizing: border-box;\n  position: relative;\n  background-repeat: no-repeat;\n  background-size: 100% 100%;\n  background-position: 50%;\n  border: 0 solid black;\n}", ""]);
	
	// exports


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(24)
	var utils = __webpack_require__(15)
	
	var DEFAULT_FONT_SIZE = 32
	var DEFAULT_TEXT_OVERFLOW = 'ellipsis'
	
	// attr
	//  - value: text content.
	//  - lines: maximum lines of the text.
	function Text (data) {
	  Atomic.call(this, data)
	}
	
	Text.prototype = Object.create(Atomic.prototype)
	
	Text.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('weex-container')
	  node.style.fontSize = DEFAULT_FONT_SIZE * this.data.scale + 'px'
	  this.textNode = document.createElement('span')
	  // Give the developers the ability to control space
	  // and line-breakers.
	  this.textNode.style.whiteSpace = 'pre-wrap'
	  this.textNode.style.wordWrap = 'break-word'
	  this.textNode.style.display = '-webkit-box'
	  this.textNode.style.webkitBoxOrient = 'vertical'
	  this.style.lines.call(this, this.data.style.lines)
	  node.appendChild(this.textNode)
	  return node
	}
	
	Text.prototype.attr = {
	  value: function (value) {
	    var span = this.node.firstChild
	    span.innerHTML = ''
	    if (value == null || value === '') {
	      return
	    }
	    span.textContent = value
	    /**
	     * Developers are supposed to have the ability to break text
	     * lines manually. Using ``&nbsp;`` to replace text space is
	     * not compatible with the ``-webkit-line-clamp``. Therefor
	     * we use ``white-space: no-wrap`` instead (instead of the
	     * code bellow).
	
	      var frag = document.createDocumentFragment()
	        text.split(' ').forEach(function(str) {
	          var textNode = document.createTextNode(str)
	          var space = document.createElement('i')
	          space.innerHTML = '&nbsp;'
	          frag.appendChild(space)
	          frag.appendChild(textNode)
	        })
	        frag.removeChild(frag.firstChild)
	        span.appendChild(document.createElement('br'))
	        span.appendChild(frag)
	      })
	      span.removeChild(span.firstChild)
	     */
	  }
	}
	
	Text.prototype.clearAttr = function () {
	  this.node.firstChild.textContent = ''
	}
	
	Text.prototype.style = utils.extend(Object.create(Atomic.prototype.style), {
	
	  lines: function (val) {
	    val = parseInt(val)
	    if (val !== val) { // NaN
	      return
	    }
	    if (val <= 0) {
	      this.textNode.style.textOverflow = ''
	      this.textNode.style.overflow = 'visible'
	      this.textNode.style.webkitLineClamp = ''
	    } else {
	      var style = this.data ? this.data.style : null
	      this.textNode.style.overflow = 'hidden'
	      this.textNode.style.textOverflow = style
	        ? style.textOverflow
	        : DEFAULT_TEXT_OVERFLOW
	      this.textNode.style.webkitLineClamp = val
	    }
	  },
	
	  textOverflow: function (val) {
	    this.textNode.style.textOverflow = val
	  }
	
	})
	
	module.exports = Text


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var List = __webpack_require__(42)
	
	function Vlist(data, nodeType) {
	  data.attr.direction = 'v'
	  List.call(this, data, nodeType)
	}
	
	Vlist.prototype = Object.create(List.prototype)
	
	module.exports = Vlist

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	__webpack_require__(43)
	__webpack_require__(45)
	
	var Component = __webpack_require__(24)
	var LazyLoad = __webpack_require__(20)
	
	var DEFAULT_LOAD_MORE_OFFSET = 500
	
	var directionMap = {
	  h: ['row', 'horizontal', 'h', 'x'],
	  v: ['column', 'vertical', 'v', 'y']
	}
	
	// direction: 'v' or 'h', default is 'v'
	function List(data, nodeType) {
	  // this.loadmoreOffset = Number(data.attr.loadmoreoffset)
	  // this.isAvailableToFireloadmore = true
	  this.direction = directionMap.h.indexOf(data.attr.direction) === -1
	    ? 'v'
	    : 'h'
	  Component.call(this, data, nodeType)
	}
	
	List.prototype = Object.create(Component.prototype)
	
	List.prototype.create = function (nodeType) {
	  var Scroll = lib.scroll
	  var node = Component.prototype.create.call(this, nodeType)
	  node.classList.add('weex-container', 'list-wrap')
	  this.listElement = document.createElement('div')
	  this.listElement.classList.add(
	    'weex-container'
	    , 'list-element'
	    , this.direction + '-list'
	  )
	
	  // Flex will cause a bug to rescale children's size if their total
	  // size exceed the limit of their parent. So to use box instead.
	  this.listElement.style.display = '-webkit-box'
	  this.listElement.style.display = 'box'
	  this.listElement.style.webkitBoxOrient = this.direction === 'h'
	    ? 'horizontal'
	    : 'vertical'
	  this.listElement.style.boxOrient = this.listElement.style.webkitBoxOrient
	
	  node.appendChild(this.listElement)
	  this.scroller = new Scroll({
	    scrollElement: this.listElement
	    , direction: this.direction === 'h' ? 'x' : 'y'
	  })
	  this.scroller.init()
	  this.offset = 0
	  return node
	}
	
	List.prototype.bindEvents = function (evts) {
	  Component.prototype.bindEvents.call(this, evts)
	  // to enable lazyload for Images.
	  this.scroller.addEventListener('scrolling', function (e) {
	    var so = e.scrollObj
	    var scrollTop = so.getScrollTop()
	    var scrollLeft = so.getScrollLeft()
	    var offset = this.direction === 'v' ? scrollTop : scrollLeft
	    var diff = offset - this.offset
	    var dir
	    if (diff >= 0) {
	      dir = this.direction === 'v' ? 'up' : 'left'
	    } else {
	      dir = this.direction === 'v' ? 'down' : 'right'
	    }
	    this.dispatchEvent('scroll', {
	      originalType: 'scrolling',
	      scrollTop: so.getScrollTop(),
	      scrollLeft: so.getScrollLeft(),
	      offset: offset,
	      direction: dir
	    }, {
	      bubbles: true
	    })
	    this.offset = offset
	  }.bind(this))
	
	  var pullendEvent = 'pull' + ({ v: 'up', h: 'left' })[this.direction] + 'end'
	  this.scroller.addEventListener(pullendEvent, function (e) {
	    this.dispatchEvent('loadmore')
	  }.bind(this))
	}
	
	List.prototype.createChildren = function () {
	  var children = this.data.children
	  var parentRef = this.data.ref
	  var componentManager = this.getComponentManager()
	  if (children && children.length) {
	    var fragment = document.createDocumentFragment()
	    var isFlex = false
	    for (var i = 0; i < children.length; i++) {
	      children[i].instanceId = this.data.instanceId
	      children[i].scale = this.data.scale
	      var child = componentManager.createElement(children[i])
	      fragment.appendChild(child.node)
	      child.parentRef = parentRef
	      if (!isFlex
	          && child.data.style
	          && child.data.style.hasOwnProperty('flex')
	        ) {
	        isFlex = true
	      }
	    }
	    this.listElement.appendChild(fragment)
	  }
	  // wait for fragment to appended on listElement on UI thread.
	  setTimeout(function () {
	    this.scroller.refresh()
	  }.bind(this), 0)
	}
	
	List.prototype.appendChild = function (data) {
	  var children = this.data.children
	  var componentManager = this.getComponentManager()
	  var child = componentManager.createElement(data)
	  this.listElement.appendChild(child.node)
	
	  // wait for UI thread to update.
	  setTimeout(function () {
	    this.scroller.refresh()
	  }.bind(this), 0)
	
	  // update this.data.children
	  if (!children || !children.length) {
	    this.data.children = [data]
	  } else {
	    children.push(data)
	  }
	
	  return child
	}
	
	List.prototype.insertBefore = function (child, before) {
	  var children = this.data.children
	  var i = 0
	  var isAppend = false
	
	  // update this.data.children
	  if (!children || !children.length || !before) {
	    isAppend = true
	  } else {
	    for (var l = children.length; i < l; i++) {
	      if (children[i].ref === before.data.ref) {
	        break
	      }
	    }
	    if (i === l) {
	      isAppend = true
	    }
	  }
	
	  if (isAppend) {
	    this.listElement.appendChild(child.node)
	    children.push(child.data)
	  } else {
	    if (before.fixedPlaceholder) {
	      this.listElement.insertBefore(child.node, before.fixedPlaceholder)
	    } else {
	      this.listElement.insertBefore(child.node, before.node)
	    }
	    children.splice(i, 0, child.data)
	  }
	
	  // wait for UI thread to update.
	  setTimeout(function () {
	    this.scroller.refresh()
	  }.bind(this), 0)
	}
	
	List.prototype.removeChild = function (child) {
	  var children = this.data.children
	  // remove from this.data.children
	  var i = 0
	  var componentManager = this.getComponentManager()
	  if (children && children.length) {
	    for (var l = children.length; i < l; i++) {
	      if (children[i].ref === child.data.ref) {
	        break
	      }
	    }
	    if (i < l) {
	      children.splice(i, 1)
	    }
	  }
	  // remove from componentMap recursively
	  componentManager.removeElementByRef(child.data.ref)
	  if (child.fixedPlaceholder) {
	    this.listElement.removeChild(child.fixedPlaceholder)
	  }
	  child.node.parentNode.removeChild(child.node)
	
	  // wait for UI thread to update.
	  setTimeout(function () {
	    this.scroller.refresh()
	  }.bind(this), 0)
	}
	
	module.exports = List


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(44);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./list.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./list.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, ".list-wrap {\n  display: block;\n  overflow: hidden;\n}\n\n.list-element {\n  -webkit-box-orient: vertical;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n}\n", ""]);
	
	// exports


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(46)
	
	var logger = __webpack_require__(32)
	
	var doc = window.document
	var ua = window.navigator.userAgent
	var scrollObjs = {}
	var plugins = {}
	var dpr = window.dpr
	  || (!!window.navigator.userAgent.match(/iPhone|iPad|iPod/)
	    ? document.documentElement.clientWidth / window.screen.availWidth
	    : 1)
	var inertiaCoefficient = {
	  normal: [2 * dpr, 0.0015 * dpr],
	  slow: [1.5 * dpr, 0.003 * dpr],
	  veryslow: [1.5 * dpr, 0.005 * dpr]
	}
	var timeFunction = {
	  ease: [.25,.1,.25,1],
	  liner: [0,0,1,1],
	  'ease-in': [.42,0,1,1],
	  'ease-out': [0,0,.58,1],
	  'ease-in-out': [.42,0,.58,1]
	}
	var Firefox = !!ua.match(/Firefox/i)
	var IEMobile = !!ua.match(/IEMobile/i)
	var cssPrefix = Firefox ? '-moz-' : IEMobile ? '-ms-' : '-webkit-'
	var stylePrefix = Firefox ? 'Moz' : IEMobile ? 'ms' : 'webkit'
	
	function debugLog() {
	  if (lib.scroll.outputDebugLog) {
	    logger.log.apply(logger, arguments)
	  }
	}
	
	function getBoundingClientRect(el) {
	  var rect = el.getBoundingClientRect()
	  if (!rect) {
	    rect = {}
	    rect.width = el.offsetWidth
	    rect.height = el.offsetHeight
	
	    rect.left = el.offsetLeft
	    rect.top = el.offsetTop
	    var parent = el.offsetParent
	    while (parent) {
	      rect.left += parent.offsetLeft
	      rect.top += parent.offsetTop
	      parent = parent.offsetParent
	    }
	
	    rect.right = rect.left + rect.width
	    rect.bottom = rect.top + rect.height
	  }
	  return rect
	}
	
	function getMinScrollOffset(scrollObj) {
	  return 0 - scrollObj.options[scrollObj.axis + 'PaddingTop']
	}
	
	function getMaxScrollOffset(scrollObj) {
	  var rect = getBoundingClientRect(scrollObj.element)
	  var pRect = getBoundingClientRect(scrollObj.viewport)
	  var min = getMinScrollOffset(scrollObj)
	  if (scrollObj.axis === 'y') {
	    var max = 0 - rect.height + pRect.height
	  } else {
	    var max = 0 - rect.width + pRect.width
	  }
	  return Math.min(
	    max + scrollObj.options[scrollObj.axis + 'PaddingBottom'],
	    min
	  )
	}
	
	function getBoundaryOffset(scrollObj, offset) {
	  if (offset > scrollObj.minScrollOffset) {
	    return offset - scrollObj.minScrollOffset
	  }
	  if (offset < scrollObj.maxScrollOffset) {
	    return offset - scrollObj.maxScrollOffset
	  }
	}
	
	function touchBoundary(scrollObj, offset) {
	  if (offset > scrollObj.minScrollOffset) {
	    offset = scrollObj.minScrollOffset
	  } else if (offset < scrollObj.maxScrollOffset) {
	    offset = scrollObj.maxScrollOffset
	  }
	  return offset
	}
	
	function fireEvent(scrollObj, eventName, extra) {
	  debugLog(scrollObj.element.scrollId, eventName, extra)
	  var event = doc.createEvent('HTMLEvents')
	  event.initEvent(eventName, false, true)
	  event.scrollObj = scrollObj
	  if (extra) {
	    for (var key in extra) {
	      event[key] = extra[key]
	    }
	  }
	  scrollObj.element.dispatchEvent(event)
	  scrollObj.viewport.dispatchEvent(event)
	}
	
	function getTransformOffset(scrollObj) {
	  var offset = {x: 0, y: 0}
	  var transform = getComputedStyle(scrollObj.element)
	    [stylePrefix + 'Transform']
	  var matched
	  var reg1 = new RegExp('^matrix3d'
	    + '\\((?:[-\\d.]+,\\s*){12}([-\\d.]+),'
	    + '\\s*([-\\d.]+)(?:,\\s*[-\\d.]+){2}\\)')
	  var reg2 = new RegExp('^matrix'
	    + '\\((?:[-\\d.]+,\\s*){4}([-\\d.]+),\\s*([-\\d.]+)\\)$')
	  if (transform !== 'none') {
	    if ((matched = transform.match(reg1) ||
	        transform.match(reg2))) {
	      offset.x = parseFloat(matched[1]) || 0
	      offset.y = parseFloat(matched[2]) || 0
	    }
	  }
	
	  return offset
	}
	
	var CSSMatrix = IEMobile ? 'MSCSSMatrix' : 'WebKitCSSMatrix'
	var has3d = !!Firefox
	  || CSSMatrix in window
	  && 'm11' in new window[CSSMatrix]()
	function getTranslate(x, y) {
	  x = parseFloat(x)
	  y = parseFloat(y)
	
	  if (x != 0) {
	    x += 'px'
	  }
	
	  if (y != 0) {
	    y += 'px'
	  }
	
	  if (has3d) {
	    return 'translate3d(' + x + ', ' + y + ', 0)'
	  }
	  return 'translate(' + x + ', ' + y + ')'
	}
	
	function setTransitionStyle(scrollObj, duration, timingFunction) {
	  if (duration === '' && timingFunction === '') {
	    scrollObj.element.style[stylePrefix + 'Transition'] = ''
	  } else {
	    scrollObj.element.style[stylePrefix + 'Transition']
	      = cssPrefix + 'transform ' + duration + ' ' + timingFunction + ' 0s'
	  }
	}
	
	function setTransformStyle(scrollObj, offset) {
	  var x = 0
	  var y = 0
	  if (typeof offset === 'object') {
	    x = offset.x
	    y = offset.y
	  } else {
	    if (scrollObj.axis === 'y') {
	      y = offset
	    } else {
	      x = offset
	    }
	  }
	  scrollObj.element.style[stylePrefix + 'Transform'] = getTranslate(x, y)
	}
	
	var panning = false
	doc.addEventListener('touchmove', function (e) {
	  if (panning) {
	    e.preventDefault()
	    return false
	  }
	  return true
	}, false)
	
	function Scroll(element, options) {
	  var that = this
	
	  options = options || {}
	  options.noBounce = !!options.noBounce
	  options.padding = options.padding || {}
	
	  if (options.isPrevent == null) {
	    options.isPrevent = true
	  } else {
	    options.isPrevent = !!options.isPrevent
	  }
	
	  if (options.isFixScrollendClick == null) {
	    options.isFixScrollendClick = true
	  } else {
	    options.isFixScrollendClick = !!options.isFixScrollendClick
	  }
	
	  if (options.padding) {
	    options.yPaddingTop = -options.padding.top || 0
	    options.yPaddingBottom = -options.padding.bottom || 0
	    options.xPaddingTop = -options.padding.left || 0
	    options.xPaddingBottom = -options.padding.right || 0
	  } else {
	    options.yPaddingTop = 0
	    options.yPaddingBottom = 0
	    options.xPaddingTop = 0
	    options.xPaddingBottom = 0
	  }
	
	  options.direction = options.direction || 'y'
	  options.inertia = options.inertia || 'normal'
	
	  this.options = options
	  that.axis = options.direction
	  this.element = element
	  this.viewport = element.parentNode
	  this.plugins = {}
	
	  this.element.scrollId = setTimeout(function () {
	    scrollObjs[that.element.scrollId + ''] = that
	  }, 1)
	
	  this.viewport.addEventListener('touchstart', touchstartHandler, false)
	  this.viewport.addEventListener('touchend', touchendHandler, false)
	  this.viewport.addEventListener('touchcancel', touchendHandler, false)
	  this.viewport.addEventListener('panstart', panstartHandler, false)
	  this.viewport.addEventListener('panmove', panHandler, false)
	  this.viewport.addEventListener('panend', panendHandler, false)
	
	  if (options.isPrevent) {
	    this.viewport.addEventListener('touchstart', function (e) {
	      panning = true
	    }, false)
	    that.viewport.addEventListener('touchend', function (e) {
	      panning = false
	    }, false)
	  }
	
	  // if (options.isPrevent) {
	  //   var d = this.axis === 'y'?'vertical':'horizontal'
	  //   this.viewport.addEventListener(d + 'panstart', function (e) {
	  //     panning = true
	  //   }, false)
	  //   that.viewport.addEventListener('panend', function (e) {
	  //     panning = false
	  //   }, false)
	  // }
	
	  if (options.isFixScrollendClick) {
	    var preventScrollendClick
	    var fixScrollendClickTimeoutId
	
	    this.viewport.addEventListener('scrolling', function () {
	      preventScrollendClick = true
	      fixScrollendClickTimeoutId && clearTimeout(fixScrollendClickTimeoutId)
	      fixScrollendClickTimeoutId = setTimeout(function (e) {
	        preventScrollendClick = false
	      }, 400)
	    }, false)
	
	    function preventScrollendClickHandler(e) {
	      if (preventScrollendClick || isScrolling) {
	        e.preventDefault()
	        e.stopPropagation()
	        return false
	      }
	      return true
	    }
	
	    function fireNiceTapEventHandler(e) {
	      if (!preventScrollendClick && !isScrolling) {
	        setTimeout(function () {
	          var niceTapEvent = document.createEvent('HTMLEvents')
	          niceTapEvent.initEvent('niceclick', true, true)
	          e.target.dispatchEvent(niceTapEvent)
	        }, 300)
	      }
	    }
	
	    this.viewport.addEventListener('click', preventScrollendClickHandler)
	    this.viewport.addEventListener('tap', fireNiceTapEventHandler)
	  }
	
	  if (options.useFrameAnimation) {
	    var scrollAnimation
	
	    Object.defineProperty(this, 'animation', {
	      get: function () {
	        return scrollAnimation
	      }
	    })
	  } else {
	    var transitionEndHandler
	    var transitionEndTimeoutId = 0
	
	    function setTransitionEndHandler(h, t) {
	      transitionEndHandler = null
	      clearTimeout(transitionEndTimeoutId)
	
	      transitionEndTimeoutId = setTimeout(function () {
	        if (transitionEndHandler) {
	          transitionEndHandler = null
	          lib.animation.requestFrame(h)
	        }
	      }, (t || 400))
	
	      transitionEndHandler = h
	    }
	
	    element.addEventListener(
	        Firefox
	          ? 'transitionend'
	          : (stylePrefix + 'TransitionEnd'), function (e) {
	      if (transitionEndHandler) {
	        var handler = transitionEndHandler
	
	        transitionEndHandler = null
	        clearTimeout(transitionEndTimeoutId)
	
	        lib.animation.requestFrame(function () {
	          handler(e)
	        })
	      }
	    }, false)
	  }
	
	  var panFixRatio
	  var isScrolling
	  var isFlickScrolling
	  var cancelScrollEnd
	
	  Object.defineProperty(this, 'isScrolling', {
	    get: function () {
	      return !!isScrolling
	    }
	  })
	
	  function isEnabled(e) {
	    if (!that.enabled) {
	      return false
	    }
	
	    if (typeof e.isVertical != 'undefined') {
	      if (that.axis === 'y' && e.isVertical
	          || that.axis === 'x' && !e.isVertical) {
	        // gesture in same direction, stop bubbling up
	        e.stopPropagation()
	      } else {
	        // gesture in different direction, bubbling up
	        // to the top, without any other process
	        return false
	      }
	    }
	
	    return true
	  }
	
	  function touchstartHandler(e) {
	    if (!isEnabled(e)) {
	      return
	    }
	
	    if (isScrolling) {
	      scrollEnd()
	    }
	
	    if (options.useFrameAnimation) {
	      scrollAnimation && scrollAnimation.stop()
	      scrollAnimation = null
	    } else {
	      var transform = getTransformOffset(that)
	      setTransformStyle(that, transform)
	      setTransitionStyle(that, '', '')
	      transitionEndHandler = null
	      clearTimeout(transitionEndTimeoutId)
	    }
	  }
	
	  function touchendHandler(e) {
	    if (!isEnabled(e)) {
	      return
	    }
	
	    var s0 = getTransformOffset(that)[that.axis]
	    var boundaryOffset = getBoundaryOffset(that, s0)
	
	    if (boundaryOffset) {
	      // dragging out of boundray, bounce is needed
	      var s1 = touchBoundary(that, s0)
	
	      if (options.useFrameAnimation) {
	        // frame
	        var _s = s1 - s0
	        scrollAnimation = new lib.animation(
	            400,
	            lib.cubicbezier.ease,
	            0,
	            function (i1, i2) {
	          var offset = (s0 + _s * i2).toFixed(2)
	          setTransformStyle(that, offset)
	          fireEvent(that, 'scrolling')
	        })
	        scrollAnimation.onend(scrollEnd)
	        scrollAnimation.play()
	      } else {
	        // css
	        var offset =  s1.toFixed(0)
	        setTransitionStyle(that, '0.4s', 'ease')
	        setTransformStyle(that, offset)
	        setTransitionEndHandler(scrollEnd, 400)
	
	        lib.animation.requestFrame(function () {
	          if (isScrolling && that.enabled) {
	            fireEvent(that, 'scrolling')
	            lib.animation.requestFrame(arguments.callee)
	          }
	        })
	      }
	
	      if (boundaryOffset > 0) {
	        fireEvent(that, that.axis === 'y' ? 'pulldownend' : 'pullrightend')
	      } else if (boundaryOffset < 0) {
	        fireEvent(that, that.axis === 'y' ? 'pullupend' : 'pullleftend')
	      }
	    } else if (isScrolling) {
	      // without exceeding the boundary, just end it
	      scrollEnd()
	    }
	  }
	
	  var lastDisplacement
	  function panstartHandler(e) {
	    if (!isEnabled(e)) {
	      return
	    }
	
	    that.transformOffset = getTransformOffset(that)
	    that.minScrollOffset = getMinScrollOffset(that)
	    that.maxScrollOffset = getMaxScrollOffset(that)
	    panFixRatio = 2.5
	    cancelScrollEnd = true
	    isScrolling = true
	    isFlickScrolling = false
	    fireEvent(that, 'scrollstart')
	
	    lastDisplacement = e['displacement' + that.axis.toUpperCase()]
	  }
	
	
	  function panHandler(e) {
	    if (!isEnabled(e)) {
	      return
	    }
	
	    // finger move less than 5 px. just ignore that.
	    var displacement = e['displacement' + that.axis.toUpperCase()]
	    if (Math.abs(displacement - lastDisplacement) < 5) {
	      e.stopPropagation()
	      return
	    }
	    lastDisplacement = displacement
	
	    var offset = that.transformOffset[that.axis] + displacement
	    if (offset > that.minScrollOffset) {
	      offset = that.minScrollOffset
	        + (offset - that.minScrollOffset) / panFixRatio
	      panFixRatio *= 1.003
	    } else if (offset < that.maxScrollOffset) {
	      offset = that.maxScrollOffset
	        - (that.maxScrollOffset - offset) / panFixRatio
	      panFixRatio *= 1.003
	    }
	    if (panFixRatio > 4) {
	      panFixRatio = 4
	    }
	
	    // tell whether or not reach the fringe
	    var boundaryOffset = getBoundaryOffset(that, offset)
	    if (boundaryOffset) {
	      fireEvent(
	          that,
	          boundaryOffset > 0
	          ? (that.axis === 'y' ? 'pulldown' : 'pullright')
	          : (that.axis === 'y' ? 'pullup' : 'pullleft'), {
	        boundaryOffset: Math.abs(boundaryOffset)
	      })
	      if (that.options.noBounce) {
	        offset = touchBoundary(that, offset)
	      }
	    }
	
	    setTransformStyle(that, offset.toFixed(2))
	    fireEvent(that, 'scrolling')
	  }
	
	  function panendHandler(e) {
	    if (!isEnabled(e)) {
	      return
	    }
	
	    if (e.isflick) {
	      flickHandler(e)
	    }
	  }
	
	  function flickHandler(e) {
	    cancelScrollEnd = true
	
	    var v0, a0, t0, s0, s, motion0
	    var v1, a1, t1, s1, motion1,sign
	    var v2, a2, t2, s2, motion2, ft
	
	    s0 = getTransformOffset(that)[that.axis]
	    var boundaryOffset0 = getBoundaryOffset(that, s0)
	    if (!boundaryOffset0) {
	      // when fingers left the range of screen, let touch end handler
	      // to deal with it.
	      // when fingers left the screen, but still in the range of
	      // screen, calculate the intertia.
	      v0 = e['velocity' + that.axis.toUpperCase()]
	
	      var maxV = 2
	      var friction = 0.0015
	      if (options.inertia && inertiaCoefficient[options.inertia]) {
	        maxV = inertiaCoefficient[options.inertia][0]
	        friction = inertiaCoefficient[options.inertia][1]
	      }
	
	      if (v0 > maxV) {
	        v0 = maxV
	      }
	      if (v0 < -maxV) {
	        v0 = -maxV
	      }
	      a0 = friction * (v0 / Math.abs(v0))
	      motion0 = new lib.motion({
	        v: v0,
	        a: -a0
	      })
	      t0 = motion0.t
	      s = s0 + motion0.s
	
	      var boundaryOffset1 = getBoundaryOffset(that, s)
	      if (boundaryOffset1) {
	        debugLog('inertial calculation has exceeded the boundary',
	          boundaryOffset1)
	
	        v1 = v0
	        a1 = a0
	        if (boundaryOffset1 > 0) {
	          s1 = that.minScrollOffset
	          sign = 1
	        } else {
	          s1 = that.maxScrollOffset
	          sign = -1
	        }
	        motion1 = new lib.motion({
	          v: sign * v1,
	          a: -sign * a1,
	          s: Math.abs(s1 - s0)
	        })
	        t1 = motion1.t
	        var timeFunction1 = motion1.generateCubicBezier()
	
	        v2 = v1 - a1 * t1
	        a2 = 0.03 * (v2 / Math.abs(v2))
	        motion2 = new lib.motion({
	          v: v2,
	          a: -a2
	        })
	        t2 = motion2.t
	        s2 = s1 + motion2.s
	        var timeFunction2 = motion2.generateCubicBezier()
	
	        if (options.noBounce) {
	          debugLog('no bounce effect')
	
	          if (s0 !== s1) {
	            if (options.useFrameAnimation) {
	              // frame
	              var _s = s1 - s0
	              var bezier = lib.cubicbezier(
	                timeFunction1[0][0],
	                timeFunction1[0][1],
	                timeFunction1[1][0],
	                timeFunction1[1][1]
	              )
	              scrollAnimation = new lib.animation(
	                  t1.toFixed(0),
	                  bezier,
	                  0,
	                  function (i1, i2) {
	                var offset = (s0 + _s * i2)
	                getTransformOffset(that, offset.toFixed(2))
	                fireEvent(that, 'scrolling', {
	                  afterFlick: true
	                })
	              })
	
	              scrollAnimation.onend(scrollEnd)
	
	              scrollAnimation.play()
	            } else {
	              // css
	              var offset = s1.toFixed(0)
	              setTransitionStyle(
	                that,
	                (t1 / 1000).toFixed(2) + 's',
	                'cubic-bezier(' + timeFunction1 + ')'
	              )
	              setTransformStyle(that, offset)
	              setTransitionEndHandler(
	                scrollEnd,
	                (t1 / 1000).toFixed(2) * 1000
	              )
	            }
	          } else {
	            scrollEnd()
	          }
	        } else if (s0 !== s2) {
	          debugLog(
	            'scroll for inertia',
	            's=' + s2.toFixed(0),
	            't=' + ((t1 + t2) / 1000).toFixed(2)
	          )
	
	          if (options.useFrameAnimation) {
	            var _s = s2 - s0
	            var bezier = lib.cubicbezier.easeOut
	            scrollAnimation = new lib.animation(
	                (t1 + t2).toFixed(0),
	                bezier,
	                0,
	                function (i1, i2) {
	              var offset = s0 + _s * i2
	              setTransformStyle(that, offset.toFixed(2))
	              fireEvent(that, 'scrolling',{
	                afterFlick: true
	              })
	            })
	
	            scrollAnimation.onend(function () {
	              if (!that.enabled) {
	                return
	              }
	
	              var _s = s1 - s2
	              var bezier = lib.cubicbezier.ease
	              scrollAnimation = new lib.animation(
	                  400,
	                  bezier,
	                  0,
	                  function (i1, i2) {
	                var offset = s2 + _s * i2
	                setTransformStyle(that, offset.toFixed(2))
	                fireEvent(that, 'scrolling',{
	                  afterFlick: true
	                })
	              })
	
	              scrollAnimation.onend(scrollEnd)
	
	              scrollAnimation.play()
	            })
	
	            scrollAnimation.play()
	          } else {
	            var offset = s2.toFixed(0)
	            setTransitionStyle(
	              that,
	              ((t1 + t2) / 1000).toFixed(2) + 's',
	              'ease-out'
	            )
	            setTransformStyle(that, offset)
	
	            setTransitionEndHandler(function (e) {
	              if (!that.enabled) {
	                return
	              }
	
	              debugLog('inertial bounce',
	                's=' + s1.toFixed(0),
	                't=400'
	              )
	
	              if (s2 !== s1) {
	                var offset = s1.toFixed(0)
	                setTransitionStyle(that, '0.4s', 'ease')
	                setTransformStyle(that, offset)
	                setTransitionEndHandler(scrollEnd, 400)
	              } else {
	                scrollEnd()
	              }
	            }, ((t1 + t2) / 1000).toFixed(2) * 1000)
	          }
	        } else {
	          scrollEnd()
	        }
	      } else {
	        debugLog('inertial calculation hasn\'t exceeded the boundary')
	        var timeFunction = motion0.generateCubicBezier()
	
	        if (options.useFrameAnimation) {
	          // frame
	          var _s = s - s0
	          var bezier = lib.cubicbezier(
	            timeFunction[0][0],
	            timeFunction[0][1],
	            timeFunction[1][0],
	            timeFunction[1][1]
	          )
	          scrollAnimation = new lib.animation(
	              t0.toFixed(0),
	              bezier,
	              0,
	              function (i1, i2) {
	            var offset = (s0 + _s * i2).toFixed(2)
	            setTransformStyle(that, offset)
	            fireEvent(that, 'scrolling',{
	              afterFlick: true
	            })
	          })
	
	          scrollAnimation.onend(scrollEnd)
	
	          scrollAnimation.play()
	        } else {
	          // css
	          var offset = s.toFixed(0)
	          setTransitionStyle(
	            that,
	            (t0 / 1000).toFixed(2) + 's',
	            'cubic-bezier(' + timeFunction + ')'
	          )
	          setTransformStyle(that, offset)
	          setTransitionEndHandler(scrollEnd, (t0 / 1000).toFixed(2) * 1000)
	        }
	      }
	
	
	      isFlickScrolling = true
	      if (!options.useFrameAnimation) {
	        lib.animation.requestFrame(function () {
	          if (isScrolling && isFlickScrolling && that.enabled) {
	            fireEvent(that, 'scrolling', {
	              afterFlick: true
	            })
	            lib.animation.requestFrame(arguments.callee)
	          }
	        })
	      }
	    }
	  }
	
	  function scrollEnd() {
	    if (!that.enabled) {
	      return
	    }
	
	    cancelScrollEnd = false
	
	    setTimeout(function () {
	      if (!cancelScrollEnd && isScrolling) {
	        isScrolling = false
	        isFlickScrolling = false
	
	        if (options.useFrameAnimation) {
	          scrollAnimation && scrollAnimation.stop()
	          scrollAnimation = null
	        } else {
	          setTransitionStyle(that, '', '')
	        }
	        fireEvent(that, 'scrollend')
	      }
	    }, 50)
	  }
	
	  var proto = {
	    init: function () {
	      this.enable()
	      this.refresh()
	      this.scrollTo(0)
	      return this
	    },
	
	    enable: function () {
	      this.enabled = true
	      return this
	    },
	
	    disable: function () {
	      var el = this.element
	      this.enabled = false
	
	      if (this.options.useFrameAnimation) {
	        scrollAnimation && scrollAnimation.stop()
	      } else {
	        lib.animation.requestFrame(function () {
	          el.style[stylePrefix + 'Transform']
	            = getComputedStyle(el)[stylePrefix + 'Transform']
	        })
	      }
	
	      return this
	    },
	
	    getScrollWidth: function () {
	      return getBoundingClientRect(this.element).width
	    },
	
	    getScrollHeight: function () {
	      return getBoundingClientRect(this.element).height
	    },
	
	    getScrollLeft: function () {
	      return -getTransformOffset(this).x - this.options.xPaddingTop
	    },
	
	    getScrollTop: function () {
	      return -getTransformOffset(this).y - this.options.yPaddingTop
	    },
	
	    getMaxScrollLeft: function () {
	      return -that.maxScrollOffset - this.options.xPaddingTop
	    },
	
	    getMaxScrollTop: function () {
	      return -that.maxScrollOffset - this.options.yPaddingTop
	    },
	
	    getBoundaryOffset: function () {
	      return Math.abs(
	        getBoundaryOffset(this, getTransformOffset(this)[this.axis]) || 0
	      )
	    },
	
	    refresh: function () {
	      var el = this.element
	      var isVertical = (this.axis === 'y')
	      var type = isVertical?'height':'width'
	
	      if (this.options[type] != null) {
	        // use options
	        el.style[type] = this.options[type] + 'px'
	      } else if (!!this.options.useElementRect) {
	        el.style[type] = 'auto'
	        el.style[type] = getBoundingClientRect(el)[type] + 'px'
	      } else if (el.childElementCount > 0) {
	        var range
	        var rect
	        var firstEl = el.firstElementChild
	        var lastEl = el.lastElementChild
	
	        if (document.createRange && !this.options.ignoreOverflow) {
	          // use range
	          range = document.createRange()
	          range.selectNodeContents(el)
	          rect = getBoundingClientRect(range)
	        }
	
	        if (rect) {
	          el.style[type] = rect[type] + 'px'
	        } else {
	          // use child offsets
	          while (firstEl) {
	            if (getBoundingClientRect(firstEl)[type] === 0
	                && firstEl.nextElementSibling) {
	              firstEl = firstEl.nextElementSibling
	            } else {
	              break
	            }
	          }
	
	          while (lastEl && lastEl !== firstEl) {
	            if (getBoundingClientRect(lastEl)[type] === 0
	                && lastEl.previousElementSibling) {
	              lastEl = lastEl.previousElementSibling
	            } else {
	              break
	            }
	          }
	
	          el.style[type] = (getBoundingClientRect(lastEl)[
	              isVertical ? 'bottom' : 'right']
	            - getBoundingClientRect(firstEl)[
	              isVertical ? 'top' : 'left'])
	            + 'px'
	        }
	      }
	
	      this.transformOffset = getTransformOffset(this)
	      this.minScrollOffset = getMinScrollOffset(this)
	      this.maxScrollOffset = getMaxScrollOffset(this)
	      this.scrollTo(
	        -this.transformOffset[this.axis]
	        - this.options[this.axis + 'PaddingTop']
	      )
	      fireEvent(this, 'contentrefresh')
	
	      return this
	    },
	
	    offset: function (childEl) {
	      var elRect = getBoundingClientRect(this.element)
	      var childRect = getBoundingClientRect(childEl)
	      if (this.axis === 'y') {
	        var offsetRect = {
	          top: childRect.top - elRect.top - this.options.yPaddingTop,
	          left: childRect.left - elRect.left,
	          right: elRect.right - childRect.right,
	          width: childRect.width,
	          height: childRect.height
	        }
	
	        offsetRect.bottom = offsetRect.top + offsetRect.height
	      } else {
	        var offsetRect = {
	          top: childRect.top - elRect.top,
	          bottom: elRect.bottom - childRect.bottom,
	          left: childRect.left - elRect.left - this.options.xPaddingTop,
	          width: childRect.width,
	          height: childRect.height
	        }
	
	        offsetRect.right = offsetRect.left + offsetRect.width
	      }
	      return offsetRect
	    },
	
	    getRect: function (childEl) {
	      var viewRect = getBoundingClientRect(this.viewport)
	      var childRect = getBoundingClientRect(childEl)
	      if (this.axis === 'y') {
	        var offsetRect = {
	          top: childRect.top - viewRect.top,
	          left: childRect.left - viewRect.left,
	          right: viewRect.right - childRect.right,
	          width: childRect.width,
	          height: childRect.height
	        }
	
	        offsetRect.bottom = offsetRect.top + offsetRect.height
	      } else {
	        var offsetRect = {
	          top: childRect.top - viewRect.top,
	          bottom: viewRect.bottom - childRect.bottom,
	          left: childRect.left - viewRect.left,
	          width: childRect.width,
	          height: childRect.height
	        }
	
	        offsetRect.right = offsetRect.left + offsetRect.width
	      }
	      return offsetRect
	    },
	
	    isInView: function (childEl) {
	      var viewRect = this.getRect(this.viewport)
	      var childRect = this.getRect(childEl)
	      if (this.axis === 'y') {
	        return viewRect.top < childRect.bottom
	          && viewRect.bottom > childRect.top
	      }
	      return viewRect.left < childRect.right
	        && viewRect.right > childRect.left
	    },
	
	    scrollTo: function (offset, isSmooth) {
	      var that = this
	      var element = this.element
	
	      offset = -offset - this.options[this.axis + 'PaddingTop']
	      offset = touchBoundary(this, offset)
	
	      isScrolling = true
	      if (isSmooth === true) {
	        if (this.options.useFrameAnimation) {
	          var s0 = getTransformOffset(that)[this.axis]
	          var _s = offset - s0
	          scrollAnimation = new lib.animation(
	              400,
	              lib.cubicbezier.easeInOut,
	              0,
	              function (i1, i2) {
	            var offset = (s0 + _s * i2).toFixed(2)
	            setTransformStyle(that, offset)
	            fireEvent(that, 'scrolling')
	          })
	
	          scrollAnimation.onend(scrollEnd)
	
	          scrollAnimation.play()
	        } else {
	          setTransitionStyle(that, '0.4s', 'ease-in-out')
	          setTransformStyle(that, offset)
	          setTransitionEndHandler(scrollEnd, 400)
	
	          lib.animation.requestFrame(function () {
	            if (isScrolling && that.enabled) {
	              fireEvent(that, 'scrolling')
	              lib.animation.requestFrame(arguments.callee)
	            }
	          })
	        }
	      } else {
	        if (!this.options.useFrameAnimation) {
	          setTransitionStyle(that, '', '')
	        }
	        setTransformStyle(that, offset)
	        scrollEnd()
	      }
	
	      return this
	    },
	
	    scrollToElement: function (childEl, isSmooth) {
	      var offset = this.offset(childEl)
	      offset = offset[this.axis === 'y'?'top':'left']
	      return this.scrollTo(offset, isSmooth)
	    },
	
	    getViewWidth: function () {
	      return getBoundingClientRect(this.viewport).width
	    },
	
	    getViewHeight: function () {
	      return getBoundingClientRect(this.viewport).height
	    },
	
	    addPulldownHandler: function (handler) {
	      var that = this
	      this.element.addEventListener('pulldownend', function (e) {
	        that.disable()
	        handler.call(that, e, function () {
	          that.scrollTo(0, true)
	          that.refresh()
	          that.enable()
	        })
	      }, false)
	
	      return this
	    },
	
	    addPullupHandler: function (handler) {
	      var that = this
	
	      this.element.addEventListener('pullupend', function (e) {
	        that.disable()
	        handler.call(that, e, function () {
	          that.scrollTo(that.getScrollHeight(), true)
	          that.refresh()
	          that.enable()
	        })
	      }, false)
	
	      return this
	    },
	
	    addScrollstartHandler: function (handler) {
	      var that = this
	      this.element.addEventListener('scrollstart', function (e) {
	        handler.call(that, e)
	      }, false)
	
	      return this
	    },
	
	    addScrollingHandler: function (handler) {
	      var that = this
	      this.element.addEventListener('scrolling', function (e) {
	        handler.call(that, e)
	      }, false)
	
	      return this
	    },
	
	    addScrollendHandler: function (handler) {
	      var that = this
	      this.element.addEventListener('scrollend', function (e) {
	        handler.call(that, e)
	      }, false)
	
	      return this
	    },
	
	    addContentrenfreshHandler: function (handler) {
	      var that = this
	      this.element.addEventListener('contentrefresh', function (e) {
	        handler.call(that, e)
	      }, false)
	    },
	
	    addEventListener: function (name, handler, useCapture) {
	      var that = this
	      this.element.addEventListener(name, function (e) {
	        handler.call(that, e)
	      }, !!useCapture)
	    },
	
	    removeEventListener: function (name, handler) {
	      var that = this
	      this.element.removeEventListener(name, function (e) {
	        handler.call(that, e)
	      })
	    },
	
	    enablePlugin: function (name, options) {
	      var plugin = plugins[name]
	      if (plugin && !this.plugins[name]) {
	        this.plugins[name] = true
	        options = options || {}
	        plugin.call(this, name, options)
	      }
	      return this
	    }
	  }
	
	  for (var k in proto) {
	    this[k] = proto[k]
	  }
	  delete proto
	}
	
	lib.scroll = function (el, options) {
	  if (arguments.length === 1 && !(arguments[0] instanceof HTMLElement)) {
	    options = arguments[0]
	    if (options.scrollElement) {
	      el = options.scrollElement
	    } else if (options.scrollWrap) {
	      el = options.scrollWrap.firstElementChild
	    } else {
	      throw new Error('no scroll element')
	    }
	  }
	
	  if (!el.parentNode) {
	    throw new Error('wrong dom tree')
	  }
	  if (options
	      && options.direction
	      && ['x', 'y'].indexOf(options.direction) < 0) {
	    throw new Error('wrong direction')
	  }
	
	  var scroll
	  if (options.downgrade === true
	      && lib.scroll.downgrade) {
	    scroll = lib.scroll.downgrade(el, options)
	  } else {
	    if (el.scrollId) {
	      scroll = scrollObjs[el.scrollId]
	    } else {
	      scroll = new Scroll(el, options)
	    }
	  }
	  return scroll
	}
	
	lib.scroll.plugin = function (name, constructor) {
	  if (constructor) {
	    name = name.split(',')
	    name.forEach(function (n) {
	      plugins[n] = constructor
	    })
	  } else {
	    return plugins[name]
	  }
	}
	


/***/ },
/* 46 */
/***/ function(module, exports) {

	'use strict'
	
	/**
	 * transfer Quadratic Bezier Curve to Cubic Bezier Curve
	 *
	 * @param  {number} a abscissa of p1
	 * @param  {number} b ordinate of p1
	 * @return {Array} parameter matrix for cubic bezier curve
	 *   like [[p1x, p1y], [p2x, p2y]]
	 */
	function quadratic2cubicBezier(a, b) {
	  return [
	    [
	      (a / 3 + (a + b) / 3 - a) / (b - a),
	      (a * a / 3 + a * b * 2 / 3 - a * a) / (b * b - a * a)
	    ], [
	      (b / 3 + (a + b) / 3 - a) / (b - a),
	      (b * b / 3 + a * b * 2 / 3 - a * a) / (b * b - a * a)
	    ]
	  ]
	}
	
	/**
	 * derive position data from knowing motion parameters
	 * base on Newton's second law: s = vt + at^2/2
	 *
	 * @param {object} config object of { v, a, s, t }
	 *   - v: initial velocity
	 *   - a: accelerate speed
	 *   - t: time
	 *   - s: shifting
	 */
	function Motion(config) {
	
	  this.v = config.v || 0
	  this.a = config.a || 0
	
	  if (typeof config.t !== 'undefined') {
	    this.t = config.t
	  }
	
	  if (typeof config.s !== 'undefined') {
	    this.s = config.s
	  }
	
	  // derive time from shifting
	  if (typeof this.t === 'undefined') {
	    if (typeof this.s === 'undefined') {
	      this.t = -this.v / this.a
	    } else {
	      var t1 = (Math.sqrt(this.v * this.v + 2 * this.a * this.s) - this.v)
	        / this.a
	      var t2 = (-Math.sqrt(this.v * this.v + 2 * this.a * this.s) - this.v)
	        / this.a
	      this.t = Math.min(t1, t2)
	    }
	  }
	
	  // derive shifting from time
	  if (typeof this.s === 'undefined') {
	    this.s = this.a * this.t * this.t / 2 + this.v * this.t
	  }
	}
	
	/**
	 * derive cubic bezier parameters from motion parameters
	 * @return {Array} parameter matrix for cubic bezier curve
	 *   like [[p1x, p1y], [p2x, p2y]]
	 */
	Motion.prototype.generateCubicBezier = function () {
	  return quadratic2cubicBezier(
	    this.v / this.a, this.t + this.v / this.a
	  )
	}
	
	!lib && (lib = {})
	lib.motion = Motion
	
	module.exports = Motion

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var List = __webpack_require__(42)
	
	function Hlist(data, nodeType) {
	  data.attr.direction = 'h'
	  List.call(this, data, nodeType)
	}
	
	Hlist.prototype = Object.create(List.prototype)
	
	module.exports = Hlist

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(37)
	__webpack_require__(49)
	
	var FORMATTER_REGEXP = /(\\)?(dd*|hh?|mm?|ss?)/gi
	
	function formatDateTime(data, formatter, timeColor) {
	  return formatter.replace(FORMATTER_REGEXP, function (m) {
	    var len = m.length
	    var firstChar = m.charAt(0)
	    // escape character
	    if (firstChar === '\\') {
	      return m.replace('\\', '')
	    }
	    var value = (firstChar === 'd' ? data.days :
	                firstChar === 'h' ? data.hours :
	                firstChar === 'm' ? data.minutes :
	                firstChar === 's' ? data.seconds : 0) + ''
	
	    // 5 zero should be enough
	    return '<span style="margin:4px;color:'
	      + timeColor + '" >'
	      + ('00000' + value).substr(-Math.max(value.length, len))
	      + '</span>'
	  })
	}
	
	function Countdown (data) {
	  Atomic.call(this, data)
	}
	
	Countdown.prototype = Object.create(Atomic.prototype)
	
	Countdown.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('weex-element')
	  var data = this.data
	  var time = Number(data.attr.countdownTime) || 0
	  var endTime = Date.now() / 1000 + time
	  var cd = lib.countdown({
	    endDate: endTime,
	    onUpdate: function (time) {
	      var timeColor = data.style.timeColor || '#000'
	      var result = formatDateTime(time, data.attr.formatterValue, timeColor)
	      node.innerHTML = result
	    },
	    onEnd: function () {
	    }
	  }).start()
	
	  return node
	}
	
	Countdown.prototype.style = {
	  textColor: function (value) {
	    this.node.style.color = value
	  }
	}
	
	module.exports = Countdown


/***/ },
/* 49 */
/***/ function(module, exports) {

	!function(a,b){function c(a){var b;if("number"==typeof a)b=new Date(1e3*a);else if("string"==typeof a){var c=a.charAt(0),d="+"===c,h="-"===c;if(d||h){for(var i,j=a.substr(1),k=j.split(":"),l=[0,0,0,0],m=4;k.length&&--m>=0;)l[m]=parseInt(k.pop())||0;i=e*l[0]+f*l[1]+g*l[2]+l[3],b=new Date,b.setSeconds(b.getSeconds()+i*(h?-1:1)),b.setMilliseconds(0)}}return b||(b=new Date(a)),b}function d(a,b){return b.replace(FORMATTER_REGEXP,function(b){var c=b.length,d=b.charAt(0);if("\\"===d)return b.replace("\\","");var e=("d"===d?a.days:"h"===d?a.hours:"m"===d?a.minutes:"s"===d?a.seconds:0)+"";return("00000"+e).substr(-Math.max(e.length,c))})}var e=86400,f=3600,g=60,h="dhhmmss";FORMATTER_REGEXP=/(\\)?(dd*|hh?|mm?|ss?)/gi;var i=function(a){a=a||{};var b=this,d=c(a.endDate);if(!d||!d.getTime())throw new Error("Invalid endDate");b.endDate=d,b.onUpdate=a.onUpdate,b.onEnd=a.onEnd,b.interval=a.interval||1e3,b.stringFormatter=a.stringFormatter||h,b.correctDateOffset=a.correctDateOffset||0,b.updateElement=a.updateElement,b._data={days:0,hours:0,minutes:0,seconds:0}};i.prototype={start:function(){var a=this;return a.stop(),a._update()&&(a._intervalId=setInterval(function(){a._update()},a.interval)),a},_update:function(){var a,b=this,c=b._data,h=b.updateElement,i=+new Date+1e3*b.correctDateOffset,j=Math.max(0,Math.round((b.endDate.getTime()-i)/1e3)),k=0>=j;return c.totalSeconds=j,j-=(c.days=Math.floor(j/e))*e,j-=(c.hours=Math.floor(j/f))*f,j-=(c.minutes=Math.floor(j/g))*g,c.seconds=j,c.stringValue=d(c,b.stringFormatter),h&&(h.innerHTML=c.stringValue),(a=b.onUpdate)&&a.call(b,c),k?(b.stop(),(a=b.onEnd)&&a.call(b),!1):!0},stop:function(){var a=this;return a._intervalId&&(clearInterval(a._intervalId),a._intervalId=null),a},setEndDate:function(a){var b=this;return b.endDate=c(a),b}},b.countdown=function(a){return new i(a)}}(window,window.lib||(window.lib={}));

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var config = __webpack_require__(13)
	var Component = __webpack_require__(24)
	var ComponentManager = __webpack_require__(17)
	var LazyLoad = __webpack_require__(20)
	
	function Marquee (data) {
	  this.interval = Number(data.attr.interval) || 5 * 1000
	  this.transitionDuration = Number(data.attr.transitionDuration) || 500
	  this.delay = Number(data.attr.delay) || 0
	  Component.call(this, data)
	}
	
	Marquee.prototype = Object.create(Component.prototype)
	
	Marquee.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('weex-container')
	  node.style.overflow = 'hidden'
	  // fix page shaking during slider's playing
	  node.style.webkitTransform = 'translate3D(0,0,0)'
	  node.addEventListener('webkitTransitionEnd', this.end.bind(this), false)
	  return node
	}
	
	Marquee.prototype.createChildren = function () {
	  // first run:
	  // - create each child
	  // - append to parentNode
	  // - find current and next
	  // - set current and next shown and others hidden
	  var children = this.data.children
	  var parentRef = this.data.ref
	  var instanceId = this.data.instanceId
	  var items = []
	  var componentManager = this.getComponentManager()
	
	  var fragment, isFlex, child, node, i
	
	  if (children && children.length) {
	    fragment = document.createDocumentFragment()
	    isFlex = false
	    for (i = 0; i < children.length; i++) {
	      children[i].scale = this.data.scale
	      children[i].instanceId = instanceId
	      child = componentManager.createElement(children[i])
	      child.parentRef = parentRef
	      this.initChild(child)
	      // append and push
	      items.push(child)
	      fragment.appendChild(child.node)
	      if (!isFlex && child.data.style.hasOwnProperty('flex')) {
	        isFlex = true
	      }
	    }
	    this.node.appendChild(fragment)
	  }
	
	  // set items
	  this.items = items
	
	  // reset the clock for first transition
	  this.reset()
	}
	
	Marquee.prototype.initChild = function (child) {
	  var node = child.node
	  node.style.position = 'absolute'
	  node.style.top = '0'
	  node.style.left = '0'
	}
	
	Marquee.prototype.appendChild = function (data) {
	  // dom + items
	  var componentManager = ComponentManager.getInstance(this.data.instanceId)
	  var child = componentManager.createElement(data)
	  this.initChild(child)
	  this.node.appendChild(child.node)
	  this.items.push(child)
	  this.reset()
	  return child // @todo redesign Component#appendChild(component)
	}
	
	Marquee.prototype.insertBefore = function (child, before) {
	  // dom + items
	  var index = this.items.indexOf(before)
	  this.items.splice(index, 0, child)
	  this.initChild(child)
	  this.node.insertBefore(child.node, before.node)
	  this.reset()
	}
	
	Marquee.prototype.removeChild = function (child) {
	  // dom + items
	  var index = this.items.indexOf(child)
	  this.items.splice(index, 1)
	  this.node.removeChild(child.node)
	  this.reset()
	}
	
	/**
	 * status: {
	 *   current: {translateY: 0, shown: true},
	 *   next: {translateY: height, shown: true},
	 *   others[]: {shown: false}
	 *   index: index
	 * }
	 */
	Marquee.prototype.reset = function () {
	  var interval = this.interval - 0
	  var delay = this.delay - 0
	  var items = this.items
	  var self = this
	
	  var loop = function () {
	    self.next()
	    self.timerId = setTimeout(loop, self.interval)
	  }
	
	  // reset display and transform
	  items.forEach(function (item, index) {
	    var node = item.node
	    // set non-current(0)|next(1) item hidden
	    node.style.display = index > 1 ? 'none' : ''
	    // set next(1) item translateY
	    // TODO: it supposed to use item.data.style
	    // but somehow the style object is empty.
	    // This problem relies on jsframework's bugfix.
	
	    // node.style.transform = index === 1
	    //     ? 'translate3D(0,' + config.scale * item.data.style.height + 'px,0)'
	    //     : ''
	    // node.style.webkitTransform = index === 1
	    //     ? 'translate3D(0,' + config.scale * item.data.style.height + 'px,0)'
	    //     : ''
	    node.style.transform = index === 1
	        ? 'translate3D(0,' + self.data.scale * self.data.style.height + 'px,0)'
	        : ''
	    node.style.webkitTransform = index === 1
	        ? 'translate3D(0,' + self.data.scale * self.data.style.height + 'px,0)'
	        : ''
	  })
	
	  setTimeout(function () {
	    // reset current, next, index
	    self.currentItem = items[0]
	    self.nextItem = items[1]
	    self.currentIndex = 0
	
	    items.forEach(function (item, index) {
	      var node = item.node
	      // set transition
	      node.style.transition = 'transform '
	          + self.transitionDuration
	          + 'ms ease'
	      node.style.webkitTransition = '-webkit-transform '
	          + self.transitionDuration
	          + 'ms ease'
	    })
	
	    clearTimeout(self.timerId)
	
	    if (items.length > 1) {
	      self.timerId = setTimeout(loop, delay + interval)
	    }
	  }, 13)
	
	}
	
	/**
	 * next:
	 * - current: {translateY: -height}
	 * - next: {translateY: 0}
	 */
	Marquee.prototype.next = function () {
	  // - update state
	  //   - set current and next transition
	  //   - hide current when transition end
	  //   - set next to current
	  //   - find new next
	  var next = this.nextItem.node
	  var current = this.currentItem.node
	  this.transitionIndex = this.currentIndex
	
	  // Use setTimeout to fix the problem that when the
	  // page recover from backstage, the slider will
	  // not work any longer.
	  setTimeout(function () {
	    next.style.transform = 'translate3D(0,0,0)'
	    next.style.webkitTransform = 'translate3D(0,0,0)'
	    current.style.transform = 'translate3D(0,-'
	        + this.data.scale * this.data.style.height
	        + 'px,0)'
	    current.style.webkitTransform = 'translate3D(0,-'
	        + this.data.scale * this.data.style.height
	        + 'px,0)'
	    this.fireEvent('change')
	  }.bind(this), 300)
	}
	
	Marquee.prototype.fireEvent = function (type) {
	  var length = this.items.length
	  var nextIndex = (this.currentIndex + 1) % length
	  var evt = document.createEvent('HTMLEvents')
	  evt.initEvent(type, false, false)
	  evt.data = {
	    prevIndex: this.currentIndex,
	    index: nextIndex
	  }
	  this.node.dispatchEvent(evt)
	}
	
	/**
	 * end:
	 * - old current: {shown: false}
	 * - old current: {translateY: 0}
	 * - index++ % length
	 * - new current = old next
	 * - new next = items[index+1 % length]
	 * - new next: {translateY: height}
	 * - new next: {shown: true}
	 */
	Marquee.prototype.end = function (e) {
	  var target = e.target
	  var items = this.items
	  var length = items.length
	  var current, next
	  var currentIndex, nextIndex
	
	  currentIndex = this.transitionIndex
	
	  if (isNaN(currentIndex)) {
	    return
	  }
	  delete this.transitionIndex
	
	  current = this.currentItem.node
	  current.style.display = 'none'
	  current.style.webkitTransform = ''
	
	  currentIndex = (currentIndex + 1) % length
	  nextIndex = (currentIndex + 1) % length
	
	  this.currentIndex = currentIndex
	  this.currentItem = this.nextItem
	  this.nextItem = items[nextIndex]
	
	  setTimeout(function () {
	    next = this.nextItem.node
	    // TODO: it supposed to use this.nextItem.data.style
	    // but somehow the style object is empty.
	    // This problem relies on jsframework's bugfix.
	
	    next.style.webkitTransform = 'translate3D(0,'
	        + this.data.scale * this.data.style.height
	        + 'px,0)'
	    next.style.display = ''
	    LazyLoad.loadIfNeeded(next)
	  }.bind(this))
	}
	
	Marquee.prototype.attr = {
	  interval: function (value) {
	    this.interval = value
	  },
	  transitionDuration: function (value) {
	    this.transitionDuration = value
	  },
	  delay: function (value) {
	    this.delay = value
	  }
	}
	
	Marquee.prototype.clearAttr = function () {
	  this.interval = 5 * 1000
	  this.transitionDuration = 500
	  this.delay = 0
	}
	
	module.exports = Marquee


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var extend = __webpack_require__(15).extend
	var config = __webpack_require__(13)
	var Component = __webpack_require__(24)
	var ComponentManager = __webpack_require__(17)
	var LazyLoad = __webpack_require__(20)
	__webpack_require__(52)
	__webpack_require__(56)
	
	var DEFAULT_INTERVAL = 3000
	
	function Slider (data) {
	  this.autoPlay = false  // default value is false.
	  this.interval = DEFAULT_INTERVAL
	  this.direction = 'row' // 'column' is not temporarily supported.
	  this.children = []
	  this.isPageShow = true
	  this.isDomRendering = true
	
	  // bind event 'pageshow' and 'pagehide' on window.
	  this._idleWhenPageDisappear()
	  // bind event 'renderBegin' and 'renderEnd' on window.
	  this._idleWhenDomRendering()
	
	  Component.call(this, data)
	}
	
	Slider.prototype = Object.create(Component.prototype)
	
	Slider.prototype._idleWhenPageDisappear = function () {
	  var _this = this
	  window.addEventListener('pageshow', function () {
	    _this.isPageShow = true
	    _this.autoPlay && !_this.isDomRendering && _this.play()
	  })
	  window.addEventListener('pagehide', function () {
	    _this.isPageShow = false
	    _this.stop()
	  })
	}
	
	Slider.prototype._idleWhenDomRendering = function () {
	  var _this = this
	  window.addEventListener('renderend', function () {
	    _this.isDomRendering = false
	    _this.autoPlay && _this.isPageShow && _this.play()
	  })
	  window.addEventListener('renderbegin', function () {
	    _this.isDomRendering = true
	    _this.stop()
	  })
	}
	
	Slider.prototype.attr = {
	  interval: function (val) {
	    this.interval = parseInt(val) || DEFAULT_INTERVAL
	    if (this.carrousel) {
	      this.carrousel.playInterval = this.interval
	    }
	  },
	
	  playstatus: function (val) {
	    this.playstatus = val && val !== 'false' ? true : false
	    this.autoPlay = this.playstatus
	    if (this.carrousel) {
	      if (this.playstatus) {
	        this.play()
	      } else {
	        this.stop()
	      }
	    }
	  },
	
	  // support playstatus' alias auto-play for compatibility
	  autoPlay: function (val) {
	    this.attr.playstatus.call(this, val)
	  }
	}
	
	Slider.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('slider')
	  node.style.position = 'relative'
	  node.style.overflow = 'hidden'
	  return node
	}
	
	Slider.prototype._doRender = function () {
	  var _this = this
	  _this.createChildren()
	  _this.onAppend()
	}
	
	Slider.prototype.removeChild = function (child) {
	  var children = this.data.children
	  if (children) {
	    for (var i = 0; i < children.length; i++) {
	      if (child.data.ref === children[i].ref) {
	        children.splice(i, 1)
	        break
	      }
	    }
	  }
	
	  this._doRender()
	}
	
	Slider.prototype.insertBefore = function (child, before) {
	  var children = this.data.children
	  // var childIndex = this.children.indexOf(before.data)
	  var childIndex = -1
	  for (var i = 0, l = children.length; i < l; i++) {
	    if (children[i].ref === before.data.ref) {
	      childIndex = i
	      break
	    }
	  }
	  children.splice(childIndex, 0, child.data)
	
	  this._doRender()
	  if (this.children.length > 0) {
	    return this.children[this.children.length - 1]
	  }
	}
	
	Slider.prototype.appendChild = function (data) {
	  var children = this.data.children || (this.data.children = [])
	  children.push(data)
	  this._doRender()
	  if (this.children.length > 0) {
	    return this.children[this.children.length - 1]
	  }
	}
	
	Slider.prototype.createChildren = function () {
	
	  var componentManager = this.getComponentManager()
	
	  // recreate slider container.
	  if (this.sliderContainer) {
	    this.node.removeChild(this.sliderContainer)
	  }
	  if (this.indicator) {
	    this.indicator.node.parentNode.removeChild(this.indicator.node)
	  }
	  this.children = []
	
	  var sliderContainer = document.createElement('ul')
	  sliderContainer.style.listStyle = 'none'
	  this.node.appendChild(sliderContainer)
	  this.sliderContainer = sliderContainer
	
	  var children = this.data.children
	  var scale = this.data.scale
	  var fragment = document.createDocumentFragment()
	  var indicatorData, width, height
	  var childWidth = 0
	  var childHeight = 0
	
	  if (children && children.length) {
	    for (var i = 0; i < children.length; i++) {
	      var child
	      children[i].scale = this.data.scale
	      children[i].instanceId = this.data.instanceId
	      if (children[i].type === 'indicator') {
	        indicatorData = extend(children[i], {
	          extra: {
	            amount: children.length - 1,
	            index: 0
	          }
	        })
	      } else {
	        child = componentManager.createElement(children[i], 'li')
	        this.children.push(child)
	        fragment.appendChild(child.node)
	        width = child.data.style.width || 0
	        height = child.data.style.height || 0
	        width > childWidth && (childWidth = width)
	        height > childHeight && (childHeight = height)
	        child.parentRef = this.data.ref
	      }
	    }
	    // append indicator
	    if (indicatorData) {
	      indicatorData.extra.width = this.data.style.width || childWidth
	      indicatorData.extra.height = this.data.style.height || childHeight
	      this.indicator = componentManager.createElement(indicatorData)
	      this.indicator.parentRef = this.data.ref
	      this.indicator.slider = this
	      this.node.appendChild(this.indicator.node)
	    }
	
	    sliderContainer.style.height = scale * this.data.style.height + 'px'
	    sliderContainer.appendChild(fragment)
	  }
	}
	
	Slider.prototype.onAppend = function () {
	  if (this.carrousel) {
	    this.carrousel.removeEventListener('change', this._getSliderChangeHandler())
	    this.carrousel.stop()
	    this.carrousel = null
	  }
	  this.carrousel = new lib.carrousel(this.sliderContainer, {
	    autoplay: this.autoPlay,
	    useGesture: true
	  })
	
	  this.carrousel.playInterval = this.interval
	  this.carrousel.addEventListener('change', this._getSliderChangeHandler())
	  this.currentIndex = 0
	
	  // preload all images for slider
	  // because:
	  // 1. lib-img doesn't listen to event transitionend
	  // 2. even if we fire lazy load in slider's change event handler,
	  //    the next image still won't be preloaded utill the moment it
	  //    slides into the view, which is too late.
	  if (this.preloadImgsTimer) {
	    clearTimeout(this.preloadImgsTimer)
	  }
	  // The time just before the second slide appear and enough
	  // for all child elements to append is ok.
	  var preloadTime = 0.8
	  this.preloadImgsTimer = setTimeout(function () {
	    var imgs = this.carrousel.element.querySelectorAll('.weex-img')
	    for (var i = 0, l = imgs.length; i < l; i++) {
	      var img = imgs[i]
	      var iLazySrc = img.getAttribute('i-lazy-src')
	      var imgSrc = img.getAttribute('img-src')
	      if (iLazySrc) {
	        img.style.backgroundImage = 'url(' + iLazySrc + ')'
	      } else if (imgSrc) {
	        img.style.backgroundImage = 'url(' + imgSrc + ')'
	      }
	      img.removeAttribute('i-lazy-src')
	      img.removeAttribute('img-src')
	    }
	  }.bind(this), preloadTime * 1000)
	
	  // avoid page scroll when panning
	  var panning = false
	  this.carrousel.element.addEventListener('panstart', function (e) {
	    if (!e.isVertical) {
	      panning = true
	    }
	  })
	  this.carrousel.element.addEventListener('panend', function (e) {
	    if (!e.isVertical) {
	      panning = false
	    }
	  })
	
	  document.addEventListener('touchmove', function (e) {
	    if (panning) {
	      e.preventDefault()
	      return false
	    }
	    return true
	  }.bind(this))
	
	}
	
	Slider.prototype._updateIndicators = function () {
	  this.indicator && this.indicator.setIndex(this.currentIndex)
	}
	
	Slider.prototype._getSliderChangeHandler = function (e) {
	  if (!this.sliderChangeHandler) {
	    this.sliderChangeHandler = (function (e) {
	      var index = this.carrousel.items.index
	      this.currentIndex = index
	
	      // updateIndicators
	      this._updateIndicators()
	
	      this.dispatchEvent('change', { index: index })
	    }).bind(this)
	  }
	  return this.sliderChangeHandler
	}
	
	Slider.prototype.play = function () {
	  this.carrousel.play()
	}
	
	Slider.prototype.stop = function () {
	  this.carrousel.stop()
	}
	
	Slider.prototype.slideTo = function (index) {
	  var offset = index - this.currentIndex
	  this.carrousel.items.slide(offset)
	}
	
	module.exports = Slider


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});__webpack_require__(53);__webpack_require__(54);__webpack_require__(55);!function(){var a="[data-ctrl-name=carrousel]{position:relative;-webkit-transform:translateZ(1px);-ms-transform:translateZ(1px);transform:translateZ(1px)}",b=document.createElement("style");if(document.getElementsByTagName("head")[0].appendChild(b),b.styleSheet)b.styleSheet.disabled||(b.styleSheet.cssText=a);else try{b.innerHTML=a}catch(c){b.innerText=a}}();!function(a,b,c){function d(a){var b,c={x:0,y:0},d=getComputedStyle(a)[l+"Transform"];return"none"!==d&&(b=d.match(/^matrix3d\((?:[-\d.]+,\s*){12}([-\d.]+),\s*([-\d.]+)(?:,\s*[-\d.]+){2}\)/)||d.match(/^matrix\((?:[-\d.]+,\s*){4}([-\d.]+),\s*([-\d.]+)\)$/))&&(c.x=parseFloat(b[1])||0,c.y=parseFloat(b[2])||0),c}function e(a,b){return a=parseFloat(a),b=parseFloat(b),0!=a&&(a+="px"),0!=b&&(b+="px"),n?"translate3d("+a+", "+b+", 0)":"translate("+a+", "+b+")"}function f(a){return o.call(a)}function g(a,c){function g(a,b){var c=h.createEvent("HTMLEvents");if(c.initEvent(a,!1,!1),b)for(var d in b)c[d]=b[d];n.dispatchEvent(c)}function i(a){for(;0>a;)a+=r;for(;a>=r;)a-=r;return a}function j(a){if(0!==r){var b,c,d=q.get(a);r>1&&(b=q.get(a-1),c=2===r?q.getCloned(a+1):q.get(a+1),d.style.left=-o+"px",b.style.left=-o-s+"px",c.style.left=-o+s+"px"),t=d.index,g("change",{prevItem:b,curItem:d,nextItem:c})}}var k=this,m=Date.now()+"-"+ ++p,n=document.createDocumentFragment();1!==arguments.length||arguments[0]instanceof HTMLElement||(c=arguments[0],a=null),a||(a=document.createElement("ul"),n.appendChild(a)),c=c||{},a.setAttribute("data-ctrl-name","carrousel"),a.setAttribute("data-ctrl-id",m),a.style.position="relative",a.style[l+"Transform"]=e(0,0);var o=0,q={},r=0,s=c.step||a.getBoundingClientRect().width,t=0;q.add=function(b){var c=document.createElement("li");return c.style.display="none",c.style["float"]="left",c.index=r,"string"==typeof b?c.innerHTML=b:b instanceof HTMLElement&&c.appendChild(b),a.appendChild(c),Object.defineProperty(q,r+"",{get:function(){return c}}),r++,c},q.get=function(a){return q[i(a)]},q.getCloned=function(b){function c(a,b,d){var e=a._listeners;if(e){b._listeners=e;for(var f in e)b.addEventListener(f,e[f])}if(d&&a.children&&a.children.length)for(var g=0,h=a.children.length;h>g;g++)c(a.children[g],b.children[g],d)}var b=i(b),d=a.querySelector('[cloned="cloned-'+b+'"]'),e=q[b];return d||(d=e.cloneNode(!0),c(e,d,!0),a.appendChild(d),d.setAttribute("cloned","cloned-"+b),d.index=b),d},q.slide=function(c){if(0!==r){1===r&&(c=0);var f=d(a).x,g=o+s*-c,h=g-f;if(0!==h){new b.animation(400,b.cubicbezier.ease,function(b,c){a.style[l+"Transform"]=e(f+h*c,0)}).play().then(function(){o=g,a.style[l+"Transform"]=e(g,0),c&&j(t+c)})}}},q.next=function(){q.slide(1)},q.prev=function(){q.slide(-1)},f(a.querySelectorAll("li")).forEach(function(a){a.style.position="absolute",a.style.top="0",a.style.left=r*s+"px",a.style["float"]="left",a.index=r,Object.defineProperty(q,r+"",{get:function(){return a}}),r++}),Object.defineProperty(this,"items",{get:function(){return q}}),Object.defineProperty(q,"length",{get:function(){return r}}),Object.defineProperty(q,"index",{get:function(){return t}}),Object.defineProperty(q,"step",{get:function(){return s},set:function(a){s=a}});var u=!1,v=!1,w=!1;this.play=function(){return u?void(v||(v=setTimeout(function(){w=!0,q.next(),setTimeout(function(){w=!1},500),v=setTimeout(arguments.callee,400+z)},400+z))):(u=!0,j(0))},this.stop=function(){v&&(clearTimeout(v),setTimeout(function(){v=!1},500))};var x=!1,y=!1;Object.defineProperty(this,"autoplay",{get:function(){return x},set:function(a){x=!!a,y&&(clearTimeout(y),y=!1),x?y=setTimeout(function(){k.play()},2e3):k.stop()}}),this.autoplay=!!c.autoplay;var z=1500;if(Object.defineProperty(this,"playInterval",{get:function(){return z},set:function(a){z=a}}),this.playInterval=!!c.playInterval||1500,c.useGesture){var A,B=!1;a.addEventListener("panstart",function(a){a.isVertical||B&&w||(a.preventDefault(),a.stopPropagation(),x&&k.stop(),A=0,B=!0)}),a.addEventListener("panmove",function(b){!b.isVertical&&B&&(b.preventDefault(),b.stopPropagation(),A=b.displacementX,a.style[l+"Transform"]=e(o+A,0))}),a.addEventListener("panend",function(a){!a.isVertical&&B&&(a.preventDefault(),a.stopPropagation(),B=!1,a.isflick?0>A?q.next():q.prev():Math.abs(A)<s/2?q.slide(0):q.slide(0>A?1:-1),x&&setTimeout(function(){k.play()},2e3))},!1),a.addEventListener("swipe",function(a){a.isVertical||(a.preventDefault(),a.stopPropagation())})}this.addEventListener=function(a,b){this.root.addEventListener(a,b,!1)},this.removeEventListener=function(a,b){this.root.removeEventListener(a,b,!1)},this.root=n,this.element=a}var h=a.document,i=a.navigator.userAgent,j=!!i.match(/Firefox/i),k=!!i.match(/IEMobile/i),l=j?"Moz":k?"ms":"webkit",m=k?"MSCSSMatrix":"WebKitCSSMatrix",n=!!j||m in a&&"m11"in new a[m],o=Array.prototype.slice,p=0;b.carrousel=g}(window,window.lib,window.ctrl||(window.ctrl={}));;module.exports = window.lib['carrousel'];

/***/ },
/* 53 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a){return setTimeout(a,l)}function d(a){clearTimeout(a)}function e(){var a={},b=new m(function(b,c){a.resolve=b,a.reject=c});return a.promise=b,a}function f(a,b){return["then","catch"].forEach(function(c){b[c]=function(){return a[c].apply(a,arguments)}}),b}function g(b){var c,d,h=!1;this.request=function(){h=!1;var g=arguments;return c=e(),f(c.promise,this),d=n(function(){h||c&&c.resolve(b.apply(a,g))}),this},this.cancel=function(){return d&&(h=!0,o(d),c&&c.reject("CANCEL")),this},this.clone=function(){return new g(b)}}function h(a,b){"function"==typeof b&&(b={0:b});for(var c=a/l,d=1/c,e=[],f=Object.keys(b).map(function(a){return parseInt(a)}),h=0;c>h;h++){var i=f[0],j=d*h;if(null!=i&&100*j>=i){var k=b[""+i];k instanceof g||(k=new g(k)),e.push(k),f.shift()}else e.length&&e.push(e[e.length-1].clone())}return e}function i(a){var c;return"string"==typeof a||a instanceof Array?b.cubicbezier?"string"==typeof a?b.cubicbezier[a]&&(c=b.cubicbezier[a]):a instanceof Array&&4===a.length&&(c=b.cubicbezier.apply(b.cubicbezier,a)):console.error("require lib.cubicbezier"):"function"==typeof a&&(c=a),c}function j(a,b,c){var d,g=h(a,c),j=1/(a/l),k=0,m=i(b);if(!m)throw new Error("unexcept timing function");var n=!1;this.play=function(){function a(){var c=j*(k+1).toFixed(10),e=g[k];e.request(c.toFixed(10),b(c).toFixed(10)).then(function(){n&&(k===g.length-1?(n=!1,d&&d.resolve("FINISH"),d=null):(k++,a()))},function(){})}if(!n)return n=!0,d||(d=e(),f(d.promise,this)),a(),this},this.stop=function(){return n?(n=!1,g[k]&&g[k].cancel(),this):void 0}}var k=60,l=1e3/k,m=a.Promise||b.promise&&b.promise.ES6Promise,n=window.requestAnimationFrame||window.msRequestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||c,o=window.cancelAnimationFrame||window.msCancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||d;(n===c||o===d)&&(n=c,o=d),b.animation=function(a,b,c){return new j(a,b,c)},b.animation.frame=function(a){return new g(a)},b.animation.requestFrame=function(a){var b=new g(a);return b.request()}}(window,window.lib||(window.lib={}));;module.exports = window.lib['animation'];

/***/ },
/* 54 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a,b,c,d){function e(a){return(3*k*a+2*l)*a+m}function f(a){return((k*a+l)*a+m)*a}function g(a){return((n*a+o)*a+p)*a}function h(a){for(var b,c,d=a,g=0;8>g;g++){if(c=f(d)-a,Math.abs(c)<j)return d;if(b=e(d),Math.abs(b)<j)break;d-=c/b}var h=1,i=0;for(d=a;h>i;){if(c=f(d)-a,Math.abs(c)<j)return d;c>0?h=d:i=d,d=(h+i)/2}return d}function i(a){return g(h(a))}var j=1e-6,k=3*a-3*c+1,l=3*c-6*a,m=3*a,n=3*b-3*d+1,o=3*d-6*b,p=3*b;return i}b.cubicbezier=c,b.cubicbezier.linear=c(0,0,1,1),b.cubicbezier.ease=c(.25,.1,.25,1),b.cubicbezier.easeIn=c(.42,0,1,1),b.cubicbezier.easeOut=c(0,0,.58,1),b.cubicbezier.easeInOut=c(.42,0,.58,1)}(window,window.lib||(window.lib={}));;module.exports = window.lib['cubicbezier'];

/***/ },
/* 55 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a){"use strict";function b(a,b){for(var c=a;c;){if(c.contains(b)||c==b)return c;c=c.parentNode}return null}function c(a,b,c){var d=i.createEvent("HTMLEvents");if(d.initEvent(b,!0,!0),"object"==typeof c)for(var e in c)d[e]=c[e];a.dispatchEvent(d)}function d(a,b,c,d,e,f,g,h){var i=Math.atan2(h-f,g-e)-Math.atan2(d-b,c-a),j=Math.sqrt((Math.pow(h-f,2)+Math.pow(g-e,2))/(Math.pow(d-b,2)+Math.pow(c-a,2))),k=[e-j*a*Math.cos(i)+j*b*Math.sin(i),f-j*b*Math.cos(i)-j*a*Math.sin(i)];return{rotate:i,scale:j,translate:k,matrix:[[j*Math.cos(i),-j*Math.sin(i),k[0]],[j*Math.sin(i),j*Math.cos(i),k[1]],[0,0,1]]}}function e(a){0===Object.keys(l).length&&(j.addEventListener("touchmove",f,!1),j.addEventListener("touchend",g,!1),j.addEventListener("touchcancel",h,!1));for(var d=0;d<a.changedTouches.length;d++){var e=a.changedTouches[d],i={};for(var m in e)i[m]=e[m];var n={startTouch:i,startTime:Date.now(),status:"tapping",element:a.srcElement||a.target,pressingHandler:setTimeout(function(b,d){return function(){"tapping"===n.status&&(n.status="pressing",c(b,"longpress",{touch:d,touches:a.touches,changedTouches:a.changedTouches,touchEvent:a})),clearTimeout(n.pressingHandler),n.pressingHandler=null}}(a.srcElement||a.target,a.changedTouches[d]),500)};l[e.identifier]=n}if(2==Object.keys(l).length){var o=[];for(var m in l)o.push(l[m].element);c(b(o[0],o[1]),"dualtouchstart",{touches:k.call(a.touches),touchEvent:a})}}function f(a){for(var e=0;e<a.changedTouches.length;e++){var f=a.changedTouches[e],g=l[f.identifier];if(!g)return;g.lastTouch||(g.lastTouch=g.startTouch),g.lastTime||(g.lastTime=g.startTime),g.velocityX||(g.velocityX=0),g.velocityY||(g.velocityY=0),g.duration||(g.duration=0);var h=Date.now()-g.lastTime,i=(f.clientX-g.lastTouch.clientX)/h,j=(f.clientY-g.lastTouch.clientY)/h,k=70;h>k&&(h=k),g.duration+h>k&&(g.duration=k-h),g.velocityX=(g.velocityX*g.duration+i*h)/(g.duration+h),g.velocityY=(g.velocityY*g.duration+j*h)/(g.duration+h),g.duration+=h,g.lastTouch={};for(var m in f)g.lastTouch[m]=f[m];g.lastTime=Date.now();var n=f.clientX-g.startTouch.clientX,o=f.clientY-g.startTouch.clientY,p=Math.sqrt(Math.pow(n,2)+Math.pow(o,2));("tapping"===g.status||"pressing"===g.status)&&p>10&&(g.status="panning",g.isVertical=!(Math.abs(n)>Math.abs(o)),c(g.element,"panstart",{touch:f,touches:a.touches,changedTouches:a.changedTouches,touchEvent:a,isVertical:g.isVertical}),c(g.element,(g.isVertical?"vertical":"horizontal")+"panstart",{touch:f,touchEvent:a})),"panning"===g.status&&(g.panTime=Date.now(),c(g.element,"panmove",{displacementX:n,displacementY:o,touch:f,touches:a.touches,changedTouches:a.changedTouches,touchEvent:a,isVertical:g.isVertical}),g.isVertical?c(g.element,"verticalpanmove",{displacementY:o,touch:f,touchEvent:a}):c(g.element,"horizontalpanmove",{displacementX:n,touch:f,touchEvent:a}))}if(2==Object.keys(l).length){for(var q,r=[],s=[],t=[],e=0;e<a.touches.length;e++){var f=a.touches[e],g=l[f.identifier];r.push([g.startTouch.clientX,g.startTouch.clientY]),s.push([f.clientX,f.clientY])}for(var m in l)t.push(l[m].element);q=d(r[0][0],r[0][1],r[1][0],r[1][1],s[0][0],s[0][1],s[1][0],s[1][1]),c(b(t[0],t[1]),"dualtouch",{transform:q,touches:a.touches,touchEvent:a})}}function g(a){if(2==Object.keys(l).length){var d=[];for(var e in l)d.push(l[e].element);c(b(d[0],d[1]),"dualtouchend",{touches:k.call(a.touches),touchEvent:a})}for(var i=0;i<a.changedTouches.length;i++){var n=a.changedTouches[i],o=n.identifier,p=l[o];if(p){if(p.pressingHandler&&(clearTimeout(p.pressingHandler),p.pressingHandler=null),"tapping"===p.status&&(p.timestamp=Date.now(),c(p.element,"tap",{touch:n,touchEvent:a}),m&&p.timestamp-m.timestamp<300&&c(p.element,"doubletap",{touch:n,touchEvent:a}),m=p),"panning"===p.status){var q=Date.now(),r=q-p.startTime,s=((n.clientX-p.startTouch.clientX)/r,(n.clientY-p.startTouch.clientY)/r,n.clientX-p.startTouch.clientX),t=n.clientY-p.startTouch.clientY,u=Math.sqrt(p.velocityY*p.velocityY+p.velocityX*p.velocityX),v=u>.5&&q-p.lastTime<100,w={duration:r,isflick:v,velocityX:p.velocityX,velocityY:p.velocityY,displacementX:s,displacementY:t,touch:n,touches:a.touches,changedTouches:a.changedTouches,touchEvent:a,isVertical:p.isVertical};c(p.element,"panend",w),v&&(c(p.element,"swipe",w),p.isVertical?c(p.element,"verticalswipe",w):c(p.element,"horizontalswipe",w))}"pressing"===p.status&&c(p.element,"pressend",{touch:n,touchEvent:a}),delete l[o]}}0===Object.keys(l).length&&(j.removeEventListener("touchmove",f,!1),j.removeEventListener("touchend",g,!1),j.removeEventListener("touchcancel",h,!1))}function h(a){if(2==Object.keys(l).length){var d=[];for(var e in l)d.push(l[e].element);c(b(d[0],d[1]),"dualtouchend",{touches:k.call(a.touches),touchEvent:a})}for(var i=0;i<a.changedTouches.length;i++){var m=a.changedTouches[i],n=m.identifier,o=l[n];o&&(o.pressingHandler&&(clearTimeout(o.pressingHandler),o.pressingHandler=null),"panning"===o.status&&c(o.element,"panend",{touch:m,touches:a.touches,changedTouches:a.changedTouches,touchEvent:a}),"pressing"===o.status&&c(o.element,"pressend",{touch:m,touchEvent:a}),delete l[n])}0===Object.keys(l).length&&(j.removeEventListener("touchmove",f,!1),j.removeEventListener("touchend",g,!1),j.removeEventListener("touchcancel",h,!1))}var i=a.document,j=i.documentElement,k=Array.prototype.slice,l={},m=null;j.addEventListener("touchstart",e,!1)}(window);;module.exports = window.lib['gesturejs'];

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(57);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./slider.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./slider.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, ".slider {\n  position: relative;\n}\n\n.slider .indicator-container {\n  position: absolute;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-box-align: center;\n  box-align: center;\n  -webkit-align-items: center;\n  align-items: center;\n  -webkit-box-pack: center;\n  box-pack: center;\n  -webkit-justify-content: center;\n  justify-content: center;\n  font-size: 0;\n}\n.slider .indicator-container .indicator {\n  border-radius: 50%;\n}\n.slider .indicator-container.row {\n  -webkit-box-orient: horizontal;\n  box-orient: horizontal;\n  -webkit-flex-direction: row;\n  flex-direction: row;\n}\n.slider .indicator-container.column {\n  -webkit-box-orient: vertical;\n  box-orient: vertical;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n}\n", ""]);
	
	// exports


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var extend = __webpack_require__(15).extend
	var config = __webpack_require__(13)
	var Atomic = __webpack_require__(37)
	var Component = __webpack_require__(24)
	
	__webpack_require__(59)
	
	var DEFAULT_ITEM_COLOR = '#999'
	var DEFAULT_ITEM_SELECTED_COLOR = '#0000ff'
	var DEFAULT_ITEM_SIZE = 20
	var DEFAULT_MARGIN_SIZE = 10
	
	// Style supported:
	//   position: (default - absolute)
	//   itemColor: color of indicator dots
	//   itemSelectedColor: color of the selected indicator dot
	//   itemSize: size of indicators
	//   other layout styles
	function Indicator (data) {
	  this.direction = 'row' // 'column' is not temporarily supported.
	  this.amount = data.extra.amount
	  this.index = data.extra.index
	  this.sliderWidth = data.extra.width
	  this.sliderHeight = data.extra.height
	  var styles = data.style || {}
	  this.data = data
	  this.style.width.call(this, styles.width)
	  this.style.height.call(this, styles.height)
	  this.items = []
	  Atomic.call(this, data)
	}
	
	Indicator.prototype = Object.create(Atomic.prototype)
	
	Indicator.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('weex-indicators')
	  node.classList.add('weex-element')
	  node.style.position = 'absolute'
	  this.node = node
	  this.style.itemSize.call(this, 0)
	  this.itemColor = DEFAULT_ITEM_COLOR
	  this.itemSelectedColor = DEFAULT_ITEM_SELECTED_COLOR
	  this.updateStyle({
	    left: 0,
	    top: 0,
	    itemSize: 0
	  })
	  return node
	}
	
	Indicator.prototype.createChildren = function () {
	  var root = document.createDocumentFragment()
	  for (var i = 0; i < this.amount; i++) {
	    var indicator = document.createElement('div')
	    indicator.classList.add('weex-indicator')
	    indicator.style.boxSizing = 'border-box'
	    indicator.style.margin = '0 '
	                            + (DEFAULT_MARGIN_SIZE * this.data.scale)
	                            + 'px'
	    indicator.style.width = this.itemSize + 'px'
	    indicator.style.height = this.itemSize + 'px'
	    indicator.setAttribute('index', i)
	    if (this.index === i) {
	      indicator.style.backgroundColor = this.itemSelectedColor
	    } else {
	      indicator.style.backgroundColor = this.itemColor
	    }
	    indicator.addEventListener('click', this._clickHandler.bind(this, i))
	    this.items[i] = indicator
	    root.appendChild(indicator)
	  }
	  this.node.appendChild(root)
	}
	
	Indicator.prototype.style
	    = extend(Object.create(Atomic.prototype.style), {
	  itemColor: function (val) {
	    this.itemColor = val || DEFAULT_ITEM_COLOR
	    for (var i = 0, l = this.items.length; i < l; i++) {
	      this.items[i].style.backgroundColor = this.itemColor
	    }
	  },
	
	  itemSelectedColor: function (val) {
	    this.itemSelectedColor = val || DEFAULT_ITEM_SELECTED_COLOR
	    if (typeof this.index !== 'undefined'
	        && this.items.length > this.index) {
	      this.items[this.index].style.backgroundColor
	          = this.itemSelectedColor
	    }
	  },
	
	  itemSize: function (val) {
	    val = parseInt(val) * this.data.scale
	          || DEFAULT_ITEM_SIZE * this.data.scale
	    this.itemSize = val
	    this.node.style.height = val + 'px'
	    for (var i = 0, l = this.items.length; i < l; i++) {
	      this.items[i].style.width = val + 'px'
	      this.items[i].style.height = val + 'px'
	    }
	  },
	
	  width: function (val) {
	    val = parseInt(val) * this.data.scale || parseInt(this.sliderWidth)
	    this.virtualWrapperWidth = val
	  },
	
	  height: function (val) {
	    val = parseInt(val) * this.data.scale || parseInt(this.sliderHeight)
	    this.virtualWrapperHeight = val
	  },
	
	  top: function (val) {
	    val = this.virtualWrapperHeight / 2 - this.itemSize / 2
	        + val * this.data.scale
	    this.node.style.bottom = ''
	    this.node.style.top = val + 'px'
	  },
	
	  bottom: function (val) {
	    val = this.virtualWrapperHeight / 2 - this.itemSize / 2
	        + val * this.data.scale
	    this.node.style.top = ''
	    this.node.style.bottom = val + 'px'
	  },
	
	  left: function (val) {
	    val = this.virtualWrapperWidth / 2
	          - (this.itemSize + 2 * DEFAULT_MARGIN_SIZE * this.data.scale)
	              * this.amount / 2
	          + val * this.data.scale
	    this.node.style.right = ''
	    this.node.style.left = val + 'px'
	  },
	
	  right: function (val) {
	    val = this.virtualWrapperWidth / 2
	          - (this.itemSize + 2 * DEFAULT_MARGIN_SIZE * this.data.scale)
	              * this.amount / 2
	          + val * this.data.scale
	    this.node.style.left = ''
	    this.node.style.right = val + 'px'
	  }
	})
	
	Indicator.prototype.setIndex = function (idx) {
	  if (idx >= this.amount) {
	    return
	  }
	  var prev = this.items[this.index]
	  var cur = this.items[idx]
	  prev.classList.remove('active')
	  prev.style.backgroundColor = this.itemColor
	  cur.classList.add('active')
	  cur.style.backgroundColor = this.itemSelectedColor
	  this.index = idx
	}
	
	Indicator.prototype._clickHandler = function (idx) {
	  this.slider.slideTo(idx)
	}
	
	module.exports = Indicator


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(60);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./indicator.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./indicator.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-indicators {\n  position: absolute;\n  white-space: nowrap;\n}\n.weex-indicators .weex-indicator {\n  float: left;\n  border-radius: 50%;\n}\n", ""]);
	
	// exports


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(37)
	var msgQueue = __webpack_require__(62)
	var config = __webpack_require__(13)
	var utils = __webpack_require__(15)
	
	// TODO: refactor this scss code since this is strongly
	// dependent on lib.flexible other than the value of
	// scale.
	__webpack_require__(63)
	
	function TabHeader(data) {
	  Atomic.call(this, data)
	}
	
	var proto = TabHeader.prototype = Object.create(Atomic.prototype)
	
	proto.create = function () {
	  // outside container.
	  var node = document.createElement('div')
	  node.className = 'tab-header'
	  // tip on the top.
	  var bar = document.createElement('div')
	  bar.className = 'header-bar'
	  bar.textContent = 'CHANGE FLOOR'
	  // middle layer.
	  var body = document.createElement('div')
	  body.className = 'header-body'
	  var box = document.createElement('ul')
	  box.className = 'tabheader'
	
	  body.appendChild(box)
	  node.appendChild(bar)
	  node.appendChild(body)
	  this._bar = bar
	  this._body = body
	  this.box = box
	  this.node = node
	  // init events.
	  this._initFoldBtn()
	  this._initEvent()
	  return node
	}
	
	proto._initFoldBtn = function () {
	  var _this = this
	  var node = this.node
	  var btn = document.createElement('span')
	  btn.className = 'fold-toggle iconfont'
	  btn.innerHTML = '&#xe661;'
	  node.appendChild(btn)
	
	  btn.addEventListener('click', function () {
	    if (_this.unfolding) {
	      _this._folding()
	    } else {
	      _this._unfolding()
	    }
	  })
	}
	
	proto._initMask = function () {
	  var mask = document.createElement('div')
	  mask.className = 'tabheader-mask'
	  this.mask = mask
	  // stop default behavior: page moving.
	  mask.addEventListener('touchmove', function (evt) {
	    evt.preventDefault()
	  })
	  // click to unfold.
	  var _this = this
	  mask.addEventListener('click', function () {
	    _this._folding()
	  })
	
	  document.body.appendChild(mask)
	}
	
	proto._unfolding = function () {
	  // mark the initial posiiton of tabheader
	  if (!this.flag) {
	    var flag = document.createComment('tabheader')
	    this.flag = flag
	    this.node.parentNode.insertBefore(flag, this.node)
	  }
	  if (!this.mask) {
	    this._initMask()
	  }
	
	  // record the scroll position.
	  this._scrollVal = this._body.scrollLeft
	  // record the position in document.
	  this._topVal = this.node.getBoundingClientRect().top
	  this._styleTop = this.node.style.top
	
	  document.body.appendChild(this.node)
	  this.node.classList.add('unfold-header')
	  this.node.style.height = 'auto'
	  // recalc the position when it is unfolded.
	  var thHeight = this.node.getBoundingClientRect().height
	  if (thHeight + this._topVal > window.innerHeight) {
	    this._topVal = this._topVal
	        + (window.innerHeight - thHeight - this._topVal)
	  }
	
	  this.node.style.top = this._topVal + 'px'
	  // process mask style
	  this.mask.classList.add('unfold-header')
	  this.mask.style.height = window.innerHeight + 'px'
	  this.unfolding = true
	}
	
	proto._folding = function () {
	  if (this.unfolding !== true) {
	    return
	  }
	
	  this.mask.classList.remove('unfold-header')
	  this.node.classList.remove('unfold-header')
	
	  this.node.style.height = ''
	  this.node.style.top = this._styleTop
	
	  // recover the position of tabheader.
	  this.flag.parentNode.insertBefore(this.node, this.flag)
	  // recover the position of scoller.
	  this._body.scrollLeft = this._scrollVal
	
	  this._scrollToView()
	  this.unfolding = false
	}
	
	proto._initEvent = function () {
	  this._initClickEvent()
	  this._initSelectEvent()
	}
	
	// init events.
	proto._initClickEvent = function () {
	  var box = this.box
	  var _this = this
	
	  box.addEventListener('click', function (evt) {
	    var target = evt.target
	    if (target.nodeName === 'UL') {
	      return
	    }
	
	    if (target.parentNode.nodeName === 'LI') {
	      target = target.parentNode
	    }
	
	    var floor = target.getAttribute('data-floor')
	
	    if (_this.data.attr.selectedIndex == floor) {
	      // Duplicated clicking, not to trigger select event.
	      return
	    }
	
	    fireEvent(target, 'select', {index:  floor})
	  })
	}
	
	proto._initSelectEvent = function () {
	  var node = this.node
	  var _this = this
	  node.addEventListener('select', function (evt) {
	    var index
	    if (evt.index !== undefined) {
	      index = evt.index
	    } else if (evt.data && evt.data.index !== undefined) {
	      index = evt.data.index
	    }
	
	    if (index === undefined) {
	      return
	    }
	
	    _this.attr.selectedIndex.call(_this, index)
	  })
	}
	
	proto.attr = {
	  highlightIcon: function () {
	    return createHighlightIcon()
	  },
	  data: function () {
	    var attr = this.data.attr
	    // Ensure there is a default selected value.
	    if (attr.selectedIndex === undefined) {
	      attr.selectedIndex = 0
	    }
	
	    var list = attr.data || []
	    var curItem = attr.selectedIndex
	
	    var ret = []
	    var itemTmpl = '<li class="th-item" data-floor="{{floor}}">'
	        + '{{hlIcon}}{{floorName}}</li>'
	
	    list.forEach(function (item, idx) {
	      var html = itemTmpl.replace('{{floor}}', idx)
	      if (curItem == idx) {
	        html = html.replace('{{hlIcon}}', createHighlightIcon())
	      } else {
	        html = html.replace('{{hlIcon}}', '')
	      }
	
	      html = html.replace('{{floorName}}', item)
	
	      ret.push(html)
	    }, this)
	
	    this.box.innerHTML = ret.join('')
	  },
	  selectedIndex: function (val) {
	    var attr = this.data.attr
	
	    if (val === undefined) {
	      val = 0
	    }
	
	    // if (val == attr.selectedIndex) {
	    //   return
	    // }
	
	    attr.selectedIndex = val
	
	    this.attr.data.call(this)
	
	    this._folding()
	    this.style.textHighlightColor.call(this, this.textHighlightColor)
	  }
	}
	
	proto.style = Object.create(Atomic.prototype.style)
	
	proto.style.opacity = function (val) {
	  if (val === undefined || val < 0 || val > 1) {
	    val = 1
	  }
	
	  this.node.style.opacity = val
	}
	
	proto.style.textColor = function (val) {
	  if (!isValidColor(val)) {
	    return
	  }
	
	  this.node.style.color = val
	}
	
	proto.style.textHighlightColor = function (val) {
	  if (!isValidColor(val)) {
	    return
	  }
	  this.textHighlightColor = val
	  var attr = this.data.attr
	
	  var node = this.node.querySelector('[data-floor="'
	      + attr.selectedIndex + '"]')
	  if (node) {
	    node.style.color = val
	    this._scrollToView(node)
	  }
	}
	
	proto._scrollToView = function (node) {
	  if (!node) {
	    var attr = this.data.attr
	    node = this.node.querySelector('[data-floor="' + attr.selectedIndex + '"]')
	  }
	  if (!node) {
	    return
	  }
	
	  var defaultVal = this._body.scrollLeft
	  var leftVal = defaultVal  - node.offsetLeft + 300
	
	  var scrollVal = getScrollVal(this._body.getBoundingClientRect(), node)
	  doScroll(this._body, scrollVal)
	}
	
	// scroll the tabheader.
	// positive val means to scroll right.
	// negative val means to scroll left.
	function doScroll(node, val, finish) {
	  if (!val) {
	    return
	  }
	  if (finish === undefined) {
	    finish = Math.abs(val)
	  }
	
	  if (finish <= 0) {
	    return
	  }
	
	  setTimeout(function () {
	    if (val > 0) {
	      node.scrollLeft += 2
	    } else {
	      node.scrollLeft -= 2
	    }
	    finish -= 2
	
	    doScroll(node, val, finish)
	  })
	}
	
	// get scroll distance.
	function getScrollVal(rect, node) {
	  var left = node.previousSibling
	  var right = node.nextSibling
	  var scrollVal
	
	  // process left-side element first.
	  if (left) {
	    var leftRect = left.getBoundingClientRect()
	    // only need to compare the value of left.
	    if (leftRect.left < rect.left) {
	      scrollVal = leftRect.left
	      return scrollVal
	    }
	  }
	
	  if (right) {
	    var rightRect = right.getBoundingClientRect()
	    // compare the value of right.
	    if (rightRect.right > rect.right) {
	      scrollVal = rightRect.right - rect.right
	      return scrollVal
	    }
	  }
	
	  // process current node, from left to right.
	  var nodeRect = node.getBoundingClientRect()
	  if (nodeRect.left < rect.left) {
	    scrollVal = nodeRect.left
	  } else if (nodeRect.right > rect.right) {
	    scrollVal = nodeRect.right - rect.right
	  }
	
	  return scrollVal
	}
	
	// trigger and broadcast events.
	function fireEvent(element, type, data) {
	  var evt = document.createEvent('Event')
	  evt.data = data
	  utils.extend(evt, data)
	  // need bubble.
	  evt.initEvent(type, true, true)
	
	  element.dispatchEvent(evt)
	}
	
	function createHighlightIcon(code) {
	  var html = '<i class="hl-icon iconfont">' + '&#xe650' + '</i>'
	  return html
	}
	
	function isValidColor(color) {
	  if (!color) {
	    return false
	  }
	
	  if (color.charAt(0) !== '#') {
	    return false
	  }
	
	  if (color.length !== 7) {
	    return false
	  }
	
	  return true
	}
	
	module.exports = TabHeader


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var config = __webpack_require__(13)
	var messageQueue = []
	
	function flushMessage() {
	  if (typeof callJS === 'function' && messageQueue.length > 0) {
	    callJS(config.instanceId, JSON.stringify(messageQueue))
	    messageQueue.length = 0
	  }
	}
	
	function push(msg) {
	  messageQueue.push(msg)
	}
	
	/**
	 * To fix the problem of callapp, the two-way time loop mechanism must
	 * be replaced by directly procedure call except the situation of
	 * page loading.
	 * 2015-11-03
	 */
	function pushDirectly(msg) {
	  callJS(config.instanceId, [msg])
	}
	
	module.exports = {
	  push: pushDirectly
	}


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(64);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./tabheader.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./tabheader.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, ".tab-header {\n  position: relative;\n  width: 10rem;\n  font-size: 14px;\n  color: #333;\n}\n.tab-header .header-bar {\n  height: 1.17rem;\n  line-height: 1.17rem;\n  display: none;\n  color: #999;\n  padding-left: 0.4rem;\n}\n.tab-header .header-body {\n  margin-right: 1.07rem;\n  overflow-x: auto;\n  overflow-y: hidden;\n}\n.tab-header .header-body::-webkit-scrollbar {\n  width: 0;\n  height: 0;\n  overflow: hidden;\n}\n.tab-header .fold-toggle {\n  position: absolute;\n  top: 0.59rem;\n  -webkit-transform: translateY(-50%);\n  right: 0.29rem;\n  width: 0.48rem;\n  height: 0.48rem;\n  line-height: 0.48rem;\n  text-align: center;\n  z-index: 99;\n  font-size: 14px;\n}\n.tab-header.unfold-header {\n  position: fixed !important;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n}\n\n.tabheader {\n  list-style: none;\n  white-space: nowrap;\n  height: 1.17rem;\n  line-height: 1.17rem;\n}\n.tabheader .th-item {\n  padding-left: 0.72rem;\n  position: relative;\n  display: inline-block;\n}\n.tabheader .hl-icon {\n  width: 0.4rem;\n  height: 0.4rem;\n  line-height: 0.4rem;\n  text-align: center;\n  position: absolute;\n  top: 50%;\n  -webkit-transform: translateY(-50%);\n  left: 0.24rem;\n  font-size: 14px;\n}\n\n.unfold-header .header-bar {\n  display: block;\n}\n.unfold-header .fold-toggle {\n  -webkit-transform: translateY(-50%) rotate(180deg);\n}\n.unfold-header .header-body {\n  margin-right: 0;\n  padding: 0.24rem;\n}\n.unfold-header .tabheader {\n  display: block;\n  height: auto;\n}\n.unfold-header .th-item {\n  box-sizing: border-box;\n  float: left;\n  width: 33.3333%;\n  height: 1.01rem;\n  line-height: 1.01rem;\n}\n.unfold-header .hl-icon {\n  margin-right: 0;\n  position: absolute;\n}\n.unfold-header.tabheader-mask {\n  display: block;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.6);\n}\n\n.tabheader-mask {\n  display: none;\n  position: fixed;\n  left: 0;\n  top: 0;\n}\n\n@font-face {\n  font-family: \"iconfont\";\n  src: url(\"data:application/x-font-ttf;charset=utf-8;base64,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R7AEQ7CAYmAgsAArIIqKYSCwAkNgZCOwA0NhZFBYsAJDYRuwA0NgWbADJbCAYmGwAiVGYTgjIDwjOBshICBGI0ewACsjYTghWbEkARQrLbA7LLAuKy6xJAEUKy2wPCywLyshIyAgPLAEI0IjOLEkARQrsARDLrAkKy2wPSywABUgR7AAI0KyAAEBFRQTLrAqKi2wPiywABUgR7AAI0KyAAEBFRQTLrAqKi2wPyyxAAEUE7ArKi2wQCywLSotsEEssAAWRSMgLiBGiiNhOLEkARQrLbBCLLAJI0KwQSstsEMssgAAOistsEQssgABOistsEUssgEAOistsEYssgEBOistsEcssgAAOystsEgssgABOystsEkssgEAOystsEossgEBOystsEsssgAANystsEwssgABNystsE0ssgEANystsE4ssgEBNystsE8ssgAAOSstsFAssgABOSstsFEssgEAOSstsFIssgEBOSstsFMssgAAPCstsFQssgABPCstsFUssgEAPCstsFYssgEBPCstsFcssgAAOCstsFgssgABOCstsFkssgEAOCstsFossgEBOCstsFsssDArLrEkARQrLbBcLLAwK7A0Ky2wXSywMCuwNSstsF4ssAAWsDArsDYrLbBfLLAxKy6xJAEUKy2wYCywMSuwNCstsGEssDErsDUrLbBiLLAxK7A2Ky2wYyywMisusSQBFCstsGQssDIrsDQrLbBlLLAyK7A1Ky2wZiywMiuwNistsGcssDMrLrEkARQrLbBoLLAzK7A0Ky2waSywMyuwNSstsGossDMrsDYrLbBrLCuwCGWwAyRQeLABFTAtAABLuADIUlixAQGOWbkIAAgAYyCwASNEILADI3CwDkUgIEu4AA5RS7AGU1pYsDQbsChZYGYgilVYsAIlYbABRWMjYrACI0SzCgkFBCuzCgsFBCuzDg8FBCtZsgQoCUVSRLMKDQYEK7EGAUSxJAGIUViwQIhYsQYDRLEmAYhRWLgEAIhYsQYBRFlZWVm4Af+FsASNsQUARAAAAA==\") format(\"truetype\");\n}\n.iconfont {\n  font-family: iconfont !important;\n  font-size: 16px;\n  font-style: normal;\n  -webkit-font-smoothing: antialiased;\n  -webkit-text-stroke-width: 0.2px;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n[data-dpr=\"2\"] .tab-header {\n  font-size: 28px;\n}\n\n[data-dpr=\"3\"] .tab-header {\n  font-size: 42px;\n}\n\n[data-dpr=\"2\"] .tabheader .hl-icon {\n  font-size: 28px;\n}\n\n[data-dpr=\"3\"] .tabheader .hl-icon {\n  font-size: 42px;\n}\n\n[data-dpr=\"2\"] .tab-header .fold-toggle {\n  font-size: 28px;\n}\n\n[data-dpr=\"3\"] .tab-header .fold-toggle {\n  font-size: 42px;\n}\n", ""]);
	
	// exports


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	__webpack_require__(66)
	__webpack_require__(45)
	
	// lib.scroll events:
	//  - scrollstart
	//  - scrolling
	//  - pulldownend
	//  - pullupend
	//  - pullleftend
	//  - pullrightend
	//  - pulldown
	//  - pullup
	//  - pullleft
	//  - pullright
	//  - contentrefresh
	
	var Component = __webpack_require__(24)
	var utils = __webpack_require__(15)
	
	var directionMap = {
	  h: ['row', 'horizontal', 'h', 'x'],
	  v: ['column', 'vertical', 'v', 'y']
	}
	
	var DEFAULT_DIRECTION = 'column'
	
	// attrs:
	//  - scroll-direciton: none|vertical|horizontal (default is vertical)
	//  - show-scrollbar: true|false (default is true)
	function Scroller (data, nodeType) {
	  var attrs = data.attr || {}
	  var direction = attrs.scrollDirection
	    || attrs.direction
	    || DEFAULT_DIRECTION
	  this.direction = directionMap.h.indexOf(direction) === -1
	    ? 'v'
	    : 'h'
	  this.showScrollbar = attrs.showScrollbar || true
	  Component.call(this, data, nodeType)
	}
	
	Scroller.prototype = Object.create(Component.prototype)
	
	Scroller.prototype.create = function (nodeType) {
	  var Scroll = lib.scroll
	  var node = Component.prototype.create.call(this, nodeType)
	  node.classList.add('weex-container', 'scroll-wrap')
	  this.scrollElement = document.createElement('div')
	  this.scrollElement.classList.add(
	    'weex-container',
	    'scroll-element',
	    this.direction + '-scroller'
	  )
	
	  // Flex will cause a bug to rescale children's size if their total
	  // size exceed the limit of their parent. So to use box instead.
	  this.scrollElement.style.display = '-webkit-box'
	  this.scrollElement.style.display = 'box'
	  this.scrollElement.style.webkitBoxOrient = this.direction === 'h'
	    ? 'horizontal'
	    : 'vertical'
	  this.scrollElement.style.boxOrient = this.scrollElement.style.webkitBoxOrient
	
	  node.appendChild(this.scrollElement)
	  this.scroller = new Scroll({
	    // if the direction is x, then the bounding rect of the scroll element
	    // should be got by the 'Range' API other than the 'getBoundingClientRect'
	    // API, because the width outside the viewport won't be count in by
	    // 'getBoundingClientRect'.
	    // Otherwise should use the element rect in case there is a child scroller
	    // or list in this scroller. If using 'Range', the whole scroll element
	    // including the hiding part will be count in the rect.
	    useElementRect: this.direction === 'v',
	    scrollElement: this.scrollElement,
	    direction: this.direction === 'h' ? 'x' : 'y'
	  })
	  this.scroller.init()
	  this.offset = 0
	  return node
	}
	
	Scroller.prototype.bindEvents = function (evts) {
	  Component.prototype.bindEvents.call(this, evts)
	  // to enable lazyload for Images
	  this.scroller.addEventListener('scrolling', function (e) {
	    var so = e.scrollObj
	    var scrollTop = so.getScrollTop()
	    var scrollLeft = so.getScrollLeft()
	    var offset = this.direction === 'v' ? scrollTop : scrollLeft
	    var diff = offset - this.offset
	    var dir
	    if (diff >= 0) {
	      dir = this.direction === 'v' ? 'up' : 'left'
	    } else {
	      dir = this.direction === 'v' ? 'down' : 'right'
	    }
	    this.dispatchEvent('scroll', {
	      originalType: 'scrolling',
	      scrollTop: so.getScrollTop(),
	      scrollLeft: so.getScrollLeft(),
	      offset: offset,
	      direction: dir
	    }, {
	      bubbles: true
	    })
	    this.offset = offset
	  }.bind(this))
	
	  var pullendEvent = 'pull'
	    + ({ v: 'up', h: 'left' })[this.direction]
	    + 'end'
	  this.scroller.addEventListener(pullendEvent, function (e) {
	    this.dispatchEvent('loadmore')
	  }.bind(this))
	}
	
	Scroller.prototype.createChildren = function () {
	  var children = this.data.children
	  var parentRef = this.data.ref
	  var componentManager = this.getComponentManager()
	  if (children && children.length) {
	    var fragment = document.createDocumentFragment()
	    var isFlex = false
	    for (var i = 0; i < children.length; i++) {
	      children[i].instanceId = this.data.instanceId
	      children[i].scale = this.data.scale
	      var child = componentManager.createElement(children[i])
	      fragment.appendChild(child.node)
	      child.parentRef = parentRef
	      if (!isFlex
	          && child.data.style
	          && child.data.style.hasOwnProperty('flex')
	        ) {
	        isFlex = true
	      }
	    }
	    this.scrollElement.appendChild(fragment)
	  }
	  // wait for fragment to appended on scrollElement on UI thread.
	  setTimeout(function () {
	    this.scroller.refresh()
	  }.bind(this), 0)
	}
	
	Scroller.prototype.appendChild = function (data) {
	  var children = this.data.children
	  var componentManager = this.getComponentManager()
	  var child = componentManager.createElement(data)
	  this.scrollElement.appendChild(child.node)
	
	  // wait for UI thread to update.
	  setTimeout(function () {
	    this.scroller.refresh()
	  }.bind(this), 0)
	
	  // update this.data.children
	  if (!children || !children.length) {
	    this.data.children = [data]
	  } else {
	    children.push(data)
	  }
	
	  return child
	}
	
	Scroller.prototype.insertBefore = function (child, before) {
	  var children = this.data.children
	  var i = 0
	  var isAppend = false
	
	  // update this.data.children
	  if (!children || !children.length || !before) {
	    isAppend = true
	  } else {
	    for (var l = children.length; i < l; i++) {
	      if (children[i].ref === before.data.ref) {
	        break
	      }
	    }
	    if (i === l) {
	      isAppend = true
	    }
	  }
	
	  if (isAppend) {
	    this.scrollElement.appendChild(child.node)
	    children.push(child.data)
	  } else {
	    if (before.fixedPlaceholder) {
	      this.scrollElement.insertBefore(child.node, before.fixedPlaceholder)
	    } else {
	      this.scrollElement.insertBefore(child.node, before.node)
	    }
	    children.splice(i, 0, child.data)
	  }
	
	  // wait for UI thread to update.
	  setTimeout(function () {
	    this.scroller.refresh()
	  }.bind(this), 0)
	}
	
	Scroller.prototype.removeChild = function (child) {
	  var children = this.data.children
	  // remove from this.data.children
	  var i = 0
	  var componentManager = this.getComponentManager()
	  if (children && children.length) {
	    for (var l = children.length; i < l; i++) {
	      if (children[i].ref === child.data.ref) {
	        break
	      }
	    }
	    if (i < l) {
	      children.splice(i, 1)
	    }
	  }
	  // remove from componentMap recursively
	  componentManager.removeElementByRef(child.data.ref)
	  if (child.fixedPlaceholder) {
	    this.scrollElement.removeChild(child.fixedPlaceholder)
	  }
	  child.node.parentNode.removeChild(child.node)
	
	  // wait for UI thread to update.
	  setTimeout(function () {
	    this.scroller.refresh()
	  }.bind(this), 0)
	}
	
	module.exports = Scroller


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(67);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./scroller.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./scroller.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, ".scroll-wrap {\n  display: block;\n  overflow: hidden;\n}\n\n.scroll-element.horizontal {\n  -webkit-box-orient: horizontal;\n  -webkit-flex-direction: row;\n  flex-direction: row;\n}\n.scroll-element.vertical {\n  -webkit-box-orient: vertical;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n}\n", ""]);
	
	// exports


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(37)
	var utils = __webpack_require__(15)
	
	// attrs:
	//   - type: text|password|tel|email|url
	//   - value
	//   - placeholder
	//   - disabled
	//   - autofocus
	function Input (data) {
	  var attrs = data.attr || {}
	  this.type = attrs.type || 'text'
	  this.value = attrs.value
	  this.placeholder = attrs.placeholder
	  this.autofocus = attrs.autofocus && (attrs.autofocus !== 'false')
	                    ? true
	                    : false
	  Atomic.call(this, data)
	}
	
	Input.prototype = Object.create(Atomic.prototype)
	
	Input.prototype.create = function () {
	  var node = document.createElement('input')
	  var uuid = Math.floor(10000000000000 * Math.random()) + Date.now()
	  this.className = 'weex-ipt-' + uuid
	  this.styleId = 'weex-style-' + uuid
	  node.classList.add(this.className)
	  node.setAttribute('type', this.type)
	  node.type = this.type
	  // For the consistency of input component's width.
	  // The date and time type of input will have a bigger width
	  // when the 'box-sizing' is not set to 'border-box'
	  node.classList.add('weex-element')
	  this.value && (node.value = this.value)
	  this.placeholder && (node.placeholder = this.placeholder)
	  return node
	}
	
	Input.prototype.updateStyle = function (style) {
	  Atomic.prototype.updateStyle.call(this, style)
	  if (style && style.placeholderColor) {
	    this.placeholderColor = style.placeholderColor
	    this.setPlaceholderColor()
	  }
	}
	
	Input.prototype.attr = {
	  disabled: function (val) {
	    this.node.disabled = val && val !== 'false'
	                    ? true
	                    : false
	  }
	}
	
	Input.prototype.setPlaceholderColor = function () {
	  if (!this.placeholderColor) {
	    return
	  }
	  var vendors = [
	    '::-webkit-input-placeholder',
	    ':-moz-placeholder',
	    '::-moz-placeholder',
	    ':-ms-input-placeholder',
	    ':placeholder-shown'
	  ]
	  var css = ''
	  var cssRule = 'color: ' + this.placeholderColor + ';'
	  for (var i = 0, l = vendors.length; i < l; i++) {
	    css += '.' + this.className + vendors[i] + '{'
	           + cssRule + '}'
	  }
	  utils.appendStyle(css, this.styleId, true)
	}
	
	module.exports = Input


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(24)
	var sender = __webpack_require__(28)
	
	// attrs:
	//   - options: the options to be listed, as a array of strings.
	//   - selectedIndex: the selected options' index number.
	//   - disabled
	function Select (data) {
	  var attrs = data.attr || {}
	  this.options = []
	  this.selectedIndex = 0
	  Atomic.call(this, data)
	}
	
	Select.prototype = Object.create(Atomic.prototype)
	
	Select.prototype.create = function () {
	  var node = document.createElement('select')
	  var uuid = Math.floor(10000000000000 * Math.random()) + Date.now()
	  this.className = 'weex-slct-' + uuid
	  this.styleId = 'weex-style-' + uuid
	  node.classList.add(this.className)
	  // For the consistency of input component's width.
	  // The date and time type of input will have a bigger width
	  // when the 'box-sizing' is not set to 'border-box'
	  node.style['box-sizing'] = 'border-box'
	  return node
	}
	
	Select.prototype.attr = {
	  disabled: function (val) {
	    this.node.disabled = val && val !== 'false'
	                    ? true
	                    : false
	  },
	  options: function (val) {
	    if (Object.prototype.toString.call(val) !== '[object Array]') {
	      return
	    }
	    this.options = val
	    this.node.innerHTML = ''
	    this.createOptions(val)
	  },
	  selectedIndex: function (val) {
	    val = parseInt(val)
	    if (typeof val !== 'number' || val !== val || val >= this.options.length) {
	      return
	    }
	    this.node.value = this.options[val]
	  }
	}
	
	Select.prototype.bindEvents = function (evts) {
	  var isListenToChange = false
	  Atomic.prototype.bindEvents.call(
	      this,
	      evts.filter(function (val) {
	        var pass = val !== 'change'
	        !pass && (isListenToChange = true)
	        return pass
	      }))
	  if (isListenToChange) {
	    this.node.addEventListener('change', function (e) {
	      e.index = this.options.indexOf(this.node.value)
	      sender.fireEvent(this.data.ref, 'change', e)
	    }.bind(this))
	  }
	}
	
	Select.prototype.createOptions = function (opts) {
	  var optDoc = document.createDocumentFragment()
	  var opt
	  for (var i = 0, l = opts.length; i < l; i++) {
	    opt = document.createElement('option')
	    opt.appendChild(document.createTextNode(opts[i]))
	    optDoc.appendChild(opt)
	  }
	  this.node.appendChild(optDoc)
	}
	
	module.exports = Select


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(37)
	
	// attrs:
	//   - value
	//   - disabled
	function Datepicker (data) {
	  Atomic.call(this, data)
	}
	
	Datepicker.prototype = Object.create(Atomic.prototype)
	
	Datepicker.prototype.create = function () {
	  var node = document.createElement('input')
	  var uuid = Math.floor(10000000000000 * Math.random()) + Date.now()
	  this.className = 'weex-ipt-' + uuid
	  this.styleId = 'weex-style-' + uuid
	  node.classList.add(this.className)
	  node.setAttribute('type', 'date')
	  node.type = 'date'
	  // For the consistency of input component's width.
	  // The date and time type of input will have a bigger width
	  // when the 'box-sizing' is not set to 'border-box'
	  node.classList.add('weex-element')
	  return node
	}
	
	Datepicker.prototype.attr = {
	  disabled: function (val) {
	    this.node.disabled = val && val !== 'false'
	                    ? true
	                    : false
	  }
	}
	
	module.exports = Datepicker


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(37)
	
	// attrs:
	//   - value
	//   - disabled
	function Timepicker (data) {
	  Atomic.call(this, data)
	}
	
	Timepicker.prototype = Object.create(Atomic.prototype)
	
	Timepicker.prototype.create = function () {
	  var node = document.createElement('input')
	  var uuid = Math.floor(10000000000000 * Math.random()) + Date.now()
	  this.className = 'weex-ipt-' + uuid
	  this.styleId = 'weex-style-' + uuid
	  node.classList.add(this.className)
	  node.setAttribute('type', 'time')
	  node.type = 'time'
	  // For the consistency of input component's width.
	  // The date and time type of input will have a bigger width
	  // when the 'box-sizing' is not set to 'border-box'
	  node.classList.add('weex-element')
	  return node
	}
	
	Timepicker.prototype.attr = {
	  disabled: function (val) {
	    this.node.disabled = val && val !== 'false'
	                    ? true
	                    : false
	  }
	}
	
	module.exports = Timepicker


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(37)
	var utils = __webpack_require__(15)
	__webpack_require__(73)
	
	// attrs:
	//   - autoPlay: true | false (default: false)
	//   - playStatus: play | pause | stop
	//   - src: {string}
	//   - poster: {string}
	//   - loop: true | false (default: false)
	//   - muted: true | false (default: false)
	// events:
	//   - start
	//   - pause
	//   - finish
	//   - fail
	function Video (data) {
	  var autoPlay = data.attr.autoPlay
	  var playStatus = data.attr.playStatus
	  this.autoPlay = autoPlay === true || autoPlay === 'true'
	  if (playStatus !== 'play'
	      && playStatus !== 'stop'
	      && playStatus !== 'pause') {
	    this.playStatus = 'pause'
	  } else {
	    this.playStatus = playStatus
	  }
	  Atomic.call(this, data)
	}
	
	Video.prototype = Object.create(Atomic.prototype)
	
	Video.prototype.attr = {
	  playStatus: function (val) {
	    if (val !== 'play' && val !== 'stop' && val !== 'pause') {
	      val = 'pause'
	    }
	    if (this.playStatus === val) {
	      return
	    }
	    this.playStatus = val
	    this.node.setAttribute('play-status', val)
	    this[this.playStatus]()
	  },
	  autoPlay: function (val) {
	    // DO NOTHING
	  }
	}
	
	Video.prototype.create = function () {
	  var node = document.createElement('video')
	  node.classList.add('weex-video', 'weex-element')
	  node.controls = true
	  node.autoplay = this.autoPlay
	  node.setAttribute('play-status', this.playStatus)
	  this.node = node
	  if (this.autoPlay && this.playStatus === 'play') {
	    this.play()
	  }
	  return node
	}
	
	Video.prototype.bindEvents = function (evts) {
	  Atomic.prototype.bindEvents.call(this, evts)
	
	  // convert w3c-video events to weex-video events.
	  var evtsMap = {
	    start: 'play',
	    finish: 'ended',
	    fail: 'error'
	  }
	  for (var evtName in evtsMap) {
	    this.node.addEventListener(evtsMap[evtName], function (type, e) {
	      this.dispatchEvent(type, e.data)
	    }.bind(this, evtName))
	  }
	}
	
	Video.prototype.play = function () {
	  var src = this.node.getAttribute('src')
	  if (!src) {
	    src = this.node.getAttribute('data-src')
	    src && this.node.setAttribute('src', src)
	  }
	  this.node.play()
	}
	
	Video.prototype.pause = function () {
	  this.node.pause()
	}
	
	Video.prototype.stop = function () {
	  this.node.pause()
	  this.node.autoplay = false
	  this.node.setAttribute('data-src', this.node.src)
	  this.node.src = ''
	}
	
	module.exports = Video


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(74);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./video.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./video.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-video {\n\tbackground-color: #000;\n}", ""]);
	
	// exports


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(37)
	var utils = __webpack_require__(15)
	__webpack_require__(76)
	
	var defaults = {
	  color: '#64bd63'
	  , secondaryColor: '#dfdfdf'
	  , jackColor: '#fff'
	  , jackSecondaryColor: null
	  , className: 'weex-switch'
	  , disabledOpacity: 0.5
	  , speed: '0.4s'
	  , width: 100
	  , height: 60
	  // is width and height scalable ?
	  , scalable: false
	}
	
	// attrs:
	//   - checked: if is checked.
	//   - disabled: if true, this component is not available for interaction.
	function Switch (data) {
	  this.options = utils.extend({}, defaults)
	  this.checked = data.attr.checked
	      && data.attr.checked !== 'false' ? true : false
	  this.data = data
	  this.width = this.options.width * data.scale
	  this.height = this.options.height * data.scale
	  Atomic.call(this, data)
	}
	
	Switch.prototype = Object.create(Atomic.prototype)
	
	Switch.prototype.create = function () {
	  var node = document.createElement('span')
	  this.jack = document.createElement('small')
	  node.appendChild(this.jack)
	  node.className = this.options.className
	  this.node = node
	  this.attr.disabled.call(this, this.data.attr.disabled)
	  return node
	}
	
	Switch.prototype.onAppend = function () {
	  this.setSize()
	  this.setPosition()
	}
	
	Switch.prototype.attr = {
	  disabled: function (val) {
	    this.disabled = val && val !== 'false'
	                    ? true
	                    : false
	    this.disabled ? this.disable() : this.enable()
	  }
	}
	
	Switch.prototype.setSize = function () {
	  var min = Math.min(this.width, this.height)
	  var max = Math.max(this.width, this.height)
	  this.node.style.width = max + 'px'
	  this.node.style.height = min + 'px'
	  this.node.style.borderRadius = min / 2 + 'px'
	  this.jack.style.width
	      = this.jack.style.height
	      = min + 'px'
	}
	
	Switch.prototype.setPosition = function (clicked) {
	  var checked = this.checked
	  var node = this.node
	  var jack = this.jack
	
	  if (clicked && checked) {
	    checked = false
	  } else if (clicked && !checked) {
	    checked = true
	  }
	
	  if (checked === true) {
	    this.checked = true
	
	    if (window.getComputedStyle) {
	      jack.style.left = parseInt(window.getComputedStyle(node).width)
	                        - parseInt(window.getComputedStyle(jack).width) + 'px'
	    } else {
	      jack.style.left = parseInt(node.currentStyle['width'])
	                        - parseInt(jack.currentStyle['width']) + 'px'
	    }
	
	    this.options.color && this.colorize()
	    this.setSpeed()
	  } else {
	    this.checked = false
	    jack.style.left = 0
	    node.style.boxShadow = 'inset 0 0 0 0 ' + this.options.secondaryColor
	    node.style.borderColor = this.options.secondaryColor
	    node.style.backgroundColor
	        = (this.options.secondaryColor !== defaults.secondaryColor)
	          ? this.options.secondaryColor
	          : '#fff'
	    jack.style.backgroundColor
	        = (this.options.jackSecondaryColor !== this.options.jackColor)
	          ? this.options.jackSecondaryColor
	          : this.options.jackColor
	    this.setSpeed()
	  }
	}
	
	Switch.prototype.colorize = function () {
	  var nodeHeight = this.node.offsetHeight / 2
	
	  this.node.style.backgroundColor = this.options.color
	  this.node.style.borderColor = this.options.color
	  this.node.style.boxShadow = 'inset 0 0 0 '
	                              + nodeHeight
	                              + 'px '
	                              + this.options.color
	  this.jack.style.backgroundColor = this.options.jackColor
	}
	
	Switch.prototype.setSpeed = function () {
	  var switcherProp = {}
	  var jackProp = {
	      'background-color': this.options.speed
	      , left: this.options.speed.replace(/[a-z]/, '') / 2 + 's'
	    }
	
	  if (this.checked) {
	    switcherProp = {
	      border: this.options.speed
	      , 'box-shadow': this.options.speed
	      , 'background-color': this.options.speed.replace(/[a-z]/, '') * 3 + 's'
	    }
	  } else {
	    switcherProp = {
	      border: this.options.speed
	      , 'box-shadow': this.options.speed
	    }
	  }
	
	  utils.transitionize(this.node, switcherProp)
	  utils.transitionize(this.jack, jackProp)
	}
	
	Switch.prototype.disable = function () {
	  !this.disabled && (this.disabled = true)
	  this.node.style.opacity = defaults.disabledOpacity
	  this.node.removeEventListener('click', this.getClickHandler())
	}
	
	Switch.prototype.enable = function () {
	  this.disabled && (this.disabled = false)
	  this.node.style.opacity = 1
	  this.node.addEventListener('click', this.getClickHandler())
	}
	
	Switch.prototype.getClickHandler = function () {
	  if (!this._clickHandler) {
	    this._clickHandler = function () {
	      // var parent = this.node.parentNode.tagName.toLowerCase()
	      // var labelParent = (parent === 'label') ? false : true
	      this.setPosition(true)
	      this.dispatchEvent('change', {
	        checked: this.checked
	      })
	    }.bind(this)
	  }
	  return this._clickHandler
	}
	
	Switch.prototype.style
	    = utils.extend(Object.create(Atomic.prototype.style), {
	
	      width: function (val) {
	        if (!this.options.scalable) {
	          return
	        }
	        val = parseFloat(val)
	        if (val !== val || val < 0) { // NaN
	          val = this.options.width
	        }
	        this.width = val * this.data.scale
	        this.setSize()
	      },
	
	      height: function (val) {
	        if (!this.options.scalable) {
	          return
	        }
	        val = parseFloat(val)
	        if (val !== val || val < 0) { // NaN
	          val = this.options.height
	        }
	        this.height = val * this.data.scale
	        this.setSize()
	      }
	
	    })
	
	module.exports = Switch


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(77);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./switch.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./switch.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, "/* switch defaults. */\n.weex-switch {\n  background-color: #fff;\n  border: 1px solid #dfdfdf;\n  cursor: pointer;\n  display: inline-block;\n  position: relative;\n  vertical-align: middle;\n  -moz-user-select: none;\n  -khtml-user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  box-sizing: content-box;\n  background-clip: content-box;\n}\n\n.weex-switch > small {\n  background: #fff;\n  border-radius: 100%;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);\n  position: absolute;\n  top: 0;\n}\n", ""]);
	
	// exports


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(32)
	var Component = __webpack_require__(24)
	
	// attrs:
	//   - href
	function A (data) {
	  Component.call(this, data)
	}
	
	A.prototype = Object.create(Component.prototype)
	
	A.prototype.create = function () {
	  var node = document.createElement('a')
	  node.classList.add('weex-container')
	  node.style.textDecoration = 'none'
	  return node
	}
	
	A.prototype.attr = {
	  href: function (val) {
	    if (!val) {
	      return logger.warn('href of <a> should not be a null value.')
	    }
	    this.href = val
	    this.node.setAttribute('data-href', val)
	  }
	}
	
	A.prototype.bindEvents = function (evts) {
	  // event handler for click event will be processed
	  // before the url redirection.
	  Component.prototype.bindEvents.call(this, evts)
	  this.node.addEventListener('click', function (evt) {
	    if (evt._alreadyFired && evt.target !== this.node) {
	      // if the event target is this.node, then this is
	      // just another click event handler for the same
	      // target, not a handler for a bubbling up event,
	      // otherwise it is a bubbling up event, and it
	      // should be disregarded.
	      return
	    }
	    evt._alreadyFired = true
	    location.href = this.href
	  }.bind(this))
	}
	
	module.exports = A


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Component = __webpack_require__(24)
	var utils = __webpack_require__(15)
	
	var ID_PREFIX = 'weex_embed_'
	
	function _generateId() {
	  return ID_PREFIX + utils.getRandom(10)
	}
	
	function Embed (data, nodeType) {
	  var attr = data.attr
	  if (attr) {
	    this.source = attr.src
	    this.loader = attr.loader || 'xhr'
	    this.jsonpCallback = attr.jsonpCallback
	  }
	  Component.call(this, data, nodeType)
	}
	
	Embed.prototype = Object.create(Component.prototype)
	
	Embed.prototype.create = function () {
	  var node = document.createElement('div')
	  node.id = this.id
	  node.style.overflow = 'scroll'
	  return node
	}
	
	Embed.prototype.initWeex = function () {
	  this.id = _generateId()
	  this.node.id = this.id
	  var config = {
	    appId: this.id,
	    source: this.source,
	    bundleUrl: this.source,
	    loader: this.loader,
	    jsonpCallback: this.jsonpCallback,
	    width: this.node.getBoundingClientRect().width,
	    rootId: this.id,
	    embed: true
	  }
	  window.weex.init(config)
	}
	
	Embed.prototype.destroyWeex = function () {
	  this.id && window.destroyInstance(this.id)
	  // TODO: unbind events and clear doms.
	  this.node.innerHTML = ''
	}
	
	Embed.prototype.reloadWeex = function () {
	  if (this.id) {
	    this.destroyWeex()
	    this.id = null
	    this.node.id = null
	    this.node.innerHTML = ''
	  }
	  this.initWeex()
	}
	
	// not recommended, because of the leak of memory.
	Embed.prototype.attr = {
	  src: function (value) {
	    this.source = value
	    this.reloadWeex()
	  }
	}
	
	module.exports = Embed


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Component = __webpack_require__(24)
	
	__webpack_require__(81)
	
	var parents = ['scroller', 'list']
	
	// Only if pulldown offset is larger than this value can this
	// component trigger the 'refresh' event, otherwise just recover
	// to the start point.
	var CLAMP = 130
	
	var ua = window.navigator.userAgent
	var Firefox = !!ua.match(/Firefox/i)
	var IEMobile = !!ua.match(/IEMobile/i)
	var cssPrefix = Firefox ? '-moz-' : IEMobile ? '-ms-' : '-webkit-'
	
	function Refresh (data) {
	  Component.call(this, data)
	}
	
	Refresh.prototype = Object.create(Component.prototype)
	
	Refresh.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('weex-container', 'weex-refresh')
	  return node
	}
	
	Refresh.prototype.onAppend = function () {
	  var parent = this.getParent()
	  var self = this
	  if (parents.indexOf(parent.data.type) === -1) {
	    return
	  }
	  parent.scroller.addEventListener('pulldown', function (e) {
	    self.adjustHeight(Math.abs(e.scrollObj.getScrollTop()))
	    if (!this.display) {
	      self.show()
	    }
	  })
	  parent.scroller.addEventListener('pulldownend', function (e) {
	    var top = Math.abs(e.scrollObj.getScrollTop())
	    if (top > CLAMP) {
	      self.handleRefresh(e)
	    }
	  })
	}
	
	Refresh.prototype.adjustHeight = function (val) {
	  this.node.style.height = val + 'px'
	  this.node.style.top = -val + 'px'
	}
	
	Refresh.prototype.handleRefresh = function (e) {
	  var scrollObj = e.scrollObj
	  var parent = this.getParent()
	  var scrollElement = parent.scrollElement || parent.listElement
	  this.node.style.height = CLAMP + 'px'
	  this.node.style.top = -CLAMP + 'px'
	  var translateStr = 'translate3d(0px,' + CLAMP + 'px,0px)'
	  scrollElement.style[cssPrefix + 'transform']
	    = cssPrefix + translateStr
	  scrollElement.style.transform = translateStr
	  this.dispatchEvent('refresh')
	}
	
	Refresh.prototype.show = function () {
	  this.display = true
	  this.node.style.display = '-webkit-box'
	  this.node.style.display = '-webkit-flex'
	  this.node.style.display = 'flex'
	}
	
	Refresh.prototype.hide = function () {
	  this.display = false
	  var parent = this.getParent()
	  if (parent) {
	    var scrollElement = parent.scrollElement || parent.listElement
	    var translateStr = 'translate3d(0px,0px,0px)'
	    scrollElement.style[cssPrefix + 'transform']
	      = cssPrefix + translateStr
	    scrollElement.style.transform = translateStr
	  }
	  this.node.style.display = 'none'
	}
	
	Refresh.prototype.attr = {
	  display: function (val) {
	    if (val === 'show') {
	      setTimeout(function () {
	        this.show()
	      }.bind(this), 0)
	    } else if (val === 'hide') {
	      setTimeout(function () {
	        this.hide()
	      }.bind(this), 0)
	    } else {
	      // TODO
	      console.error('h5render:attribute value of refresh \'display\' '
	          + val
	          + ' is invalid. Should be \'show\' or \'hide\'')
	    }
	  }
	}
	
	module.exports = Refresh


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(82);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./refresh.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./refresh.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-refresh {\n  // -webkit-box-align: center;\n  // -webkit-align-items: center;\n  // align-items: center;\n  // -webkit-box-pack: center;\n  // -webkit-justify-content: center;\n  // justify-content: center;\n  overflow: hidden;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 0;\n}", ""]);
	
	// exports


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Component = __webpack_require__(24)
	
	__webpack_require__(84)
	
	var parents = ['scroller', 'list']
	
	var DEFAULT_HEIGHT = 130
	
	var ua = window.navigator.userAgent
	var Firefox = !!ua.match(/Firefox/i)
	var IEMobile = !!ua.match(/IEMobile/i)
	var cssPrefix = Firefox ? '-moz-' : IEMobile ? '-ms-' : '-webkit-'
	
	function Loading (data) {
	  Component.call(this, data)
	}
	
	Loading.prototype = Object.create(Component.prototype)
	
	Loading.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('weex-container', 'weex-loading')
	  return node
	}
	
	Loading.prototype.onAppend = function () {
	  var parent = this.getParent()
	  var self = this
	  var scrollWrapHeight = parent.node.getBoundingClientRect().height
	  if (parents.indexOf(parent.data.type) === -1) {
	    return
	  }
	  parent.scroller.addEventListener('pullup', function (e) {
	    var obj = e.scrollObj
	    self.adjustHeight(Math.abs(
	      obj.getScrollHeight() - obj.getScrollTop() - scrollWrapHeight))
	    if (!self.display) {
	      self.show()
	    }
	  })
	  parent.scroller.addEventListener('pullupend', function (e) {
	    self.handleLoading(e)
	  })
	}
	
	Loading.prototype.adjustHeight = function (val) {
	  this.node.style.height = val + 'px'
	  this.node.style.bottom = -val + 'px'
	}
	
	Loading.prototype.handleLoading = function (e) {
	  var parent = this.getParent()
	  var scrollElement = parent.scrollElement || parent.listElement
	  var offset = scrollElement.getBoundingClientRect().height
	            - parent.node.getBoundingClientRect().height
	            + DEFAULT_HEIGHT
	  this.node.style.height = DEFAULT_HEIGHT + 'px'
	  this.node.style.bottom = -DEFAULT_HEIGHT + 'px'
	  var translateStr = 'translate3d(0px,-' + offset + 'px,0px)'
	  scrollElement.style[cssPrefix + 'transform']
	    = cssPrefix + translateStr
	  scrollElement.style.transform = translateStr
	  this.dispatchEvent('loading')
	}
	
	Loading.prototype.show = function () {
	  this.display = true
	  this.node.style.display = '-webkit-box'
	  this.node.style.display = '-webkit-flex'
	  this.node.style.display = 'flex'
	}
	
	Loading.prototype.hide = function () {
	  this.display = false
	  var parent = this.getParent()
	  if (parent) {
	    var scrollElement = parent.scrollElement || parent.listElement
	    var scrollElementHeight = scrollElement.getBoundingClientRect().height
	    var scrollWrapHeight = parent.node.getBoundingClientRect().height
	    var left = scrollElementHeight
	      - parent.scroller.getScrollTop()
	      - scrollWrapHeight
	    if (left < 0) {
	      var offset = scrollElementHeight
	              - parent.node.getBoundingClientRect().height
	      var translateStr = 'translate3d(0px,-' + offset + 'px,0px)'
	      scrollElement.style[cssPrefix + 'transform']
	        = cssPrefix + translateStr
	      scrollElement.style.transform = translateStr
	    }
	  }
	  this.node.style.display = 'none'
	}
	
	Loading.prototype.attr = {
	  display: function (val) {
	    if (val === 'show') {
	      setTimeout(function () {
	        this.show()
	      }.bind(this), 0)
	    } else if (val === 'hide') {
	      setTimeout(function () {
	        this.hide()
	      }.bind(this), 0)
	    } else {
	      // TODO
	      console.error('h5render:attribute value of refresh \'display\' '
	          + val
	          + ' is invalid. Should be \'show\' or \'hide\'')
	    }
	  }
	}
	
	module.exports = Loading


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(85);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./loading.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./loading.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-loading {\n  // -webkit-box-align: center;\n  // -webkit-align-items: center;\n  // align-items: center;\n  // -webkit-box-pack: center;\n  // -webkit-justify-content: center;\n  // justify-content: center;\n  overflow: hidden;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  height: 0;\n}", ""]);
	
	// exports


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(37)
	var utils = __webpack_require__(15)
	
	__webpack_require__(87)
	
	function Spinner (data) {
	  Atomic.call(this, data)
	}
	
	Spinner.prototype = Object.create(Atomic.prototype)
	
	Spinner.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('weex-container', 'weex-spinner-wrap')
	  this.spinner = document.createElement('div')
	  this.spinner.classList.add('weex-element', 'weex-spinner')
	  node.appendChild(this.spinner)
	  return node
	}
	
	Spinner.prototype.updateStyle = function (style) {
	  Atomic.prototype.updateStyle.call(this, style)
	  if (style && style.color) {
	    this.setKeyframeColor(utils.getRgb(this.node.style.color))
	  }
	}
	
	Spinner.prototype.getStyleSheet = function () {
	  if (this.styleSheet) {
	    return
	  }
	  var styles = document.styleSheets
	  outer: for (var i = 0, l = styles.length; i < l; i++) {
	    var rules = styles[i].rules
	    for (var j = 0, m = rules.length; j < m; j++) {
	      var item = rules.item(j)
	      if (
	        (item.type === CSSRule.KEYFRAMES_RULE
	          || item.type === CSSRule.WEBKIT_KEYFRAMES_RULE)
	        && item.name === 'spinner') {
	        break outer
	      }
	    }
	  }
	  this.styleSheet = styles[i]
	}
	
	Spinner.prototype.setKeyframeColor = function (val) {
	  this.getStyleSheet()
	  var keyframeRules = this.computeKeyFrameRules(val)
	  var rules, item, cssRules, keyframe
	  rules = this.styleSheet.rules
	  for (var i = 0, l = rules.length; i < l; i++) {
	    item = rules.item(i)
	    if ((item.type === CSSRule.KEYFRAMES_RULE
	          || item.type === CSSRule.WEBKIT_KEYFRAMES_RULE)
	        && item.name === 'spinner') {
	      cssRules = item.cssRules
	      for (var j = 0, m = cssRules.length; j < m; j++) {
	        keyframe = cssRules[j]
	        if (keyframe.type === CSSRule.KEYFRAME_RULE
	          || keyframe.type === CSSRule.WEBKIT_KEYFRAME_RULE) {
	          keyframe.style.boxShadow = keyframeRules[j]
	        }
	      }
	    }
	  }
	}
	
	Spinner.prototype.computeKeyFrameRules = function (rgb) {
	  if (!rgb) {
	    return
	  }
	  var scaleArr = [
	    '0em -2.6em 0em 0em',
	    '1.8em -1.8em 0 0em',
	    '2.5em 0em 0 0em',
	    '1.75em 1.75em 0 0em',
	    '0em 2.5em 0 0em',
	    '-1.8em 1.8em 0 0em',
	    '-2.6em 0em 0 0em',
	    '-1.8em -1.8em 0 0em']
	  var colorArr = [
	    '1',
	    '0.2',
	    '0.2',
	    '0.2',
	    '0.2',
	    '0.2',
	    '0.5',
	    '0.7'].map(function (e) {
	      return 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + e + ')'
	    })
	  var rules = []
	  for (var i = 0; i < scaleArr.length; i++) {
	    var tmpColorArr = utils.loopArray(colorArr, i, 'r')
	    rules.push(scaleArr.map(function (scaleStr, i) {
	      return scaleStr + ' ' + tmpColorArr[i]
	    }).join(', '))
	  }
	  return rules
	}
	
	module.exports = Spinner


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(88);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./spinner.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./spinner.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-spinner-wrap {\n  width: 1.013333rem; /* 76px */\n  height: 1.013333rem;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n  align-items: center;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  justify-content: center;\n  overflow: visible;\n}\n\n.weex-spinner {\n  font-size: 0.16rem; /* 12px */\n  width: 1em;\n  height: 1em;\n  border-radius: 50%;\n  position: relative;\n  text-indent: -9999em;\n  -webkit-animation: spinner 1.1s infinite ease;\n  animation: spinner 1.1s infinite ease;\n  -webkit-transform: translateZ(0);\n  -ms-transform: translateZ(0);\n  transform: translateZ(0);\n}\n@-webkit-keyframes spinner {\n  0%,\n  100% {\n    box-shadow: 0em -2.6em 0em 0em #ffffff, 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.5), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.7);\n  }\n  12.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.7), 1.8em -1.8em 0 0em #ffffff, 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.5);\n  }\n  25% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.5), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.7), 2.5em 0em 0 0em #ffffff, 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  37.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.5), 2.5em 0em 0 0em rgba(255, 255, 255, 0.7), 1.75em 1.75em 0 0em #ffffff, 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  50% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.5), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.7), 0em 2.5em 0 0em #ffffff, -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  62.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.5), 0em 2.5em 0 0em rgba(255, 255, 255, 0.7), -1.8em 1.8em 0 0em #ffffff, -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  75% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.5), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.7), -2.6em 0em 0 0em #ffffff, -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  87.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.5), -2.6em 0em 0 0em rgba(255, 255, 255, 0.7), -1.8em -1.8em 0 0em #ffffff;\n  }\n}\n@keyframes spinner {\n  0%,\n  100% {\n    box-shadow: 0em -2.6em 0em 0em #ffffff, 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.5), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.7);\n  }\n  12.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.7), 1.8em -1.8em 0 0em #ffffff, 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.5);\n  }\n  25% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.5), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.7), 2.5em 0em 0 0em #ffffff, 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  37.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.5), 2.5em 0em 0 0em rgba(255, 255, 255, 0.7), 1.75em 1.75em 0 0em #ffffff, 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  50% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.5), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.7), 0em 2.5em 0 0em #ffffff, -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  62.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.5), 0em 2.5em 0 0em rgba(255, 255, 255, 0.7), -1.8em 1.8em 0 0em #ffffff, -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  75% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.5), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.7), -2.6em 0em 0 0em #ffffff, -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  87.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.5), -2.6em 0em 0 0em rgba(255, 255, 255, 0.7), -1.8em -1.8em 0 0em #ffffff;\n  }\n}\n", ""]);
	
	// exports


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(37)
	var utils = __webpack_require__(15)
	var logger = __webpack_require__(32)
	
	// A component to import web pages, which works like
	// a iframe element or a webview.
	// attrs:
	//   - src
	// events:
	//   - pagestart
	//   - pagefinish
	//   - error
	function Web (data) {
	  Atomic.call(this, data)
	}
	
	Web.prototype = Object.create(Atomic.prototype)
	
	Web.prototype.create = function () {
	  // Iframe's defect: can't use position:absolute and top, left, right,
	  // bottom all setting to zero and use margin to leave specified
	  // height for a blank area, and have to use 100% to fill the parent
	  // container, otherwise it will use a unwanted default size instead.
	  // Therefore a div as a iframe wrapper is needed here.
	  var node = document.createElement('div')
	  node.classList.add('weex-container')
	  this.web = document.createElement('iframe')
	  node.appendChild(this.web)
	  this.web.classList.add('weex-element')
	  this.web.style.width = '100%'
	  this.web.style.height = '100%'
	  this.web.style.border = 'none'
	  return node
	}
	
	Web.prototype.bindEvents = function (evts) {
	  Atomic.prototype.bindEvents.call(this, evts)
	  var that = this
	  this.web.addEventListener('load', function (e) {
	    that.dispatchEvent('pagefinish', utils.extend({
	      url: that.web.src
	    }))
	  })
	  window.addEventListener('message', this.msgHandler.bind(this))
	}
	
	Web.prototype.msgHandler = function (evt) {
	  var msg = evt.data
	  if (typeof msg === 'string') {
	    try {
	      msg = JSON.parse(msg)
	    } catch (e) {}
	  }
	  if (!msg) {
	    return
	  }
	  if (msg.type === 'weex') {
	    if (!utils.isArray(msg.content)) {
	      return logger.error('weex msg received by web component. msg.content'
	        + ' should be a array:', msg.content)
	    }
	    callNative(this.getComponentManager().instanceId, msg.content)
	  }
	}
	
	Web.prototype.attr = {
	  src: function (val) {
	    this.web.src = val
	    setTimeout(function () {
	      this.dispatchEvent('pagestart', { url: val })
	    }.bind(this), 0)
	  }
	}
	
	Web.prototype.goBack = function () {
	  this.web.contentWindow.history.back()
	}
	
	Web.prototype.goForward = function () {
	  this.web.contentWindow.history.forward()
	}
	
	Web.prototype.reload = function () {
	  this.web.contentWindow.location.reload()
	}
	
	module.exports = Web


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var dom = __webpack_require__(91)
	var event = __webpack_require__(99)
	var pageInfo = __webpack_require__(100)
	var stream = __webpack_require__(101)
	var modal = __webpack_require__(103)
	var animation = __webpack_require__(120)
	var webview = __webpack_require__(121)
	var timer = __webpack_require__(122)
	var navigator = __webpack_require__(123)
	
	var api = {
	  init: function (Weex) {
	    Weex.registerApiModule('dom', dom, dom._meta)
	    Weex.registerApiModule('event', event, event._meta)
	    Weex.registerApiModule('pageInfo', pageInfo, pageInfo._meta)
	    Weex.registerApiModule('stream', stream, stream._meta)
	    Weex.registerApiModule('modal', modal, modal._meta)
	    Weex.registerApiModule('animation', animation, animation._meta)
	    Weex.registerApiModule('webview', webview, webview._meta)
	    Weex.registerApiModule('timer', timer, timer._meta)
	    Weex.registerApiModule('navigator', navigator, navigator._meta)
	  }
	}
	
	module.exports = api

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var messageQueue = __webpack_require__(62)
	var FrameUpdater = __webpack_require__(18)
	var Component = __webpack_require__(24)
	var scroll = __webpack_require__(92)
	var config = __webpack_require__(13)
	var logger = __webpack_require__(32)
	
	var dom = {
	
	  /**
	   * createBody: create root component
	   * @param  {object} element
	   *    container|listview|scrollview
	   * @return {[type]}      [description]
	   */
	  createBody: function (element) {
	    var componentManager = this.getComponentManager()
	    element.scale = this.scale
	    element.instanceId = componentManager.instanceId
	    return componentManager.createBody(element)
	  },
	
	  addElement: function (parentRef, element, index) {
	    var componentManager = this.getComponentManager()
	    element.scale = this.scale
	    element.instanceId = componentManager.instanceId
	    return componentManager.addElement(parentRef, element, index)
	  },
	
	  removeElement: function (ref) {
	    var componentManager = this.getComponentManager()
	    return componentManager.removeElement(ref)
	  },
	
	  moveElement: function (ref, parentRef, index) {
	    var componentManager = this.getComponentManager()
	    return componentManager.moveElement(ref, parentRef, index)
	  },
	
	  addEvent: function (ref, type) {
	    var componentManager = this.getComponentManager()
	    return componentManager.addEvent(ref, type)
	  },
	
	  removeEvent: function (ref, type) {
	    var componentManager = this.getComponentManager()
	    return componentManager.removeEvent(ref, type)
	  },
	
	  /**
	   * updateAttrs: update attributes of component
	   * @param  {string} ref
	   * @param  {obj} attr
	   */
	  updateAttrs: function (ref, attr) {
	    var componentManager = this.getComponentManager()
	    return componentManager.updateAttrs(ref, attr)
	  },
	
	  /**
	   * updateStyle: udpate style of component
	   * @param {string} ref
	   * @param {obj} style
	   */
	  updateStyle: function (ref, style) {
	    var componentManager = this.getComponentManager()
	    return componentManager.updateStyle(ref, style)
	  },
	
	  createFinish: function () {
	    // TODO
	    // FrameUpdater.pause()
	  },
	
	  refreshFinish: function () {
	    // TODO
	  },
	
	  /**
	   * scrollToElement
	   * @param  {string} ref
	   * @param  {obj} options {offset:Number}
	   *   ps: scroll-to has 'ease' and 'duration'(ms) as options.
	   */
	  scrollToElement: function (ref, options) {
	    !options && (options = {})
	    var componentManager = this.getComponentManager()
	    var elem = componentManager.getElementByRef(ref)
	    if (!elem) {
	      return logger.error('component of ref ' + ref + ' doesn\'t exist.')
	    }
	    var parentScroller = elem.getParentScroller()
	    if (parentScroller) {
	      parentScroller.scroller.scrollToElement(elem.node, true)
	    } else {
	      var offsetTop = elem.node.getBoundingClientRect().top
	          + document.body.scrollTop
	      var offset = (Number(options.offset) || 0) * this.scale
	      var tween = scroll(0, offsetTop + offset, options)
	      tween.on('end', function () {
	        logger.log('scroll end.')
	      })
	    }
	  }
	
	}
	
	dom._meta = {
	  dom: [{
	    name: 'createBody',
	    args: ['object']
	  }, {
	    name: 'addElement',
	    args: ['string', 'object', 'number']
	  }, {
	    name: 'removeElement',
	    args: ['string']
	  }, {
	    name: 'moveElement',
	    args: ['string', 'string', 'number']
	  }, {
	    name: 'addEvent',
	    args: ['string', 'string']
	  }, {
	    name: 'removeEvent',
	    args: ['string', 'string']
	  }, {
	    name: 'updateAttrs',
	    args: ['string', 'object']
	  }, {
	    name: 'updateStyle',
	    args: ['string', 'object']
	  }, {
	    name: 'createFinish',
	    args: []
	  }, {
	    name: 'refreshFinish',
	    args: []
	  }, {
	    name: 'scrollToElement',
	    args: ['string', 'object']
	  }]
	}
	
	module.exports = dom


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var Tween = __webpack_require__(93);
	var raf = __webpack_require__(98);
	
	/**
	 * Expose `scrollTo`.
	 */
	
	module.exports = scrollTo;
	
	/**
	 * Scroll to `(x, y)`.
	 *
	 * @param {Number} x
	 * @param {Number} y
	 * @api public
	 */
	
	function scrollTo(x, y, options) {
	  options = options || {};
	
	  // start position
	  var start = scroll();
	
	  // setup tween
	  var tween = Tween(start)
	    .ease(options.ease || 'out-circ')
	    .to({ top: y, left: x })
	    .duration(options.duration || 1000);
	
	  // scroll
	  tween.update(function(o){
	    window.scrollTo(o.left | 0, o.top | 0);
	  });
	
	  // handle end
	  tween.on('end', function(){
	    animate = function(){};
	  });
	
	  // animate
	  function animate() {
	    raf(animate);
	    tween.update();
	  }
	
	  animate();
	  
	  return tween;
	}
	
	/**
	 * Return scroll position.
	 *
	 * @return {Object}
	 * @api private
	 */
	
	function scroll() {
	  var y = window.pageYOffset || document.documentElement.scrollTop;
	  var x = window.pageXOffset || document.documentElement.scrollLeft;
	  return { top: y, left: x };
	}


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var Emitter = __webpack_require__(94);
	var clone = __webpack_require__(95);
	var type = __webpack_require__(96);
	var ease = __webpack_require__(97);
	
	/**
	 * Expose `Tween`.
	 */
	
	module.exports = Tween;
	
	/**
	 * Initialize a new `Tween` with `obj`.
	 *
	 * @param {Object|Array} obj
	 * @api public
	 */
	
	function Tween(obj) {
	  if (!(this instanceof Tween)) return new Tween(obj);
	  this._from = obj;
	  this.ease('linear');
	  this.duration(500);
	}
	
	/**
	 * Mixin emitter.
	 */
	
	Emitter(Tween.prototype);
	
	/**
	 * Reset the tween.
	 *
	 * @api public
	 */
	
	Tween.prototype.reset = function(){
	  this.isArray = 'array' === type(this._from);
	  this._curr = clone(this._from);
	  this._done = false;
	  this._start = Date.now();
	  return this;
	};
	
	/**
	 * Tween to `obj` and reset internal state.
	 *
	 *    tween.to({ x: 50, y: 100 })
	 *
	 * @param {Object|Array} obj
	 * @return {Tween} self
	 * @api public
	 */
	
	Tween.prototype.to = function(obj){
	  this.reset();
	  this._to = obj;
	  return this;
	};
	
	/**
	 * Set duration to `ms` [500].
	 *
	 * @param {Number} ms
	 * @return {Tween} self
	 * @api public
	 */
	
	Tween.prototype.duration = function(ms){
	  this._duration = ms;
	  return this;
	};
	
	/**
	 * Set easing function to `fn`.
	 *
	 *    tween.ease('in-out-sine')
	 *
	 * @param {String|Function} fn
	 * @return {Tween}
	 * @api public
	 */
	
	Tween.prototype.ease = function(fn){
	  fn = 'function' == typeof fn ? fn : ease[fn];
	  if (!fn) throw new TypeError('invalid easing function');
	  this._ease = fn;
	  return this;
	};
	
	/**
	 * Stop the tween and immediately emit "stop" and "end".
	 *
	 * @return {Tween}
	 * @api public
	 */
	
	Tween.prototype.stop = function(){
	  this.stopped = true;
	  this._done = true;
	  this.emit('stop');
	  this.emit('end');
	  return this;
	};
	
	/**
	 * Perform a step.
	 *
	 * @return {Tween} self
	 * @api private
	 */
	
	Tween.prototype.step = function(){
	  if (this._done) return;
	
	  // duration
	  var duration = this._duration;
	  var now = Date.now();
	  var delta = now - this._start;
	  var done = delta >= duration;
	
	  // complete
	  if (done) {
	    this._from = this._to;
	    this._update(this._to);
	    this._done = true;
	    this.emit('end');
	    return this;
	  }
	
	  // tween
	  var from = this._from;
	  var to = this._to;
	  var curr = this._curr;
	  var fn = this._ease;
	  var p = (now - this._start) / duration;
	  var n = fn(p);
	
	  // array
	  if (this.isArray) {
	    for (var i = 0; i < from.length; ++i) {
	      curr[i] = from[i] + (to[i] - from[i]) * n;
	    }
	
	    this._update(curr);
	    return this;
	  }
	
	  // objech
	  for (var k in from) {
	    curr[k] = from[k] + (to[k] - from[k]) * n;
	  }
	
	  this._update(curr);
	  return this;
	};
	
	/**
	 * Set update function to `fn` or
	 * when no argument is given this performs
	 * a "step".
	 *
	 * @param {Function} fn
	 * @return {Tween} self
	 * @api public
	 */
	
	Tween.prototype.update = function(fn){
	  if (0 == arguments.length) return this.step();
	  this._update = fn;
	  return this;
	};

/***/ },
/* 94 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks['$' + event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var type;
	try {
	  type = __webpack_require__(96);
	} catch (_) {
	  type = __webpack_require__(96);
	}
	
	/**
	 * Module exports.
	 */
	
	module.exports = clone;
	
	/**
	 * Clones objects.
	 *
	 * @param {Mixed} any object
	 * @api public
	 */
	
	function clone(obj){
	  switch (type(obj)) {
	    case 'object':
	      var copy = {};
	      for (var key in obj) {
	        if (obj.hasOwnProperty(key)) {
	          copy[key] = clone(obj[key]);
	        }
	      }
	      return copy;
	
	    case 'array':
	      var copy = new Array(obj.length);
	      for (var i = 0, l = obj.length; i < l; i++) {
	        copy[i] = clone(obj[i]);
	      }
	      return copy;
	
	    case 'regexp':
	      // from millermedeiros/amd-utils - MIT
	      var flags = '';
	      flags += obj.multiline ? 'm' : '';
	      flags += obj.global ? 'g' : '';
	      flags += obj.ignoreCase ? 'i' : '';
	      return new RegExp(obj.source, flags);
	
	    case 'date':
	      return new Date(obj.getTime());
	
	    default: // string, number, boolean, 
	      return obj;
	  }
	}


/***/ },
/* 96 */
/***/ function(module, exports) {

	/**
	 * toString ref.
	 */
	
	var toString = Object.prototype.toString;
	
	/**
	 * Return the type of `val`.
	 *
	 * @param {Mixed} val
	 * @return {String}
	 * @api public
	 */
	
	module.exports = function(val){
	  switch (toString.call(val)) {
	    case '[object Date]': return 'date';
	    case '[object RegExp]': return 'regexp';
	    case '[object Arguments]': return 'arguments';
	    case '[object Array]': return 'array';
	    case '[object Error]': return 'error';
	  }
	
	  if (val === null) return 'null';
	  if (val === undefined) return 'undefined';
	  if (val !== val) return 'nan';
	  if (val && val.nodeType === 1) return 'element';
	
	  val = val.valueOf
	    ? val.valueOf()
	    : Object.prototype.valueOf.apply(val)
	
	  return typeof val;
	};


/***/ },
/* 97 */
/***/ function(module, exports) {

	
	// easing functions from "Tween.js"
	
	exports.linear = function(n){
	  return n;
	};
	
	exports.inQuad = function(n){
	  return n * n;
	};
	
	exports.outQuad = function(n){
	  return n * (2 - n);
	};
	
	exports.inOutQuad = function(n){
	  n *= 2;
	  if (n < 1) return 0.5 * n * n;
	  return - 0.5 * (--n * (n - 2) - 1);
	};
	
	exports.inCube = function(n){
	  return n * n * n;
	};
	
	exports.outCube = function(n){
	  return --n * n * n + 1;
	};
	
	exports.inOutCube = function(n){
	  n *= 2;
	  if (n < 1) return 0.5 * n * n * n;
	  return 0.5 * ((n -= 2 ) * n * n + 2);
	};
	
	exports.inQuart = function(n){
	  return n * n * n * n;
	};
	
	exports.outQuart = function(n){
	  return 1 - (--n * n * n * n);
	};
	
	exports.inOutQuart = function(n){
	  n *= 2;
	  if (n < 1) return 0.5 * n * n * n * n;
	  return -0.5 * ((n -= 2) * n * n * n - 2);
	};
	
	exports.inQuint = function(n){
	  return n * n * n * n * n;
	}
	
	exports.outQuint = function(n){
	  return --n * n * n * n * n + 1;
	}
	
	exports.inOutQuint = function(n){
	  n *= 2;
	  if (n < 1) return 0.5 * n * n * n * n * n;
	  return 0.5 * ((n -= 2) * n * n * n * n + 2);
	};
	
	exports.inSine = function(n){
	  return 1 - Math.cos(n * Math.PI / 2 );
	};
	
	exports.outSine = function(n){
	  return Math.sin(n * Math.PI / 2);
	};
	
	exports.inOutSine = function(n){
	  return .5 * (1 - Math.cos(Math.PI * n));
	};
	
	exports.inExpo = function(n){
	  return 0 == n ? 0 : Math.pow(1024, n - 1);
	};
	
	exports.outExpo = function(n){
	  return 1 == n ? n : 1 - Math.pow(2, -10 * n);
	};
	
	exports.inOutExpo = function(n){
	  if (0 == n) return 0;
	  if (1 == n) return 1;
	  if ((n *= 2) < 1) return .5 * Math.pow(1024, n - 1);
	  return .5 * (-Math.pow(2, -10 * (n - 1)) + 2);
	};
	
	exports.inCirc = function(n){
	  return 1 - Math.sqrt(1 - n * n);
	};
	
	exports.outCirc = function(n){
	  return Math.sqrt(1 - (--n * n));
	};
	
	exports.inOutCirc = function(n){
	  n *= 2
	  if (n < 1) return -0.5 * (Math.sqrt(1 - n * n) - 1);
	  return 0.5 * (Math.sqrt(1 - (n -= 2) * n) + 1);
	};
	
	exports.inBack = function(n){
	  var s = 1.70158;
	  return n * n * (( s + 1 ) * n - s);
	};
	
	exports.outBack = function(n){
	  var s = 1.70158;
	  return --n * n * ((s + 1) * n + s) + 1;
	};
	
	exports.inOutBack = function(n){
	  var s = 1.70158 * 1.525;
	  if ( ( n *= 2 ) < 1 ) return 0.5 * ( n * n * ( ( s + 1 ) * n - s ) );
	  return 0.5 * ( ( n -= 2 ) * n * ( ( s + 1 ) * n + s ) + 2 );
	};
	
	exports.inBounce = function(n){
	  return 1 - exports.outBounce(1 - n);
	};
	
	exports.outBounce = function(n){
	  if ( n < ( 1 / 2.75 ) ) {
	    return 7.5625 * n * n;
	  } else if ( n < ( 2 / 2.75 ) ) {
	    return 7.5625 * ( n -= ( 1.5 / 2.75 ) ) * n + 0.75;
	  } else if ( n < ( 2.5 / 2.75 ) ) {
	    return 7.5625 * ( n -= ( 2.25 / 2.75 ) ) * n + 0.9375;
	  } else {
	    return 7.5625 * ( n -= ( 2.625 / 2.75 ) ) * n + 0.984375;
	  }
	};
	
	exports.inOutBounce = function(n){
	  if (n < .5) return exports.inBounce(n * 2) * .5;
	  return exports.outBounce(n * 2 - 1) * .5 + .5;
	};
	
	// aliases
	
	exports['in-quad'] = exports.inQuad;
	exports['out-quad'] = exports.outQuad;
	exports['in-out-quad'] = exports.inOutQuad;
	exports['in-cube'] = exports.inCube;
	exports['out-cube'] = exports.outCube;
	exports['in-out-cube'] = exports.inOutCube;
	exports['in-quart'] = exports.inQuart;
	exports['out-quart'] = exports.outQuart;
	exports['in-out-quart'] = exports.inOutQuart;
	exports['in-quint'] = exports.inQuint;
	exports['out-quint'] = exports.outQuint;
	exports['in-out-quint'] = exports.inOutQuint;
	exports['in-sine'] = exports.inSine;
	exports['out-sine'] = exports.outSine;
	exports['in-out-sine'] = exports.inOutSine;
	exports['in-expo'] = exports.inExpo;
	exports['out-expo'] = exports.outExpo;
	exports['in-out-expo'] = exports.inOutExpo;
	exports['in-circ'] = exports.inCirc;
	exports['out-circ'] = exports.outCirc;
	exports['in-out-circ'] = exports.inOutCirc;
	exports['in-back'] = exports.inBack;
	exports['out-back'] = exports.outBack;
	exports['in-out-back'] = exports.inOutBack;
	exports['in-bounce'] = exports.inBounce;
	exports['out-bounce'] = exports.outBounce;
	exports['in-out-bounce'] = exports.inOutBounce;


/***/ },
/* 98 */
/***/ function(module, exports) {

	/**
	 * Expose `requestAnimationFrame()`.
	 */
	
	exports = module.exports = window.requestAnimationFrame
	  || window.webkitRequestAnimationFrame
	  || window.mozRequestAnimationFrame
	  || fallback;
	
	/**
	 * Fallback implementation.
	 */
	
	var prev = new Date().getTime();
	function fallback(fn) {
	  var curr = new Date().getTime();
	  var ms = Math.max(0, 16 - (curr - prev));
	  var req = setTimeout(fn, ms);
	  prev = curr;
	  return req;
	}
	
	/**
	 * Cancel.
	 */
	
	var cancel = window.cancelAnimationFrame
	  || window.webkitCancelAnimationFrame
	  || window.mozCancelAnimationFrame
	  || window.clearTimeout;
	
	exports.cancel = function(id){
	  cancel.call(window, id);
	};


/***/ },
/* 99 */
/***/ function(module, exports) {

	'use strict'
	
	var event = {
	  /**
	   * openUrl
	   * @param  {string} url
	   */
	  openURL: function (url) {
	    location.href = url
	  }
	
	}
	
	event._meta = {
	  event: [{
	    name: 'openURL',
	    args: ['string']
	  }]
	}
	
	module.exports = event

/***/ },
/* 100 */
/***/ function(module, exports) {

	'use strict'
	
	var pageInfo = {
	
	  setTitle: function (title) {
	    title = title || 'Weex HTML5'
	    try {
	      title = decodeURIComponent(title)
	    } catch (e) {}
	    document.title = title
	  }
	}
	
	pageInfo._meta = {
	  pageInfo: [{
	    name: 'setTitle',
	    args: ['string']
	  }]
	}
	
	module.exports = pageInfo

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict'
	
	var utils = __webpack_require__(15)
	var logger = __webpack_require__(32)
	
	__webpack_require__(102)
	
	var jsonpCnt = 0
	var ERROR_STATE = -1
	
	function _jsonp(config, callback, progressCallback) {
	  var cbName = 'jsonp_' + (++jsonpCnt)
	  var script, url, head
	
	  if (!config.url) {
	    logger.error('config.url should be set in _jsonp for \'fetch\' API.')
	  }
	
	  global[cbName] = (function (cb) {
	    return function (response) {
	      callback(response)
	      delete global[cb]
	    }
	  })(cbName)
	
	  script = document.createElement('script')
	  try {
	    url = lib.httpurl(config.url)
	  } catch (err) {
	    logger.error('invalid config.url in _jsonp for \'fetch\' API: '
	      + config.url)
	  }
	  url.params.callback = cbName
	  script.type = 'text/javascript'
	  script.src = url.toString()
	  // script.onerror is not working on IE or safari.
	  // but they are not considered here.
	  script.onerror = (function (cb) {
	    return function (err) {
	      logger.error('unexpected error in _jsonp for \'fetch\' API', err)
	      callback(err)
	      delete global[cb]
	    }
	  })(cbName)
	  head = document.getElementsByTagName('head')[0]
	  head.insertBefore(script, null)
	}
	
	function _xhr(config, callback, progressCallback) {
	  var xhr = new XMLHttpRequest()
	  xhr.responseType = config.type
	  xhr.open(config.method, config.url, true)
	
	  xhr.onload = function (res) {
	    callback({
	      status: xhr.status,
	      ok: xhr.status >= 200 && xhr.status < 300,
	      statusText: xhr.statusText,
	      data: xhr.response,
	      headers: xhr.getAllResponseHeaders().split('\n')
	        .reduce(function (obj, headerStr) {
	          var headerArr = headerStr.match(/(.+): (.+)/)
	          if (headerArr) {
	            obj[headerArr[1]] = headerArr[2]
	          }
	          return obj
	        }, {})
	    })
	  }
	
	  if (progressCallback) {
	    xhr.onprogress = function (e) {
	      progressCallback({
	        readyState: xhr.readyState,
	        status: xhr.status,
	        length: e.loaded,
	        total: e.total,
	        statusText: xhr.statusText,
	        headers: xhr.getAllResponseHeaders().split('\n')
	          .reduce(function (obj, headerStr) {
	            var headerArr = headerStr.match(/(.+): (.+)/)
	            if (headerArr) {
	              obj[headerArr[1]] = headerArr[2]
	            }
	            return obj
	          }, {})
	      })
	    }
	  }
	
	  xhr.onerror = function (err) {
	    logger.error('unexpected error in _xhr for \'fetch\' API', err)
	    callback({
	      status: ERROR_STATE,
	      ok: false,
	      statusText: '',
	      data: '',
	      headers: {}
	    })
	  }
	
	  xhr.send(config.body)
	}
	
	var stream = {
	
	  /**
	   * sendHttp
	   * Note: This API is deprecated. Please use stream.fetch instead.
	   * send a http request through XHR.
	   * @deprecated
	   * @param  {obj} params
	   *  - method: 'GET' | 'POST',
	   *  - url: url requested
	   * @param  {string} callbackId
	   */
	  sendHttp: function (param, callbackId) {
	    if (typeof param === 'string') {
	      try {
	        param = JSON.parse(param)
	      } catch (e) {
	        return
	      }
	    }
	    if (typeof param !== 'object' || !param.url) {
	      return logger.error(
	        'invalid config or invalid config.url for sendHttp API')
	    }
	
	    var sender = this.sender
	    var method = param.method || 'GET'
	    var xhr = new XMLHttpRequest()
	    xhr.open(method, param.url, true)
	    xhr.onload = function () {
	      sender.performCallback(callbackId, this.responseText)
	    }
	    xhr.onerror = function (error) {
	      return logger.error('unexpected error in sendHttp API', error)
	      sender.performCallback(
	        callbackId,
	        new Error('unexpected error in sendHttp API')
	      )
	    }
	    xhr.send()
	  },
	
	  /**
	   * fetch
	   * use stream.fetch to request for a json file, a plain text file or
	   * a arraybuffer for a file stream. (You can use Blob and FileReader
	   * API implemented by most modern browsers to read a arraybuffer.)
	   * @param  {object} options config options
	   *   - method {string} 'GET' | 'POST'
	   *   - headers {obj}
	   *   - url {string}
	   *   - mode {string} 'cors' | 'no-cors' | 'same-origin' | 'navigate'
	   *   - body
	   *   - type {string} 'json' | 'jsonp' | 'text'
	   * @param  {string} callbackId
	   * @param  {string} progressCallbackId
	   */
	  fetch: function (options, callbackId, progressCallbackId) {
	
	    var DEFAULT_METHOD = 'GET'
	    var DEFAULT_MODE = 'cors'
	    var DEFAULT_TYPE = 'text'
	
	    var methodOptions = ['GET', 'POST']
	    var modeOptions = ['cors', 'no-cors', 'same-origin', 'navigate']
	    var typeOptions = ['text', 'json', 'jsonp', 'arraybuffer']
	
	    var fallback = false  // fallback from 'fetch' API to XHR.
	    var sender = this.sender
	
	    var config = utils.extend({}, options)
	
	    // validate options.method
	    if (typeof config.method === 'undefined') {
	      config.method = DEFAULT_METHOD
	      logger.warn('options.method for \'fetch\' API has been set to '
	        + 'default value \'' + config.method + '\'')
	    } else if (methodOptions.indexOf((config.method + '')
	        .toUpperCase()) === -1) {
	      return logger.error('options.method \''
	        + config.method
	        + '\' for \'fetch\' API should be one of '
	        + methodOptions + '.')
	    }
	
	    // validate options.url
	    if (!config.url) {
	      return logger.error('options.url should be set for \'fetch\' API.')
	    }
	
	    // validate options.mode
	    if (typeof config.mode === 'undefined') {
	      config.mode = DEFAULT_MODE
	    } else if (modeOptions.indexOf((config.mode + '').toLowerCase()) === -1) {
	      return logger.error('options.mode \''
	        + config.mode
	        + '\' for \'fetch\' API should be one of '
	        + modeOptions + '.')
	    }
	
	    // validate options.type
	    if (typeof config.type === 'undefined') {
	      config.type = DEFAULT_TYPE
	      logger.warn('options.type for \'fetch\' API has been set to '
	        + 'default value \'' + config.type + '\'.')
	    } else if (typeOptions.indexOf((config.type + '').toLowerCase()) === -1) {
	      return logger.error('options.type \''
	          + config.type
	          + '\' for \'fetch\' API should be one of '
	          + typeOptions + '.')
	    }
	
	    var _callArgs = [config, function (res) {
	      sender.performCallback(callbackId, res)
	    }]
	    if (progressCallbackId) {
	      _callArgs.push(function (res) {
	        // Set 'keepAlive' to true for sending continuous callbacks
	        sender.performCallback(progressCallbackId, res, true)
	      })
	    }
	
	    if (config.type === 'jsonp') {
	      _jsonp.apply(this, _callArgs)
	    } else {
	      _xhr.apply(this, _callArgs)
	    }
	  }
	
	}
	
	stream._meta = {
	  stream: [{
	    name: 'sendHttp',
	    args: ['object', 'function']
	  }, {
	    name: 'fetch',
	    args: ['object', 'function', 'function']
	  }]
	}
	
	module.exports = stream
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 102 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a){var b={};Object.defineProperty(this,"params",{set:function(a){if("object"==typeof a){for(var c in b)delete b[c];for(var c in a)b[c]=a[c]}},get:function(){return b},enumerable:!0}),Object.defineProperty(this,"search",{set:function(a){if("string"==typeof a){0===a.indexOf("?")&&(a=a.substr(1));var c=a.split("&");for(var d in b)delete b[d];for(var e=0;e<c.length;e++){var f=c[e].split("=");if(void 0!==f[1]&&(f[1]=f[1].toString()),f[0])try{b[decodeURIComponent(f[0])]=decodeURIComponent(f[1])}catch(g){b[f[0]]=f[1]}}}},get:function(){var a=[];for(var c in b)if(void 0!==b[c])if(""!==b[c])try{a.push(encodeURIComponent(c)+"="+encodeURIComponent(b[c]))}catch(d){a.push(c+"="+b[c])}else try{a.push(encodeURIComponent(c))}catch(d){a.push(c)}return a.length?"?"+a.join("&"):""},enumerable:!0});var c;Object.defineProperty(this,"hash",{set:function(a){"string"==typeof a&&(a&&a.indexOf("#")<0&&(a="#"+a),c=a||"")},get:function(){return c},enumerable:!0}),this.set=function(a){a=a||"";var b;if(!(b=a.match(new RegExp("^([a-z0-9-]+:)?[/]{2}(?:([^@/:?]+)(?::([^@/:]+))?@)?([^:/?#]+)(?:[:]([0-9]+))?([/][^?#;]*)?(?:[?]([^#]*))?([#][^?]*)?$","i"))))throw new Error("Wrong uri scheme.");this.protocol=b[1]||("object"==typeof location?location.protocol:""),this.username=b[2]||"",this.password=b[3]||"",this.hostname=this.host=b[4],this.port=b[5]||"",this.pathname=b[6]||"/",this.search=b[7]||"",this.hash=b[8]||"",this.origin=this.protocol+"//"+this.hostname},this.toString=function(){var a=this.protocol+"//";return this.username&&(a+=this.username,this.password&&(a+=":"+this.password),a+="@"),a+=this.host,this.port&&"80"!==this.port&&(a+=":"+this.port),this.pathname&&(a+=this.pathname),this.search&&(a+=this.search),this.hash&&(a+=this.hash),a},a&&this.set(a.toString())}b.httpurl=function(a){return new c(a)}}(window,window.lib||(window.lib={}));;module.exports = window.lib['httpurl'];

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var modal = __webpack_require__(104)
	
	var msg = {
	
	  // duration: default is 0.8 seconds.
	  toast: function (config) {
	    modal.toast(config.message, config.duration)
	  },
	
	  // config:
	  //  - message: string
	  //  - okTitle: title of ok button
	  //  - callback
	  alert: function (config, callbackId) {
	    var sender =  this.sender
	    config.callback = function () {
	      sender.performCallback(callbackId)
	    }
	    modal.alert(config)
	  },
	
	  // config:
	  //  - message: string
	  //  - okTitle: title of ok button
	  //  - cancelTitle: title of cancel button
	  //  - callback
	  confirm: function (config, callbackId) {
	    var sender =  this.sender
	    config.callback = function (val) {
	      sender.performCallback(callbackId, val)
	    }
	    modal.confirm(config)
	  },
	
	  // config:
	  //  - message: string
	  //  - okTitle: title of ok button
	  //  - cancelTitle: title of cancel button
	  //  - callback
	  prompt: function (config, callbackId) {
	    var sender =  this.sender
	    config.callback = function (val) {
	      sender.performCallback(callbackId, val)
	    }
	    modal.prompt(config)
	  }
	
	}
	
	msg._meta = {
	  modal: [{
	    name: 'toast',
	    args: ['object']
	  }, {
	    name: 'alert',
	    args: ['object', 'string']
	  }, {
	    name: 'confirm',
	    args: ['object', 'string']
	  }, {
	    name: 'prompt',
	    args: ['object', 'string']
	  }]
	}
	
	module.exports = msg


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Alert = __webpack_require__(105)
	var Confirm = __webpack_require__(111)
	var Prompt = __webpack_require__(114)
	var toast = __webpack_require__(117)
	
	var modal = {
	
	  toast: function (msg, duration) {
	    toast.push(msg, duration)
	  },
	
	  alert: function (config) {
	    new Alert(config).show()
	  },
	
	  prompt: function (config) {
	    new Prompt(config).show()
	  },
	
	  confirm: function (config) {
	    new Confirm(config).show()
	  }
	
	}
	
	!window.lib && (window.lib = {})
	window.lib.modal = modal
	
	module.exports = modal

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Modal = __webpack_require__(106)
	__webpack_require__(109)
	
	var CONTENT_CLASS = 'content'
	var MSG_CLASS = 'content-msg'
	var BUTTON_GROUP_CLASS = 'btn-group'
	var BUTTON_CLASS = 'btn'
	
	function Alert(config) {
	  this.msg = config.message || ''
	  this.callback = config.callback
	  this.okTitle = config.okTitle || 'OK'
	  Modal.call(this)
	  this.node.classList.add('amfe-alert')
	}
	
	Alert.prototype = Object.create(Modal.prototype)
	
	Alert.prototype.createNodeContent = function () {
	  var content = document.createElement('div')
	  content.classList.add(CONTENT_CLASS)
	  this.node.appendChild(content)
	
	  var msg = document.createElement('div')
	  msg.classList.add(MSG_CLASS)
	  msg.appendChild(document.createTextNode(this.msg))
	  content.appendChild(msg)
	
	  var buttonGroup = document.createElement('div')
	  buttonGroup.classList.add(BUTTON_GROUP_CLASS)
	  this.node.appendChild(buttonGroup)
	  var button = document.createElement('div')
	  button.classList.add(BUTTON_CLASS, 'alert-ok')
	  button.appendChild(document.createTextNode(this.okTitle))
	  buttonGroup.appendChild(button)
	}
	
	Alert.prototype.bindEvents = function () {
	  Modal.prototype.bindEvents.call(this)
	  var button = this.node.querySelector('.' + BUTTON_CLASS)
	  button.addEventListener('click', function () {
	    this.destroy()
	    this.callback && this.callback()
	  }.bind(this))
	}
	
	module.exports = Alert


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	__webpack_require__(107)
	
	// there will be only one instance of modal.
	var MODAL_WRAP_CLASS = 'amfe-modal-wrap'
	var MODAL_NODE_CLASS = 'amfe-modal-node'
	
	function Modal() {
	  this.wrap = document.querySelector(MODAL_WRAP_CLASS)
	  this.node = document.querySelector(MODAL_NODE_CLASS)
	  if (!this.wrap) {
	    this.createWrap()
	  }
	  if (!this.node) {
	    this.createNode()
	  }
	  this.clearNode()
	  this.createNodeContent()
	  this.bindEvents()
	}
	
	Modal.prototype = {
	
	  show: function () {
	    this.wrap.style.display = 'block'
	    this.node.classList.remove('hide')
	  },
	
	  destroy: function () {
	    document.body.removeChild(this.wrap)
	    document.body.removeChild(this.node)
	    this.wrap = null
	    this.node = null
	  },
	
	  createWrap: function () {
	    this.wrap = document.createElement('div')
	    this.wrap.className = MODAL_WRAP_CLASS
	    document.body.appendChild(this.wrap)
	  },
	
	  createNode: function () {
	    this.node = document.createElement('div')
	    this.node.classList.add(MODAL_NODE_CLASS, 'hide')
	    document.body.appendChild(this.node)
	  },
	
	  clearNode: function () {
	    this.node.innerHTML = ''
	  },
	
	  createNodeContent: function () {
	
	    // do nothing.
	    // child classes can override this method.
	  },
	
	  bindEvents: function () {
	    this.wrap.addEventListener('click', function (e) {
	      e.preventDefault()
	      e.stopPropagation()
	    })
	  }
	}
	
	module.exports = Modal


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(108);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./modal.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./modal.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-modal-wrap {\n  display: none;\n  position: fixed;\n  z-index: 999999999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: #000;\n  opacity: 0.5;\n}\n\n.amfe-modal-node {\n  position: fixed;\n  z-index: 9999999999;\n  top: 50%;\n  left: 50%;\n  width: 6.666667rem;\n  min-height: 2.666667rem;\n  border-radius: 0.066667rem;\n  -webkit-transform: translate(-50%, -50%);\n  transform: translate(-50%, -50%);\n  background-color: #fff;\n}\n.amfe-modal-node.hide {\n  display: none;\n}\n.amfe-modal-node .content {\n  width: 100%;\n  min-height: 1.866667rem;\n  box-sizing: border-box;\n  font-size: 0.32rem;\n  line-height: 0.426667rem;\n  padding: 0.213333rem;\n  border-bottom: 1px solid #ddd;\n}\n.amfe-modal-node .btn-group {\n  width: 100%;\n  height: 0.8rem;\n  font-size: 0.373333rem;\n  text-align: center;\n}\n.amfe-modal-node .btn-group .btn {\n  box-sizing: border-box;\n  height: 0.8rem;\n  line-height: 0.8rem;\n}\n", ""]);
	
	// exports


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(110);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./alert.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./alert.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-alert .amfe-alert-ok {\n  width: 100%;\n}\n", ""]);
	
	// exports


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Modal = __webpack_require__(106)
	__webpack_require__(112)
	
	var CONTENT_CLASS = 'content'
	var MSG_CLASS = 'content-msg'
	var BUTTON_GROUP_CLASS = 'btn-group'
	var BUTTON_CLASS = 'btn'
	
	function Confirm(config) {
	  this.msg = config.message || ''
	  this.callback = config.callback
	  this.okTitle = config.okTitle || 'OK'
	  this.cancelTitle = config.cancelTitle || 'Cancel'
	  Modal.call(this)
	  this.node.classList.add('amfe-confirm')
	}
	
	Confirm.prototype = Object.create(Modal.prototype)
	
	Confirm.prototype.createNodeContent = function () {
	  var content = document.createElement('div')
	  content.classList.add(CONTENT_CLASS)
	  this.node.appendChild(content)
	
	  var msg = document.createElement('div')
	  msg.classList.add(MSG_CLASS)
	  msg.appendChild(document.createTextNode(this.msg))
	  content.appendChild(msg)
	
	  var buttonGroup = document.createElement('div')
	  buttonGroup.classList.add(BUTTON_GROUP_CLASS)
	  this.node.appendChild(buttonGroup)
	  var btnOk = document.createElement('div')
	  btnOk.appendChild(document.createTextNode(this.okTitle))
	  btnOk.classList.add('btn-ok', BUTTON_CLASS)
	  var btnCancel = document.createElement('div')
	  btnCancel.appendChild(document.createTextNode(this.cancelTitle))
	  btnCancel.classList.add('btn-cancel', BUTTON_CLASS)
	  buttonGroup.appendChild(btnOk)
	  buttonGroup.appendChild(btnCancel)
	  this.node.appendChild(buttonGroup)
	}
	
	Confirm.prototype.bindEvents = function () {
	  Modal.prototype.bindEvents.call(this)
	  var btnOk = this.node.querySelector('.' + BUTTON_CLASS + '.btn-ok')
	  var btnCancel = this.node.querySelector('.' + BUTTON_CLASS + '.btn-cancel')
	  btnOk.addEventListener('click', function () {
	    this.destroy()
	    this.callback && this.callback(this.okTitle)
	  }.bind(this))
	  btnCancel.addEventListener('click', function () {
	    this.destroy()
	    this.callback && this.callback(this.cancelTitle)
	  }.bind(this))
	}
	
	module.exports = Confirm


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(113);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./confirm.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./confirm.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-confirm .btn-group .btn {\n  float: left;\n  width: 50%;\n}\n.amfe-confirm .btn-group .btn.btn-ok {\n  border-right: 1px solid #ddd;\n}\n", ""]);
	
	// exports


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Modal = __webpack_require__(106)
	__webpack_require__(115)
	
	var CONTENT_CLASS = 'content'
	var MSG_CLASS = 'content-msg'
	var BUTTON_GROUP_CLASS = 'btn-group'
	var BUTTON_CLASS = 'btn'
	var INPUT_WRAP_CLASS = 'input-wrap'
	var INPUT_CLASS = 'input'
	
	function Prompt(config) {
	  this.msg = config.message || ''
	  this.defaultMsg = config.default || ''
	  this.callback = config.callback
	  this.okTitle = config.okTitle || 'OK'
	  this.cancelTitle = config.cancelTitle || 'Cancel'
	  Modal.call(this)
	  this.node.classList.add('amfe-prompt')
	}
	
	Prompt.prototype = Object.create(Modal.prototype)
	
	Prompt.prototype.createNodeContent = function () {
	
	  var content = document.createElement('div')
	  content.classList.add(CONTENT_CLASS)
	  this.node.appendChild(content)
	
	  var msg = document.createElement('div')
	  msg.classList.add(MSG_CLASS)
	  msg.appendChild(document.createTextNode(this.msg))
	  content.appendChild(msg)
	
	  var inputWrap = document.createElement('div')
	  inputWrap.classList.add(INPUT_WRAP_CLASS)
	  content.appendChild(inputWrap)
	  var input = document.createElement('input')
	  input.classList.add(INPUT_CLASS)
	  input.type = 'text'
	  input.autofocus = true
	  input.placeholder = this.defaultMsg
	  inputWrap.appendChild(input)
	
	  var buttonGroup = document.createElement('div')
	  buttonGroup.classList.add(BUTTON_GROUP_CLASS)
	  var btnOk = document.createElement('div')
	  btnOk.appendChild(document.createTextNode(this.okTitle))
	  btnOk.classList.add('btn-ok', BUTTON_CLASS)
	  var btnCancel = document.createElement('div')
	  btnCancel.appendChild(document.createTextNode(this.cancelTitle))
	  btnCancel.classList.add('btn-cancel', BUTTON_CLASS)
	  buttonGroup.appendChild(btnOk)
	  buttonGroup.appendChild(btnCancel)
	  this.node.appendChild(buttonGroup)
	}
	
	Prompt.prototype.bindEvents = function () {
	  Modal.prototype.bindEvents.call(this)
	  var btnOk = this.node.querySelector('.' + BUTTON_CLASS + '.btn-ok')
	  var btnCancel = this.node.querySelector('.' + BUTTON_CLASS + '.btn-cancel')
	  var that = this
	  btnOk.addEventListener('click', function () {
	    var val = document.querySelector('input').value
	    this.destroy()
	    this.callback && this.callback({
	      result: that.okTitle,
	      data: val
	    })
	  }.bind(this))
	  btnCancel.addEventListener('click', function () {
	    var val = document.querySelector('input').value
	    this.destroy()
	    this.callback && this.callback({
	      result: that.cancelTitle
	    })
	  }.bind(this))
	}
	
	module.exports = Prompt


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(116);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./prompt.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./prompt.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-prompt .input-wrap {\n  box-sizing: border-box;\n  width: 100%;\n  padding: 0.24rem 0.213333rem 0.213333rem;\n  height: 0.96rem;\n}\n.amfe-prompt .input-wrap .input {\n  box-sizing: border-box;\n  width: 100%;\n  height: 0.56rem;\n  line-height: 0.56rem;\n  font-size: 0.32rem;\n}\n.amfe-prompt .btn-group .btn {\n  float: left;\n  width: 50%;\n}\n.amfe-prompt .btn-group .btn.btn-ok {\n  border-right: 1px solid #ddd;\n}\n", ""]);
	
	// exports


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	__webpack_require__(118)
	
	var queue = []
	var timer
	var isProcessing = false
	var toastWin
	var TOAST_WIN_CLASS_NAME = 'amfe-toast'
	
	var DEFAULT_DURATION = 0.8
	
	function showToastWindow(msg, callback) {
	  var handleTransitionEnd = function () {
	    toastWin.removeEventListener('transitionend', handleTransitionEnd)
	    callback && callback()
	  }
	  if (!toastWin) {
	    toastWin = document.createElement('div')
	    toastWin.classList.add(TOAST_WIN_CLASS_NAME, 'hide')
	    document.body.appendChild(toastWin)
	  }
	  toastWin.innerHTML = msg
	  toastWin.addEventListener('transitionend', handleTransitionEnd)
	  setTimeout(function () {
	    toastWin.classList.remove('hide')
	  }, 0)
	}
	
	function hideToastWindow(callback) {
	  var handleTransitionEnd = function () {
	    toastWin.removeEventListener('transitionend', handleTransitionEnd)
	    callback && callback()
	  }
	  if (!toastWin) {
	    return
	  }
	  toastWin.addEventListener('transitionend', handleTransitionEnd)
	  toastWin.classList.add('hide')
	}
	
	var toast = {
	
	  push: function (msg, duration) {
	    queue.push({
	      msg: msg,
	      duration: duration || DEFAULT_DURATION
	    })
	    this.show()
	  },
	
	  show: function () {
	    var that = this
	
	    // All messages had been toasted already, so remove the toast window,
	    if (!queue.length) {
	      toastWin && toastWin.parentNode.removeChild(toastWin)
	      toastWin = null
	      return
	    }
	
	    // the previous toast is not ended yet.
	    if (isProcessing) {
	      return
	    }
	    isProcessing = true
	
	    var toastInfo = queue.shift()
	    showToastWindow(toastInfo.msg, function () {
	      timer = setTimeout(function () {
	        timer = null
	        hideToastWindow(function () {
	          isProcessing = false
	          that.show()
	        })
	      }, toastInfo.duration * 1000)
	    })
	  }
	
	}
	
	module.exports = {
	  push: toast.push.bind(toast)
	}


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(119);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./toast.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./toast.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(5)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-toast {\n  font-size: 0.32rem;\n  line-height: 0.426667rem;\n  position: fixed;\n  box-sizing: border-box;\n  max-width: 80%;\n  bottom: 2.666667rem;\n  left: 50%;\n  padding: 0.213333rem;\n  background-color: #000;\n  color: #fff;\n  text-align: center;\n  opacity: 0.6;\n  transition: all 0.4s ease-in-out;\n  border-radius: 0.066667rem;\n  -webkit-transform: translateX(-50%);\n  transform: translateX(-50%);\n}\n\n.amfe-toast.hide {\n  opacity: 0;\n}\n", ""]);
	
	// exports


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Sender = __webpack_require__(28)
	
	var _data = {}
	
	var animation = {
	
	  /**
	   * transition
	   * @param  {string} ref        [description]
	   * @param  {obj} config     [description]
	   * @param  {string} callbackId [description]
	   */
	  transition: function (ref, config, callbackId) {
	    var refData = _data[ref]
	    var stylesKey = JSON.stringify(config.styles)
	    var weexInstance = this
	    // If the same component perform a animation with exactly the same
	    // styles in a sequence with so short interval that the prev animation
	    // is still in playing, then the next animation should be ignored.
	    if (refData && refData[stylesKey]) {
	      return
	    }
	    if (!refData) {
	      refData = _data[ref] = {}
	    }
	    refData[stylesKey] = true
	    return this.getComponentManager().transition(ref, config, function () {
	      // Remove the stylesKey in refData so that the same animation
	      // can be played again after current animation is already finished.
	      delete refData[stylesKey]
	      weexInstance.sender.performCallback(callbackId)
	    })
	  }
	
	}
	
	animation._meta = {
	  animation: [{
	    name: 'transition',
	    args: ['string', 'object', 'string']
	  }]
	}
	
	module.exports = animation


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var sender = __webpack_require__(28)
	
	var webview = {
	
	  // ref: ref of the web component.
	  goBack: function (ref) {
	    var webComp = this.getComponentManager().getElementByRef(ref)
	    if (!webComp.goBack) {
	      console.error('error: the specified component has no method of'
	          + ' goBack. Please make sure it is a webview component.')
	      return
	    }
	    webComp.goBack()
	  },
	
	  // ref: ref of the web component.
	  goForward: function (ref) {
	    var webComp = this.getComponentManager().getElementByRef(ref)
	    if (!webComp.goForward) {
	      console.error('error: the specified component has no method of'
	          + ' goForward. Please make sure it is a webview component.')
	      return
	    }
	    webComp.goForward()
	  },
	
	  // ref: ref of the web component.
	  reload: function (ref) {
	    var webComp = this.getComponentManager().getElementByRef(ref)
	    if (!webComp.reload) {
	      console.error('error: the specified component has no method of'
	          + ' reload. Please make sure it is a webview component.')
	      return
	    }
	    webComp.reload()
	  }
	
	}
	
	webview._meta = {
	  webview: [{
	    name: 'goBack',
	    args: ['string']
	  }, {
	    name: 'goForward',
	    args: ['string']
	  }, {
	    name: 'reload',
	    args: ['string']
	  }]
	}
	
	module.exports = webview


/***/ },
/* 122 */
/***/ function(module, exports) {

	'use strict'
	
	var timer = {
	
	  setTimeout: function (timeoutCallbackId, delay) {
	    var sender = this.sender
	    var timerId = setTimeout(function () {
	      sender.performCallback(timeoutCallbackId)
	    }, delay)
	  },
	
	  clearTimeout: function (timerId) {
	    clearTimeout(timerId)
	  }
	
	}
	
	timer._meta = {
	  timer: [{
	    name: 'setTimeout',
	    args: ['function', 'number']
	  }, {
	    name: 'clearTimeout',
	    args: ['number']
	  }]
	}
	
	module.exports = timer


/***/ },
/* 123 */
/***/ function(module, exports) {

	'use strict'
	
	var navigator = {
	
	  // config
	  //  - url: the url to push
	  //  - animated: this configuration item is native only
	  //  callback is not currently supported
	  push: function (config, callbackId) {
	    window.location.href = config.url
	    this.sender.performCallback(callbackId)
	  },
	
	  // config
	  //  - animated: this configuration item is native only
	  //  callback is note currently supported
	  pop: function (config, callbackId) {
	    window.history.back()
	    this.sender.performCallback(callbackId)
	  }
	
	}
	
	navigator._meta = {
	  navigator: [{
	    name: 'push',
	    args: ['object', 'function']
	  }, {
	    name: 'pop',
	    args: ['object', 'function']
	  }]
	}
	
	module.exports = navigator


/***/ },
/* 124 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a){Object.defineProperty(this,"val",{value:a.toString(),enumerable:!0}),this.gt=function(a){return c.compare(this,a)>0},this.gte=function(a){return c.compare(this,a)>=0},this.lt=function(a){return c.compare(this,a)<0},this.lte=function(a){return c.compare(this,a)<=0},this.eq=function(a){return 0===c.compare(this,a)}}b.env=b.env||{},c.prototype.toString=function(){return this.val},c.prototype.valueOf=function(){for(var a=this.val.split("."),b=[],c=0;c<a.length;c++){var d=parseInt(a[c],10);isNaN(d)&&(d=0);var e=d.toString();e.length<5&&(e=Array(6-e.length).join("0")+e),b.push(e),1===b.length&&b.push(".")}return parseFloat(b.join(""))},c.compare=function(a,b){a=a.toString().split("."),b=b.toString().split(".");for(var c=0;c<a.length||c<b.length;c++){var d=parseInt(a[c],10),e=parseInt(b[c],10);if(window.isNaN(d)&&(d=0),window.isNaN(e)&&(e=0),e>d)return-1;if(d>e)return 1}return 0},b.version=function(a){return new c(a)}}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c=a.location.search.replace(/^\?/,"");if(b.env.params={},c)for(var d=c.split("&"),e=0;e<d.length;e++){d[e]=d[e].split("=");try{b.env.params[d[e][0]]=decodeURIComponent(d[e][1])}catch(f){b.env.params[d[e][0]]=d[e][1]}}}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c,d=a.navigator.userAgent;if(c=d.match(/Windows\sPhone\s(?:OS\s)?([\d\.]+)/))b.env.os={name:"Windows Phone",isWindowsPhone:!0,version:c[1]};else if(d.match(/Safari/)&&(c=d.match(/Android[\s\/]([\d\.]+)/)))b.env.os={version:c[1]},d.match(/Mobile\s+Safari/)?(b.env.os.name="Android",b.env.os.isAndroid=!0):(b.env.os.name="AndroidPad",b.env.os.isAndroidPad=!0);else if(c=d.match(/(iPhone|iPad|iPod)/)){var e=c[1];c=d.match(/OS ([\d_\.]+) like Mac OS X/),b.env.os={name:e,isIPhone:"iPhone"===e||"iPod"===e,isIPad:"iPad"===e,isIOS:!0,version:c[1].split("_").join(".")}}else b.env.os={name:"unknown",version:"0.0.0"};b.version&&(b.env.os.version=b.version(b.env.os.version))}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c,d=a.navigator.userAgent;(c=d.match(/(?:UCWEB|UCBrowser\/)([\d\.]+)/))?b.env.browser={name:"UC",isUC:!0,version:c[1]}:(c=d.match(/MQQBrowser\/([\d\.]+)/))?b.env.browser={name:"QQ",isQQ:!0,version:c[1]}:(c=d.match(/Firefox\/([\d\.]+)/))?b.env.browser={name:"Firefox",isFirefox:!0,version:c[1]}:(c=d.match(/MSIE\s([\d\.]+)/))||(c=d.match(/IEMobile\/([\d\.]+)/))?(b.env.browser={version:c[1]},d.match(/IEMobile/)?(b.env.browser.name="IEMobile",b.env.browser.isIEMobile=!0):(b.env.browser.name="IE",b.env.browser.isIE=!0),d.match(/Android|iPhone/)&&(b.env.browser.isIELikeWebkit=!0)):(c=d.match(/(?:Chrome|CriOS)\/([\d\.]+)/))?(b.env.browser={name:"Chrome",isChrome:!0,version:c[1]},d.match(/Version\/[\d+\.]+\s*Chrome/)&&(b.env.browser.name="Chrome Webview",b.env.browser.isWebview=!0)):d.match(/Safari/)&&(c=d.match(/Android[\s\/]([\d\.]+)/))?b.env.browser={name:"Android",isAndroid:!0,version:c[1]}:d.match(/iPhone|iPad|iPod/)?d.match(/Safari/)?(c=d.match(/Version\/([\d\.]+)/),b.env.browser={name:"Safari",isSafari:!0,version:c[1]}):(c=d.match(/OS ([\d_\.]+) like Mac OS X/),b.env.browser={name:"iOS Webview",isWebview:!0,version:c[1].replace(/\_/g,".")}):b.env.browser={name:"unknown",version:"0.0.0"},b.version&&(b.env.browser.version=b.version(b.env.browser.version))}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c=a.navigator.userAgent;c.match(/Weibo/i)?b.env.thirdapp={appname:"Weibo",isWeibo:!0}:c.match(/MicroMessenger/i)?b.env.thirdapp={appname:"Weixin",isWeixin:!0}:b.env.thirdapp=!1}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c,d,e=a.navigator.userAgent;(d=e.match(/WindVane[\/\s]([\d\.\_]+)/))&&(c=d[1]);var f=!1,g="",h="",i="";(d=e.match(/AliApp\(([A-Z\-]+)\/([\d\.]+)\)/i))&&(f=!0,g=d[1],i=d[2],h=g.indexOf("-PD")>0?b.env.os.isIOS?"iPad":b.env.os.isAndroid?"AndroidPad":b.env.os.name:b.env.os.name),!g&&e.indexOf("TBIOS")>0&&(g="TB"),f?b.env.aliapp={windvane:b.version(c||"0.0.0"),appname:g||"unkown",version:b.version(i||"0.0.0"),platform:h||b.env.os.name}:b.env.aliapp=!1,b.env.taobaoApp=b.env.aliapp}(window,window.lib||(window.lib={}));;module.exports = window.lib['env'];

/***/ }
/******/ ]);
module.exports = global.weex;